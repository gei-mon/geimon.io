<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
    <link rel="icon" href="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/favicon.png" type="image/png">
    <link rel="stylesheet" href="style.css">
    <title>Deck Page</title>
    <style>
        .card-button {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: transparent;
            border: none;
            cursor: pointer;
            pointer-events: all;
        }
        .card-wrapper {
            width: 100%;
            max-width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 0px;
            padding: 0px;
            transform-origin: top left;
            margin-left: 80px;
            margin-top: 20px;
        }
        .card-wrapper > div {
            transform-origin: top left;
            transform: scale(0.5);
            margin: 20px -60px;
        }
        .card-wrapper > div.stacked {
            margin-top: -200px; /* or whatever value you want */
        }
        .card-wrapper button {
            background-color: transparent;
            border: none;
            cursor: pointer;
        }
        .card-wrapper button:focus {
            outline: none;
        }
        .card-wrapper button:hover {
            outline: none;
        }
        .scaled-card,
        .scaled-card * {
            pointer-events: auto !important;
            user-select: text !important;  /* so you can try selecting text, verifying interaction */
        }
        #scaled-card .card-button {
            display: none !important;
            pointer-events: none !important;
        }
        .main-container {
            display: flex;
            height: 80vh; /* adjust as needed */
            gap: 10px;
            padding: 0px 10px 10px 10px;
            overflow: hidden; /* Prevent horizontal overflow */
        }
        /* Left side: existing container */
        .container {
            flex: 1;
            display: flex;
            gap: 10px;
            overflow-y: auto;
            padding-left: 320px;
        }
        /* Right side: search panel */
        .search-panel {
            width: 320px;
            background-color: #2f2f2f;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            padding: 0 12px;
            color: white;
            box-shadow: 0 0 10px black;
            max-height: 100vh;
            height: auto;           /* fix height */
            overflow-y: auto;     /* Allow scrolling */
            overflow-x: hidden;   /* Prevent horizontal overflow */
        }
        .search-panel input[type="search"] {
            padding: 8px 10px;
            font-size: 16px;
            border-radius: 6px;
            border: none;
            margin-bottom: 12px;
            outline: none;
            width: 100%;
            box-sizing: border-box;
            font-family: 'Racing Sans One', cursive;
            flex-shrink: 0;         /* input should not shrink */
        }
        .shrink-wrapper {
            flex-grow: 1;
            overflow-y: auto;    /* Allow vertical scrolling */
            overflow-x: hidden;  /* Prevent horizontal scroll */
            position: relative;
        }
        .shrink {
            zoom: 0.5;
            width: 100%;
            height: auto;
            overflow-y: auto;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .search-results {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: flex-start; /* align left */
            max-width: 100%; /* prevent overflow */
            overflow-x: hidden; /* disable horizontal scroll */
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: flex-start;
            width: 100%;
            overflow-x: hidden;
        }
        #card-wrapper > div, 
        .search-results > div {
            cursor: pointer;
        }
        .search-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: hidden;
            opacity: 0;
            max-height: 0;
            transition: max-height 0.4s ease, opacity 0.4s ease;
        }
        .search-options.open {
            opacity: 1;
            overflow: visible;
            max-height: 1000px;  /* enough to allow full expansion */
        }
        .type-btn {
            background-color: #444;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            font-family: 'Racing Sans One', cursive;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .type-btn:hover,
        .type-btn.active {
            background-color: #777;
        }
        #champion-filter {
            display: flex;
            flex-wrap: wrap;
        }
        .champ-filter-btn {
            background-color: #333;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            font-family: 'Racing Sans One', cursive;
            cursor: pointer;
        }
        .champ-filter-btn.active {
            background-color: #888;
        }
        .rarity-badge{
            position:absolute;           /* sit over the card */
            top:-24px; right:-16px;
            min-width:32px;              /* room for “Superior” */
            padding:2px 4px;
            font-size:32px;
            font-family:'Racing Sans One', cursive;
            color:#fff;  text-align:center; line-height:1;
            border-radius:4px; pointer-events:none;
            text-shadow:1px 1px 2px #000;
        }
        /* simple colour map – tweak as you like */
        .rarity-common    { background:#ff4444; }
        .rarity-rare  { background:#ff52ee; }
        .rarity-superior      { background:#d6ec10; }
        .rarity-legendary  { background:#9b27ff; }
        .scaled-card .rarity-badge{ display:none!important; }
        body.rarity-hidden .rarity-badge{ display:none!important; }
    </style>
</head>
<body style="background-color:rgb(78, 78, 78);">
  <img src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/try_2.png" class="bg-image" alt="">
    <div>
        <div style="display: flex; justify-content: center; align-items: center; gap: 12px; margin-top: 10px;">
            <span style="font-size: 275%; color: white; text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black; font-family: 'Racing Sans One', cursive;">Geimon!  -  </span>
            <h2 id="deck-name" style="font-size: 200%; margin: 0; text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black; font-family: 'Racing Sans One', cursive;"></h2>
        </div>
    </div>
    <div style="display: flex; flex-direction: row; align-items: center; justify-content: center;">
        <button id="sort-deck-btn" class="button buttonEvenSmaller" style="text-shadow: 1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black; background-color: rgb(206, 152, 15); color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer; margin-right: 10px;">
            Sort
        </button>
        <button id="save-deck-btn" class="button buttonEvenSmaller" style="text-shadow: 1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black; background-color: purple; color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer; margin-right: 10px;">
            Save
        </button>
        <button id="close-deck-btn" class="button buttonEvenSmaller" style="text-shadow: 1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black; background-color: rgb(187, 0, 0); color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer;">
            Close
        </button>
    </div>
    <div style="text-align: center; margin-top: 0px;">
    <button id="toggleRarityBtn" class="button buttonEvenSmaller" style="text-shadow: 1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black; background-color: rgb(35, 63, 220); color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer; width: 131.75px;">
        Hide Rarities
    </button>
        <button class="button buttonEvenSmaller" id="soloButton" onclick="window.open('solo.html', '_blank')" style="display: none; text-shadow: 1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black; background-color: rgb(115, 243, 166); color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer;">Test Deck</button>
    </div>

    <div id="deck-info" style="width: 60%; margin: 12px auto; padding: 8px 16px; background-color: #3a3a3a; color: white; font-family: 'Racing Sans One', cursive; font-size: 18px; border-radius: 8px; display: flex; gap: 8px; text-align: center; justify-content: space-between;">
        Loading deck info...
    </div>

      <div class="viewing-window" id="viewing-window">
        <div class="scaled-card" id="scaled-card"></div>
      </div>


    <div class="main-container">
    <div class="container">
        <div class="card-wrapper" id="card-wrapper"></div>
    </div>

    <div class="search-panel" id="search-panel">
        <p id="card-count" style="font-family: 'Racing Sans One', cursive; font-size: 18px; margin-bottom: 8px; margin-top: 8px;">Cards Found: 0</p>
        <input type="search" id="search-input" placeholder="Search cards by name..." autocomplete="off" />
        <button id="toggle-options-btn" style="margin-bottom: 8px; font-family: 'Racing Sans One', cursive; cursor: pointer;">
            Show More Options ▼
        </button>
        <div class="search-options" id="search-options">
            <div id="card-type-buttons" style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px;">
                <button class="type-btn" data-type="Champion">Champion</button>
                <button class="type-btn" data-type="Action">Action</button>
                <button class="type-btn" data-type="Equipment">Equipment</button>
                <button class="type-btn" data-type="Obelisk">Obelisk</button>
                <button class="type-btn" data-type="Rush">Rush</button>
                <button class="type-btn" data-type="Reflex">Reflex</button>
            </div>
            <div id="champion-filter" style="display: none; gap: 5px; margin-bottom: 10px;">
                <button class="champ-filter-btn" data-champ="All">All Champions</button>
                <button class="champ-filter-btn" data-champ="Basic">Basic Champions</button>
                <button class="champ-filter-btn" data-champ="Elite">Elite Champions</button>
            </div>
            <input type="search" id="tag-search-input" placeholder="Search cards by their tags..." />
            <input type="search" id="condition-search-input" placeholder="Search cards by their condition..." />
            <input type="search" id="cost-search-input" placeholder="Search cards by their cost..." />
            <input type="search" id="text-search-input" placeholder="Search cards by their text..." />
        </div>

            <div class="shrink-wrapper">
            <div class="shrink">
                <div class="row">
                    <div class="search-results" id="search-results"></div>
                </div>
            </div>
            </div>
        </div>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <div id="token-tooltip" style="display: none; position: absolute;">
        <div class="token-tooltip-text" style="font-family: 'Times New Roman', serif; font-size: 14px;"></div>
    </div>

    <p class="empty-deck-message" id="empty-message" style="display: none;">This deck is currently empty.</p>

    <script type="module">
        import { cards } from "./data/cards.js";
        import { tokens } from "./data/tokens.js";
        import { renderCard } from "./utils/cardRenderer.js";
        import { addTooltipListeners } from './utils/cardRenderer.js';
        import { addTokenTooltipListeners } from './utils/cardRenderer.js';

        document.addEventListener("DOMContentLoaded", () => {
            //const sortedCards = cards.sort((a, b) => a.name.localeCompare(b.name));
            //sortedCards.forEach(card => renderCard(card, container));

            let selectedCardType = null;

            document.querySelectorAll('.type-btn').forEach(button => {
                button.addEventListener("click", () => {
                    if (selectedCardType === button.dataset.type) {
                        selectedCardType = null; // toggle off
                        button.classList.remove("active");
                    } else {
                        selectedCardType = button.dataset.type;
                        document.querySelectorAll('.type-btn').forEach(b => b.classList.remove("active"));
                        button.classList.add("active");
                    }
                    renderSearchResults();
                    updateChampionSubfilterVisibility();
                });
            });

            let selectedChampionTier = "All";

            function updateChampionSubfilterVisibility() {
                const filter = document.getElementById("champion-filter");
                filter.style.display = selectedCardType === "Champion" ? "flex" : "none";
            }

            function appendRarityBadge(cardElement, rarity){
                if(!rarity || cardElement.querySelector('.rarity-badge')) return;
                cardElement.style.position = cardElement.style.position || 'relative';

                const badge        = document.createElement('span');
                badge.className    = `rarity-badge rarity-${rarity.toLowerCase()}`;
                //badge.textContent  = rarity;
                badge.textContent = rarity.trim()[0].toUpperCase();
                cardElement.appendChild(badge);
            }

            const toggleRarityBtn = document.getElementById('toggleRarityBtn');

            toggleRarityBtn.addEventListener('click', () => {
                document.body.classList.toggle('rarity-hidden');

                const hidden = document.body.classList.contains('rarity-hidden');
                toggleRarityBtn.textContent = hidden ? 'Show Rarities' : 'Hide Rarities';
            });

            document.querySelectorAll(".champ-filter-btn").forEach(btn => {
                btn.addEventListener("click", () => {
                    selectedChampionTier = btn.dataset.champ;
                    document.querySelectorAll(".champ-filter-btn").forEach(b => b.classList.remove("active"));
                    btn.classList.add("active");
                    renderSearchResults();
                });
            });

            const container = document.getElementById("card-wrapper");
            const emptyMessage = document.getElementById("empty-message");
            const deckNameElement = document.getElementById("deck-name");
            const viewingWindow = document.getElementById("viewing-window");
            const scaledCardContainer = document.getElementById("scaled-card");
            let lastHoveredCard = null;

            const searchInput = document.getElementById("search-input");
            const textSearchInput = document.getElementById("text-search-input");
            const searchResults = document.getElementById("search-results");
            const conditionInput = document.getElementById("condition-search-input");
            const costInput = document.getElementById("cost-search-input");

            conditionInput.addEventListener("input", renderSearchResults);
            costInput.addEventListener("input", renderSearchResults);

            if (deckNameElement && deckNameElement.textContent.trim() !== "") {
                document.title = deckNameElement.textContent.trim();
            }

            const toggleBtn = document.getElementById("toggle-options-btn");
            const searchOptions = document.getElementById("search-options");

            toggleBtn.addEventListener("click", () => {
                const isOpen = searchOptions.classList.toggle("open");
                toggleBtn.textContent = isOpen ? "Hide Extra Options ▲" : "Show More Options ▼";
            });

            container.innerHTML = "";  // Clear container before rendering

            const params = new URLSearchParams(location.search);
            let colName = params.get('collection');
            if (!colName) {
                alert("⚠️ sagaDeck.html loaded without a valid ?collection= parameter!");
                return;
            }
            localStorage.setItem('selectedDeckName', colName);
            deckNameElement.textContent = colName;
            document.title = "Deck: " + colName;

            let collectionIds = [];
            let collectionPool = [];
            let deckName = null;
            let deckIds       = JSON.parse(localStorage.getItem('workingDeck')||'[]');

            (async () => {
                try {
                    const url = 
                    `https://geimon-app-833627ba44e0.herokuapp.com/collection/get` +
                    `?name=${encodeURIComponent(colName)}`;
                    console.log("→ Fetching saga collection from:", url);
                    const r = await fetch(url, { credentials:'include' });
                    console.log("← HTTP status:", r.status);
                    if (!r.ok) {
                    throw new Error(`Network error: ${r.status}`);
                    }
                    const data = await r.json();
                    console.log("← JSON response:", data);

                    if (!data.success) {
                    throw new Error(`API returned success=false`);
                    }

                    collectionIds   = data.card_ids || [];
                    collectionPool  = cards.filter(c =>
                        collectionIds.includes(Number(c.id))
                    );
                    console.log("→ collectionIds:", collectionIds);
                    console.log("→ collectionPool length:", collectionPool.length);
                } catch (err) {
                    console.error("Failed to load saga collection:", err);
                    // Optionally show the user a visible error:
                    alert("Error loading your saga collection. See console.");
                } finally {
                    // Always render—so you can see either the loaded cards or
                    // that you really have an empty pool.
                    renderDeck();
                    renderSearchResults();
                }
            })();

            const saveDeckBtn = document.getElementById("save-deck-btn");
            const closeDeckBtn = document.getElementById("close-deck-btn");
            const sortDeckBtn = document.getElementById("sort-deck-btn");

            sortDeckBtn.addEventListener("click", () => {
                const typeOrder = {
                    Champion: 0,
                    Action: 1,
                    Equipment: 2,
                    Obelisk: 3,
                    Rush: 4,
                    Reflex: 5
                };

                const deckCards = deckIds
                    .map(id => cards.find(card => String(card.id) === String(id)))
                    .filter(Boolean);

                const sorted = [...deckCards].sort((a, b) => {
                    const typeCompare = (typeOrder[a.type] ?? 999) - (typeOrder[b.type] ?? 999);
                    if (typeCompare !== 0) return typeCompare;
                    return a.name.localeCompare(b.name);
                });

                deckIds = sorted.map(c=>c.id);
                localStorage.setItem('workingDeck', JSON.stringify(deckIds));
                renderDeck();
            });

            // Save Deck button functionality
            saveDeckBtn.addEventListener("click", async () => {
                const deckName = localStorage.getItem("selectedDeckName");

                try {
                const response = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/saveDeck', {
                    method: 'POST',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ deck_name: deckName, card_ids: deckIds })
                });

                if (!response.ok) {
                    const text = await response.text();
                    throw new Error(`HTTP ${response.status}: ${text}`);
                }

                const data = await response.json();

                if (data.success) {
                    alert("Deck saved!");
                } else {
                    alert("Failed to save deck: " + data.error);
                }
                } catch (error) {
                    console.error("Error saving deck:", error);
                    alert("Error saving deck. See console for details.");
                }

                window.location.href =
                    `sagaMatch.html?room=${encodeURIComponent(params.get('room'))}` +
                    `&deck=${encodeURIComponent(colName)}` +
                    `&user=${encodeURIComponent(params.get('user'))}`;
            });


            // Close Deck button functionality
            closeDeckBtn.addEventListener("click", () => {
            window.close();
            });

            function saveDeck() {
                localStorage.setItem("selectedDeckCards", JSON.stringify(deckIds));
                updateDeckInfo(
                    deckIds
                        .map(id => cards.find(card => String(card.id) === String(id)))
                        .filter(Boolean)
                );
            }

            function addCardToDeck(cardId) {
                if (!deckIds.includes(cardId)) {
                    deckIds.push(cardId);
                    localStorage.setItem('workingDeck', JSON.stringify(deckIds));
                    renderDeck();
                    renderSearchResults(); // refresh search to update buttons
                } else {
                    console.warn(`Card with ID ${cardId} is already in the deck.`);
                }
            }

            function removeCardFromDeck(cardId) {
                deckIds = deckIds.filter(id => String(id) !== String(cardId));
                localStorage.setItem('workingDeck', JSON.stringify(deckIds));
                renderDeck();
                renderSearchResults(); // refresh search to update buttons
            }

            function renderDeck() {
                container.innerHTML = "";
                if (deckIds.length === 0) {
                    emptyMessage.style.display = "block";
                    updateDeckInfo([]);
                } else {
                    emptyMessage.style.display = "none";

                    const deckCards = deckIds
                        .map(id => cards.find(card => String(card.id) === String(id)))
                        .filter(Boolean);

                    updateDeckInfo(deckCards);

                    deckCards.forEach(card => {
                        const cardElement = renderCard(card, container);
                        appendRarityBadge(cardElement, card.rarity);
                        if (cardElement) {
                            const button = document.createElement("button");
                            button.classList.add("card-button");
                            button.style.zIndex = "1000"; 
                            button.style.pointerEvents = "auto"; 
                            button.title = "Remove card from deck";
                            button.addEventListener("click", () => {
                                removeCardFromDeck(card.id);
                            });

                            cardElement.appendChild(button);

                            cardElement.addEventListener("mouseenter", () => {
                                scaledCardContainer.innerHTML = "";
                                const clone = cardElement.cloneNode(true);
                                const cloneButton = clone.querySelector(".card-button");
                                if (cloneButton) cloneButton.remove();
                                clone.classList.add("scaled-card");
                                scaledCardContainer.appendChild(clone);
                                addTooltipListeners(clone);
                                addTokenTooltipListeners(clone);
                                lastHoveredCard = clone;
                            });
                        }
                    });

                    container.addEventListener("mouseleave", () => {
                        lastHoveredCard = null;
                    });
                }
            }

        //renderDeck();

        //const sortedCards = [...cards].sort((a, b) => a.name.localeCompare(b.name));

        async function updateDeckInfo(deckCards) {
            const deckInfoDiv = document.getElementById('deck-info');
            deckInfoDiv.textContent = "Loading deck info...";
        // Count card types
        const counts = {
            Champions: 0,
            Actions: 0,
            Equipments: 0,
            Obelisks: 0,
            Rush: 0,
            Reflex: 0,
        };

        deckCards.forEach(card => {
            switch (card.type) {
                case 'Champion': counts.Champions++; break;
                case 'Action': counts.Actions++; break;
                case 'Equipment': counts.Equipments++; break;
                case 'Obelisk': counts.Obelisks++; break;
                case 'Rush': counts.Rush++; break;
                case 'Reflex': counts.Reflex++; break;
            }
        });

        const total = deckCards.length;

        async function checkLegality(deckName) {
            try {
                const response = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/isLegal?deck_name=${encodeURIComponent(deckName)}`, {
                method: 'GET',
                credentials: 'include'
                });
                const data = await response.json();
                return data.legal;
            } catch (error) {
                console.warn("Error fetching deck legality status:", error);
                return false;
            }
        }

        try {
            const deckName = localStorage.getItem("selectedDeckName");
            const isLegal = await checkLegality(deckName);
            const deckSizeColor = isLegal ? "#4CAF50" : "#ff4d4d";

            deckInfoDiv.innerHTML = `
                <span style="color: ${deckSizeColor};">Deck Size: ${total}</span>
                <span>Champions: ${counts.Champions}</span>
                <span>Actions: ${counts.Actions}</span>
                <span>Equipments: ${counts.Equipments}</span>
                <span>Obelisks: ${counts.Obelisks}</span>
                <span>Rush: ${counts.Rush}</span>
                <span>Reflex: ${counts.Reflex}</span>
            `;
        } catch (e) {
            // In case something fails unexpectedly, still update the info with 0s
            console.error("Failed to update deck info:", e);
            deckInfoDiv.innerHTML = `
                <span style="color: #ff4d4d;">Deck Size: 0</span>
                <span>Champions: 0</span>
                <span>Actions: 0</span>
                <span>Equipments: 0</span>
                <span>Obelisks: 0</span>
                <span>Rush: 0</span>
                <span>Reflex: 0</span>
            `;
        }
    }

        searchInput.addEventListener("input", () => {
            renderSearchResults();
        });

        textSearchInput.addEventListener("input", () => {
            renderSearchResults();
        });

        document.getElementById("tag-search-input").addEventListener("input", () => {
            renderSearchResults();
        });

        function renderSearchResults() {
            // 1) Clear previous results
            searchResults.innerHTML = "";

            // 2) Grab filter values
            const nameQuery      = searchInput.value.trim().toLowerCase();
            const textQuery      = textSearchInput.value.trim().toLowerCase();
            const tagQuery       = (document.getElementById("tag-search-input").value || "").trim().toLowerCase();
            const conditionQuery = conditionInput.value.trim().toLowerCase();
            const costQuery      = costInput.value.trim().toLowerCase();

            // 3) Filter from the player's collectionPool
            let filteredCards = collectionPool.filter(card => {
                // Name
                if (nameQuery && !card.name.toLowerCase().includes(nameQuery)) {
                return false;
                }
                // Text
                if (textQuery && !card.abilities.some(a => a.text.toLowerCase().includes(textQuery))) {
                return false;
                }
                // Tags
                if (tagQuery && !(card.tags && card.tags.some(t => t.toLowerCase().includes(tagQuery)))) {
                return false;
                }
                // Condition
                if (conditionQuery && !(card.condition && card.condition.toLowerCase().includes(conditionQuery))) {
                return false;
                }
                // Cost
                if (costQuery && !String(card.cost || "").toLowerCase().includes(costQuery)) {
                return false;
                }
                // Type
                if (selectedCardType && card.type !== selectedCardType) {
                return false;
                }
                // Champion tier (only when type is Champion)
                if (selectedCardType === "Champion" && selectedChampionTier !== "All") {
                if (selectedChampionTier === "Basic" && card.cost !== "Basic") {
                    return false;
                }
                if (selectedChampionTier === "Elite" && card.cost === "Basic") {
                    return false;
                }
                }
                return true;
            });

            filteredCards.sort((a, b) =>
                a.name.localeCompare(b.name, undefined, { sensitivity: 'base' })
            );

            // 4) Update count display
            document.getElementById("card-count").textContent =
                `Cards Displayed: ${filteredCards.length}`;

            // 5) Render each filtered card
            filteredCards.forEach(card => {
                const cardElement = renderCard(card, searchResults);
                appendRarityBadge(cardElement, card.rarity);

                // Override the built-in button behavior
                const button = cardElement.querySelector(".card-button");
                if (button) {
                const isInDeck = deckIds.some(id => String(id) === String(card.id));
                if (isInDeck) {
                    button.disabled = true;
                    button.style.cursor = "not-allowed";
                    button.title = "Already in deck";
                } else {
                    button.disabled = false;
                    button.style.cursor = "pointer";
                    button.title = "Add card to deck";
                    button.onclick = () => addCardToDeck(card.id);
                }
                }

                // Hover‐to‐scale behavior (unchanged)
                cardElement.addEventListener("mouseenter", () => {
                scaledCardContainer.innerHTML = "";
                const clone = cardElement.cloneNode(true);
                clone.querySelectorAll(".card-button").forEach(btn => btn.remove());
                clone.classList.add("scaled-card");
                scaledCardContainer.appendChild(clone);
                setTimeout(() => {
                    scaledCardContainer.querySelectorAll(".card-button").forEach(btn => btn.remove());
                }, 0);
                addTooltipListeners(clone);
                addTokenTooltipListeners(clone);
                lastHoveredCard = clone;
                });
                cardElement.addEventListener("mouseleave", () => {
                lastHoveredCard = null;
                });
            });
        }
        //renderSearchResults();
    });

    function adjustCardSpacing() {
        const wrapper = document.getElementById('card-wrapper');
        const cards = wrapper.children;
        if (!cards.length) return;

        // Reset all cards first
        Array.from(cards).forEach(card => card.classList.remove('stacked'));

        const cardStyle = getComputedStyle(cards[0]);
        const cardWidth = cards[0].offsetWidth +
            parseFloat(cardStyle.marginLeft) +
            parseFloat(cardStyle.marginRight);

        const cardsPerRow = Math.floor(wrapper.offsetWidth / cardWidth);

        // Apply the class to cards in row 2 and beyond
        for (let i = cardsPerRow; i < cards.length; i++) {
            cards[i].classList.add('stacked');
        }
    }

    // Run on load and on resize
    window.addEventListener('DOMContentLoaded', adjustCardSpacing);
    window.addEventListener('resize', adjustCardSpacing);
    </script>
</body>
</html>
