<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
    <link rel="icon" href="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/favicon.png" type="image/png">
    <link rel="stylesheet" href="style.css">
    <title>Deck Page</title>
    <style>
        .card-button {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: transparent;
            border: none;
            cursor: pointer;
            pointer-events: all;
        }
        .card-wrapper {
            width: 100%;
            max-width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 0px;
            padding: 0px;
            transform-origin: top left;
            margin-left: 80px;
            margin-top: 20px;
        }
        .card-wrapper > div {
            transform-origin: top left;
            transform: scale(0.5);
            margin: 20px -60px;
        }
        .card-wrapper > div.stacked {
            margin-top: -200px; /* or whatever value you want */
        }
        .card-wrapper button {
            background-color: transparent;
            border: none;
            cursor: pointer;
        }
        .card-wrapper button:focus {
            outline: none;
        }
        .card-wrapper button:hover {
            outline: none;
        }
        .scaled-card,
        .scaled-card * {
            pointer-events: auto !important;
            user-select: text !important;  /* so you can try selecting text, verifying interaction */
        }
        #scaled-card .card-button {
            display: none !important;
            pointer-events: none !important;
        }
        .viewing-window {
            width: 300px;
            height: 460px;
            background-color: #2f2f2f;
            margin-right: 16px;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            border-radius: 8px;
            box-shadow: 0 0 10px black;
            position: fixed;
            top: 411px;              /* vertically center, optional */
            left: 20px;
            transform: translateY(-50%);  /* vertically center, optional */
            z-index: 10;           /* make sure it stays above background layers */
        }
        :root{
            --side-width: 320px;      /* width of both viewer & search   */
            --side-gap :  20px;       /* the left/right gaps you used    */
        }
        .main-container{
            /* reserve space for BOTH side panels + their gaps            */
            margin-left : calc(var(--side-width) + var(--side-gap));
            margin-right: calc(var(--side-width) + var(--side-gap));
            width: auto;              /* flexbox will shrink as needed   */
        }
        .container {
            flex: 1;
            display: flex;
            gap: 10px;
            overflow-y: auto;
            padding-left: 30px;
            padding-right: 0px;
        }
        .search-panel {
            width: 360px;
            background-color: #2f2f2f;
            border-radius: 8px;
            position: fixed;
            top: 100px;
            right: 20px;
            flex-direction: column;
            padding: 0 12px;
            color: white;
            box-shadow: 0 0 10px black;
            height: 85vh;           /* fix height */
            overflow-y: auto;     /* Allow scrolling */
            overflow-x: hidden;   /* Prevent horizontal overflow */
        }
        .search-panel input[type="search"] {
            padding: 8px 10px;
            font-size: 16px;
            border-radius: 6px;
            border: none;
            margin-bottom: 12px;
            outline: none;
            width: 100%;
            box-sizing: border-box;
            font-family: 'Racing Sans One', cursive;
            flex-shrink: 0;         /* input should not shrink */
        }
        .shrink-wrapper {
            flex-grow: 1;
            overflow-y: auto;    /* Allow vertical scrolling */
            overflow-x: hidden;  /* Prevent horizontal scroll */
            position: relative;
        }
        .shrink {
            zoom: 0.57;
            width: 100%;
            height: auto;
            overflow-y: auto;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .search-results {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            max-width: 100%;
            overflow-x: hidden;
            padding-top: 25px;
            padding-bottom: 25px;
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: flex-start;
            width: 100%;
            overflow-x: hidden;
        }
        #card-wrapper > div, 
        .search-results > div {
            cursor: pointer;
        }
        .search-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow: hidden;
            opacity: 0;
            max-height: 0;
            transition: max-height 0.4s ease, opacity 0.4s ease;
        }
        .search-options.open {
            opacity: 1;
            overflow: visible;
            max-height: 1000px;  /* enough to allow full expansion */
        }
        .type-btn {
            background-color: #444;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            font-family: 'Racing Sans One', cursive;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .type-btn:hover,
        .type-btn.active {
            background-color: #777;
        }
        #champion-filter {
            display: flex;
            flex-wrap: wrap;
        }
        .champ-filter-btn {
            background-color: #333;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            font-family: 'Racing Sans One', cursive;
            cursor: pointer;
        }
        .champ-filter-btn.active {
            background-color: #888;
        }
        .rarity-badge{
            position:absolute;           /* sit over the card */
            top:-24px; right:-16px;
            min-width:32px;              /* room for “Superior” */
            padding:2px 4px;
            font-size:32px;
            font-family:'Racing Sans One', cursive;
            color:#fff;  text-align:center; line-height:1;
            border-radius:4px; pointer-events:none;
            text-shadow:1px 1px 2px #000;
        }
        /* simple colour map – tweak as you like */
        .rarity-common    { background:#ff4444; }
        .rarity-rare  { background:#ff52ee; }
        .rarity-superior      { background:#d6ec10; }
        .rarity-legendary  { background:#9b27ff; }
        .scaled-card .rarity-badge{ display:none!important; }
        body.rarity-hidden .rarity-badge{ display:none!important; }
    </style>
</head>
<body style="background-color:rgb(78, 78, 78);">
  <img src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/try_2.png" class="bg-image" alt="">
    <div>
        <div style="display: flex; justify-content: center; align-items: center; gap: 12px; margin-top: 10px;">
            <span style="font-size: 275%; color: white; text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black; font-family: 'Racing Sans One', cursive;">Geimon!  -  </span>
            <h2 id="deck-name" style="font-size: 200%; margin: 0; text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black; font-family: 'Racing Sans One', cursive;"></h2>
        </div>
    </div>
    <div style="display: flex; flex-direction: row; align-items: center; justify-content: center;">
        <button id="sort-deck-btn" class="button buttonEvenSmaller" style="text-shadow: 1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black; background-color: rgb(206, 152, 15); color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer; margin-right: 10px;">
            Sort
        </button>
        <button id="save-deck-btn" class="button buttonEvenSmaller" style="text-shadow: 1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black; background-color: purple; color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer; margin-right: 10px;">
            Save
        </button>
        <button id="close-deck-btn" class="button buttonEvenSmaller" style="text-shadow: 1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black; background-color: rgb(187, 0, 0); color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer;">
            Close
        </button>
    </div>

    <div style="text-align: center; margin-top: 0px;">
        <button id="undoBtn" class="button buttonEvenSmaller" style="text-shadow: 1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black; background-color: rgb(170, 45, 107); color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer;">
            ← &nbsp; Undo
        </button>

        <button id="toggleRarityBtn" class="button buttonEvenSmaller" style="margin: 0 6px; text-shadow: 1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black; background-color: rgb(35, 63, 220); color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer; width: 131.75px;">
            Hide Rarities
        </button>

        <button id="redoBtn" class="button buttonEvenSmaller" style="text-shadow: 1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black; background-color: rgb(0, 118, 10); color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer;">
            Redo &nbsp; →
        </button>

        <button class="button buttonEvenSmaller" id="soloButton" onclick="window.open('solo.html', '_blank')" style="display: none; text-shadow: 1px 1px 2px black, -1px -1px 2px black, 1px -1px 2px black, -1px 1px 2px black; background-color: rgb(115, 243, 166); color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer;">Test Deck</button>
    </div>

    <div id="deck-info" style="position: relative; left: -45px; width: 1000px; margin: 12px auto; padding: 8px 16px; background-color: #3a3a3a; color: white; font-family: 'Racing Sans One', cursive; font-size: 18px; border-radius: 8px; display: flex; gap: 8px; text-align: center; justify-content: space-between;">
        Loading deck info...
    </div>
    <div class="viewing-window" id="viewing-window">
        <div class="scaled-card" id="scaled-card"></div>
    </div>

    <div class="main-container">
        <div class="container">
            <div class="card-wrapper" id="card-wrapper"></div>
        </div>
    </div>

    <div class="search-panel" id="search-panel">
        <p id="card-count" style="font-family: 'Racing Sans One', cursive; font-size: 18px; margin-bottom: 8px; margin-top: 8px;">Cards Found: 0</p>
        <input type="search" id="search-input" placeholder="Search cards by name..." autocomplete="off" />
        <button id="toggle-options-btn" style="margin-bottom: 8px; font-family: 'Racing Sans One', cursive; cursor: pointer; width: 300px; display:block; margin:0 auto 8px;">
            Show More Options ▼
        </button>
        <div class="search-options" id="search-options">
            <span class="line-gap"></span>
            <div id="card-type-buttons" style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px; justify-content:center;">
                <button class="type-btn" data-type="Champion">Champion</button>
                <button class="type-btn" data-type="Action">Action</button>
                <button class="type-btn" data-type="Equipment">Equipment</button>
                <button class="type-btn" data-type="Obelisk">Obelisk</button>
                <button class="type-btn" data-type="Rush">Rush</button>
                <button class="type-btn" data-type="Reflex">Reflex</button>
            </div>
            <div id="champion-filter" style="display: none; gap: 5px; margin-bottom: 10px;">
                <button class="champ-filter-btn" data-champ="All">All Champions</button>
                <button class="champ-filter-btn" data-champ="Basic">Basic Champions</button>
                <button class="champ-filter-btn" data-champ="Elite">Elite Champions</button>
            </div>
            <input type="search" id="tag-search-input" placeholder="Search cards by their tags..." />
            <input type="search" id="condition-search-input" placeholder="Search cards by their condition..." />
            <input type="search" id="cost-search-input" placeholder="Search cards by their cost..." />
            <input type="search" id="text-search-input" placeholder="Search cards by their text..." />
        </div>

            <div class="shrink-wrapper">
            <div class="shrink">
                <div class="row">
                    <div class="search-results" id="search-results"></div>
                </div>
            </div>
            </div>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <div id="token-tooltip" style="display: none; position: absolute;">
        <div class="token-tooltip-text" style="font-family: 'Times New Roman', serif; font-size: 14px;"></div>
    </div>

    <p class="empty-deck-message" id="empty-message" style="display: none;">This deck is currently empty.</p>

    <script type="module">
        import { cards } from "./data/cards.js";
        import { tokens } from "./data/tokens.js";
        import { renderCard } from "./utils/cardRenderer.js";
        import { addTooltipListeners } from './utils/cardRenderer.js';
        import { addTokenTooltipListeners } from './utils/cardRenderer.js';

        document.addEventListener("DOMContentLoaded", () => {
            //const sortedCards = cards.sort((a, b) => a.name.localeCompare(b.name));
            //sortedCards.forEach(card => renderCard(card, container));

            let selectedCardType = null;

            document.querySelectorAll('.type-btn').forEach(button => {
                button.addEventListener("click", () => {
                    if (selectedCardType === button.dataset.type) {
                        selectedCardType = null; // toggle off
                        button.classList.remove("active");
                    } else {
                        selectedCardType = button.dataset.type;
                        document.querySelectorAll('.type-btn').forEach(b => b.classList.remove("active"));
                        button.classList.add("active");
                    }
                    renderSearchResults();
                    updateChampionSubfilterVisibility();
                });
            });

            let selectedChampionTier = "All";

            function updateChampionSubfilterVisibility() {
                const filter = document.getElementById("champion-filter");
                filter.style.display = selectedCardType === "Champion" ? "flex" : "none";
            }

            function appendRarityBadge(cardElement, rarity){
                if(!rarity || cardElement.querySelector('.rarity-badge')) return;
                cardElement.style.position = cardElement.style.position || 'relative';

                const badge        = document.createElement('span');
                badge.className    = `rarity-badge rarity-${rarity.toLowerCase()}`;
                //badge.textContent  = rarity;
                badge.textContent = rarity.trim()[0].toUpperCase();
                cardElement.appendChild(badge);
            }

            // History stacks
            const undoStack = [];
            const redoStack = [];

            // Utility to push a fresh operation and clear redo
            function record(op) {
                undoStack.push(op);
                redoStack.length = 0;
            }

            const toggleRarityBtn = document.getElementById('toggleRarityBtn');

            toggleRarityBtn.addEventListener('click', () => {
                document.body.classList.toggle('rarity-hidden');

                const hidden = document.body.classList.contains('rarity-hidden');
                toggleRarityBtn.textContent = hidden ? 'Show Rarities' : 'Hide Rarities';
            });

            document.querySelectorAll(".champ-filter-btn").forEach(btn => {
                btn.addEventListener("click", () => {
                    selectedChampionTier = btn.dataset.champ;
                    document.querySelectorAll(".champ-filter-btn").forEach(b => b.classList.remove("active"));
                    btn.classList.add("active");
                    renderSearchResults();
                });
            });

            const container = document.getElementById("card-wrapper");
            const emptyMessage = document.getElementById("empty-message");
            const deckNameElement = document.getElementById("deck-name");
            const viewingWindow = document.getElementById("viewing-window");
            const scaledCardContainer = document.getElementById("scaled-card");
            let lastHoveredCard = null;

            const searchInput = document.getElementById("search-input");
            const textSearchInput = document.getElementById("text-search-input");
            const searchResults = document.getElementById("search-results");
            const conditionInput = document.getElementById("condition-search-input");
            const costInput = document.getElementById("cost-search-input");

            conditionInput.addEventListener("input", renderSearchResults);
            costInput.addEventListener("input", renderSearchResults);

            if (deckNameElement && deckNameElement.textContent.trim() !== "") {
                document.title = "Deck: " + deckNameElement.textContent.trim();
            }

            const toggleBtn = document.getElementById("toggle-options-btn");
            const searchOptions = document.getElementById("search-options");

            toggleBtn.addEventListener("click", () => {
                const isOpen = searchOptions.classList.toggle("open");
                toggleBtn.textContent = isOpen ? "Hide Extra Options ▲" : "Show More Options ▼";
            });

            container.innerHTML = "";  // Clear container before rendering

            // ─── Determine which search pool to use ───────────────
            const params = new URLSearchParams(location.search);
            const deckName = localStorage.getItem('selectedDeckName') || params.get('deck');
            deckNameElement.textContent = deckName;
            document.title = `Deck: ${deckName}`;
            const sagaCollections = JSON.parse(localStorage.getItem('sagaCollections') || '[]');
            const useCollectionPool = sagaCollections.includes(deckName);

            let searchPool = [];      // will hold either the limited or full set
            let deckIds    = [];      // current deck contents

            // seed deckIds from selector flow (unchanged)
            const storedCards = localStorage.getItem("selectedDeckCards");
            deckIds = storedCards ? JSON.parse(storedCards) : [];

            // now choose searchPool
            if (useCollectionPool) {
            // saga‐created deck: fetch just its collection
            fetch(`https://geimon-app-833627ba44e0.herokuapp.com/collection/get?name=${encodeURIComponent(deckName)}`, { credentials:'include' })
                .then(r => r.json())
                .then(data => {
                    if (data.success) {
                        searchPool = cards.filter(c => data.card_ids.includes(String(c.id)));
                    } else {
                        searchPool = cards; // fallback to full pool on error
                    }
                    renderDeck();
                    renderSearchResults();
                })
                .catch(() => {
                    searchPool = cards;
                    renderDeck();
                    renderSearchResults();
                });
            } else {
                // standard deck: full 302-card pool
                searchPool = cards;
                renderDeck();
                renderSearchResults();
            }

            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');

            undoBtn.addEventListener('click', () => {
                const op = undoStack.pop();
                if (!op) return;     // nothing to undo
                if (op.type === 'add') {
                    deckIds.push(op.cardId);
                    // inverse for redo:
                    redoStack.push({ type: 'remove', cardId: op.cardId });
                } else if (op.type === 'remove') {
                    deckIds = deckIds.filter(id => String(id) !== String(op.cardId));
                    redoStack.push({ type: 'add', cardId: op.cardId });
                }
                localStorage.setItem("selectedDeckCards", JSON.stringify(deckIds));
                renderDeck();
                renderSearchResults();
            });

            redoBtn.addEventListener('click', () => {
                const op = redoStack.pop();
                if (!op) return;     // nothing to redo
                if (op.type === 'add') {
                    deckIds.push(op.cardId);
                    undoStack.push({ type: 'remove', cardId: op.cardId });
                } else if (op.type === 'remove') {
                    deckIds = deckIds.filter(id => String(id) !== String(op.cardId));
                    undoStack.push({ type: 'add', cardId: op.cardId });
                }
                localStorage.setItem("selectedDeckCards", JSON.stringify(deckIds));
                renderDeck();
                renderSearchResults();
            });

            const saveDeckBtn = document.getElementById("save-deck-btn");
            const closeDeckBtn = document.getElementById("close-deck-btn");
            const sortDeckBtn = document.getElementById("sort-deck-btn");

            sortDeckBtn.addEventListener("click", () => {
                const typeOrder = {
                    Champion: 0,
                    Action: 1,
                    Equipment: 2,
                    Obelisk: 3,
                    Rush: 4,
                    Reflex: 5
                };

                // 1) Map deckIds → card objects
                const deckCards = deckIds
                    .map(id => cards.find(card => String(card.id) === String(id)))
                    .filter(Boolean);

                // 2) Sort by type then name
                const sorted = [...deckCards].sort((a, b) => {
                    const typeCompare = (typeOrder[a.type] ?? 999) - (typeOrder[b.type] ?? 999);
                    if (typeCompare !== 0) return typeCompare;
                    return a.name.localeCompare(b.name);
                });

                // 3) Rebuild deckIds in sorted order
                deckIds = sorted.map(card => card.id);

                // 4) Persist the reordered deck
                localStorage.setItem("selectedDeckCards", JSON.stringify(deckIds));

                // 5) Re-render the deck pane
                renderDeck();
            });


            // Save Deck button functionality
            saveDeckBtn.addEventListener("click", async () => {
            const deckName = localStorage.getItem("selectedDeckName") || "My Deck";

            try {
            const response = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/saveDeck', {
                method: 'POST',
                credentials: 'include',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ deck_name: deckName, card_ids: deckIds })
            });

            if (!response.ok) {
                const text = await response.text();
                throw new Error(`HTTP ${response.status}: ${text}`);
            }

            const data = await response.json();

            if (data.success) {
                alert("Deck saved!");
            } else {
                alert("Failed to save deck: " + data.error);
            }
            } catch (error) {
            console.error("Error saving deck:", error);
            alert("Error saving deck. See console for details.");
            }
        });


            // Close Deck button functionality
            closeDeckBtn.addEventListener("click", () => {
            window.close();
            });

            function saveDeck() {
                localStorage.setItem("selectedDeckCards", JSON.stringify(deckIds));
                updateDeckInfo(
                    deckIds
                        .map(id => cards.find(card => String(card.id) === String(id)))
                        .filter(Boolean)
                );
            }

            function addCardToDeck(cardId) {
                if (!deckIds.includes(cardId)) {
                    record({ type: 'remove', cardId });
                    deckIds.push(cardId);
                    localStorage.setItem("selectedDeckCards", JSON.stringify(deckIds));
                    renderDeck();
                    renderSearchResults(); // refresh search to update buttons
                } else {
                    console.warn(`Card with ID ${cardId} is already in the deck.`);
                }
            }

            function removeCardFromDeck(cardId) {
                record({ type: 'add', cardId });
                deckIds = deckIds.filter(id => String(id) !== String(cardId));
                localStorage.setItem("selectedDeckCards", JSON.stringify(deckIds));
                renderDeck();
                renderSearchResults(); // refresh search to update buttons
            }

            function renderDeck() {
                container.innerHTML = "";
                if (deckIds.length === 0) {
                    emptyMessage.style.display = "block";
                    updateDeckInfo([]);
                } else {
                    emptyMessage.style.display = "none";

                    const deckCards = deckIds
                        .map(id => cards.find(card => String(card.id) === String(id)))
                        .filter(Boolean);

                    updateDeckInfo(deckCards);

                    deckCards.forEach(card => {
                        const cardElement = renderCard(card, container);
                        appendRarityBadge(cardElement, card.rarity);
                        if (cardElement) {
                            const button = document.createElement("button");
                            button.classList.add("card-button");
                            button.style.zIndex = "1000"; 
                            button.style.pointerEvents = "auto"; 
                            button.title = "Remove card from deck";
                            button.addEventListener("click", () => {
                                removeCardFromDeck(card.id);
                            });

                            cardElement.appendChild(button);

                            cardElement.addEventListener("mouseenter", () => {
                                scaledCardContainer.innerHTML = "";
                                const clone = cardElement.cloneNode(true);
                                const cloneButton = clone.querySelector(".card-button");
                                if (cloneButton) cloneButton.remove();
                                clone.classList.add("scaled-card");
                                scaledCardContainer.appendChild(clone);
                                addTooltipListeners(clone);
                                addTokenTooltipListeners(clone);
                                lastHoveredCard = clone;
                            });
                        }
                    });

                    container.addEventListener("mouseleave", () => {
                        lastHoveredCard = null;
                    });
                }
            }

    renderDeck();

    const sortedCards = [...cards].sort((a, b) => a.name.localeCompare(b.name));

    async function updateDeckInfo(deckCards) {
        const deckInfoDiv = document.getElementById('deck-info');
        deckInfoDiv.textContent = "Loading deck info...";
    // Count card types
    const counts = {
        Champions: 0,
        Actions: 0,
        Equipments: 0,
        Obelisks: 0,
        Rush: 0,
        Reflex: 0,
    };

    deckCards.forEach(card => {
        switch (card.type) {
            case 'Champion': counts.Champions++; break;
            case 'Action': counts.Actions++; break;
            case 'Equipment': counts.Equipments++; break;
            case 'Obelisk': counts.Obelisks++; break;
            case 'Rush': counts.Rush++; break;
            case 'Reflex': counts.Reflex++; break;
        }
    });

    const total = deckCards.length;

    async function checkLegality(deckName) {
    try {
        const response = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/isLegal?deck_name=${encodeURIComponent(deckName)}`, {
        method: 'GET',
        credentials: 'include'
        });
        const data = await response.json();
        return data.legal;
    } catch (error) {
        console.warn("Error fetching deck legality status:", error);
        return false;
    }
    }

    try {
        const storedDeckName = localStorage.getItem("selectedDeckName") || "My Deck";
        const isLegal = await checkLegality(storedDeckName);
        const deckSizeColor = isLegal ? "#4CAF50" : "#ff4d4d";

        deckInfoDiv.innerHTML = `
            <span style="color: ${deckSizeColor};">Deck Size: ${total}</span>
            <span>Champions: ${counts.Champions}</span>
            <span>Actions: ${counts.Actions}</span>
            <span>Equipments: ${counts.Equipments}</span>
            <span>Obelisks: ${counts.Obelisks}</span>
            <span>Rush: ${counts.Rush}</span>
            <span>Reflex: ${counts.Reflex}</span>
        `;
    } catch (e) {
        // In case something fails unexpectedly, still update the info with 0s
        console.error("Failed to update deck info:", e);
        deckInfoDiv.innerHTML = `
            <span style="color: #ff4d4d;">Deck Size: 0</span>
            <span>Champions: 0</span>
            <span>Actions: 0</span>
            <span>Equipments: 0</span>
            <span>Obelisks: 0</span>
            <span>Rush: 0</span>
            <span>Reflex: 0</span>
        `;
    }
}

    searchInput.addEventListener("input", () => {
        renderSearchResults();
    });

    textSearchInput.addEventListener("input", () => {
        renderSearchResults();
    });

    document.getElementById("tag-search-input").addEventListener("input", () => {
        renderSearchResults();
    });

    function renderSearchResults() {

        searchResults.innerHTML = "";
        const nameQuery = searchInput.value.trim().toLowerCase();
        const textQuery = textSearchInput.value.trim().toLowerCase();
        const tagQuery = (document.getElementById("tag-search-input").value || "").trim().toLowerCase();
        const conditionQuery = conditionInput.value.trim().toLowerCase();
        const costQuery = costInput.value.trim().toLowerCase();

        const filteredCards = searchPool.filter(card => {
            const nameMatches = !nameQuery || card.name.toLowerCase().includes(nameQuery);
            const textMatches = !textQuery || card.abilities.some(ability => ability.text.toLowerCase().includes(textQuery));
            const tagMatches = !tagQuery || (card.tags && card.tags.some(tag => tag.toLowerCase().includes(tagQuery)));
            const conditionMatches = !conditionQuery || (card.condition && card.condition.toLowerCase().includes(conditionQuery));
            const costMatches = !costQuery || (String(card.cost || "").toLowerCase().includes(costQuery));
            const typeMatches = !selectedCardType || card.type === selectedCardType;
            const champMatches =
                selectedCardType !== "Champion" || selectedChampionTier === "All" ||
                (selectedChampionTier === "Basic" && card.cost === "Basic") ||
                (selectedChampionTier === "Elite" && card.cost !== "Basic");
            return nameMatches && textMatches && tagMatches && conditionMatches && costMatches && typeMatches && champMatches;
        });

        filteredCards.sort((a, b) =>
            a.name.localeCompare(b.name, undefined, { sensitivity: 'base' })
        );

        const cardCountElement = document.getElementById("card-count");
        cardCountElement.textContent = `Cards Displayed: ${filteredCards.length}`;

        filteredCards.forEach(card => {
            const cardElement = renderCard(card, searchResults);
            appendRarityBadge(cardElement, card.rarity);

            if (cardElement) {
                const button = cardElement.querySelector(".card-button"); // ✅ override existing one

            if (button) {
                const isInDeck = deckIds.some(id => String(id) === String(card.id));

                if (isInDeck) {
                    button.disabled = true;
                    button.style.cursor = "not-allowed";
                    button.title = "Already in deck";
                } else {
                    button.disabled = false;
                    button.style.cursor = "pointer";
                    button.title = "Add card to deck";
                    button.onclick = () => addCardToDeck(card.id); // ✅ override default handler
                    button._originalHandler = button.onclick;      // optional, but preserves pattern
                }
            }

                cardElement.appendChild(button);

                cardElement.addEventListener("mouseenter", () => {
                    scaledCardContainer.innerHTML = "";
                    const clone = cardElement.cloneNode(true);
                    clone.querySelectorAll(".card-button").forEach(btn => btn.remove());
                    clone.classList.add("scaled-card");
                    scaledCardContainer.appendChild(clone);
                    setTimeout(() => {
                        scaledCardContainer.querySelectorAll(".card-button").forEach(btn => btn.remove());
                    }, 0);
                    addTooltipListeners(clone);
                    addTokenTooltipListeners(clone);
                    lastHoveredCard = clone;
                });

                cardElement.addEventListener("mouseleave", () => {
                    lastHoveredCard = null;
                });
            }
        });
    }
        renderSearchResults();
    });

    function adjustCardSpacing() {
        const wrapper = document.getElementById('card-wrapper');
        const cards = wrapper.children;
        if (!cards.length) return;

        // Reset all cards first
        Array.from(cards).forEach(card => card.classList.remove('stacked'));

        const cardStyle = getComputedStyle(cards[0]);
        const cardWidth = cards[0].offsetWidth +
            parseFloat(cardStyle.marginLeft) +
            parseFloat(cardStyle.marginRight);

        const cardsPerRow = Math.floor(wrapper.offsetWidth / cardWidth);

        // Apply the class to cards in row 2 and beyond
        for (let i = cardsPerRow; i < cards.length; i++) {
            cards[i].classList.add('stacked');
        }
    }

    // Run on load and on resize
    window.addEventListener('DOMContentLoaded', adjustCardSpacing);
    window.addEventListener('resize', adjustCardSpacing);
    </script>
</body>
</html>
