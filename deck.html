<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
    <link rel="stylesheet" href="style.css">
    <title>Deck Page</title>
    <style>
        .card-button {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: transparent;
            border: none;
            cursor: pointer;
            pointer-events: all;
        }
        .card-wrapper {
            width: 100%;
            max-width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 0px;
            padding: 0px;
            transform-origin: top left;
            margin-left: 80px;
            margin-top: 20px;
        }
        .card-wrapper > div {
            transform-origin: top left;
            transform: scale(0.5);
            margin: 20px -60px;
        }
        .card-wrapper > div.stacked {
            margin-top: -200px; /* or whatever value you want */
        }
        .card-wrapper button {
            background-color: transparent;
            border: none;
            cursor: pointer;
        }
        .card-wrapper button:focus {
            outline: none;
        }
        .card-wrapper button:hover {
            outline: none;
        }
        .scaled-card,
        .scaled-card * {
        pointer-events: auto !important;
        user-select: text !important;  /* so you can try selecting text, verifying interaction */
        }
        .main-container {
        display: flex;
        height: 80vh; /* adjust as needed */
        gap: 10px;
        padding: 0px 10px 10px 10px;
        overflow: hidden; /* Prevent horizontal overflow */
        }
        /* Left side: existing container */
        .container {
        flex: 1;
        display: flex;
        gap: 10px;
        overflow-y: auto;
        padding-left: 320px;
        }
        /* Right side: search panel */
        .search-panel {
        width: 320px;
        background-color: #2f2f2f;
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        padding: 0 12px;
        color: white;
        box-shadow: 0 0 10px black;
        height: 60vh;           /* fix height */
        overflow-y: auto;     /* Allow scrolling */
        overflow-x: hidden;   /* Prevent horizontal overflow */
        }
        .search-panel input[type="search"] {
        padding: 8px 10px;
        font-size: 16px;
        border-radius: 6px;
        border: none;
        margin-bottom: 12px;
        outline: none;
        width: 100%;
        box-sizing: border-box;
        font-family: 'Racing Sans One', cursive;
        flex-shrink: 0;         /* input should not shrink */
        }
        .shrink-wrapper {
            flex-grow: 1;
            overflow-y: auto;    /* Allow vertical scrolling */
            overflow-x: hidden;  /* Prevent horizontal scroll */
            position: relative;
        }
        .shrink {
            width: 640px;          /* keep same width */
            transform: scale(0.5);
            transform-origin: top left;
            height: auto;
            overflow-y: auto;      /* scroll vertically here */
            overflow-x: hidden;    /* disable horizontal scroll */
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            flex-grow: 0;
        }
        .search-results {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: flex-start; /* align left */
            max-width: 100%; /* prevent overflow */
            overflow-x: hidden; /* disable horizontal scroll */
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: flex-start;
            width: 100%;
            overflow-x: hidden;
        }
        #card-wrapper > div, 
        .search-results > div {
            cursor: pointer;
        }
        .search-options {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease, opacity 0.4s ease;
            opacity: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-top: 0;
            padding-bottom: 0;
        }
        .search-options.open {
            max-height: 300px;
            opacity: 1;
            padding-top: 10px;
            padding-bottom: 100px;
        }
    </style>
</head>
<body style="background-color:rgb(78, 78, 78);">
  <img src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/try_2.png" class="bg-image" alt="">
    <div>
        <p style="font-size: 200%; text-align:center; font-size: 260%; text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;"><game-title>Geimon!</game-title></p>
        <h2 id="deck-name" style="font-size: 200%; color:white; text-align:center; text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black; margin-top: -20px;"></h2>
    </div>
    <div style="display: flex; flex-direction: row; align-items: center; justify-content: center;">
        <button id="sort-deck-btn" class="button buttonEvenSmaller" style="background-color: rgb(206, 152, 15); color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer; margin-right: 10px;">
            Sort
        </button>
        <button id="save-deck-btn" class="button buttonEvenSmaller" style="background-color: purple; color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer; margin-right: 10px;">
            Save
        </button>
        <button id="close-deck-btn" class="button buttonEvenSmaller" style="background-color: rgb(187, 0, 0); color: white; padding: 8px 16px; font-family: 'Racing Sans One', cursive; border-radius: 6px; cursor: pointer;">
            Close
        </button>
    </div>

    <div id="deck-info" style="width: 60%; margin: 12px auto; padding: 8px 16px; background-color: #3a3a3a; color: white; font-family: 'Racing Sans One', cursive; font-size: 18px; border-radius: 8px; display: flex; gap: 8px; text-align: center; justify-content: space-between;">
        Loading deck info...
    </div>

      <div class="viewing-window" id="viewing-window">
        <div class="scaled-card" id="scaled-card"></div>
      </div>

    <div class="main-container">
    <div class="container">
        <div class="card-wrapper" id="card-wrapper"></div>
    </div>

    <div class="search-panel" id="search-panel">
        <p id="card-count" style="font-family: 'Racing Sans One', cursive; font-size: 18px; margin-bottom: 8px; margin-top: 8px;">Cards Found: 0</p>
        <input type="search" id="search-input" placeholder="Search cards by name..." autocomplete="off" />
        <button id="toggle-options-btn" style="margin-bottom: 8px; font-family: 'Racing Sans One', cursive; cursor: pointer;">
            Show More Options ▼
        </button>
        <div class="search-options" id="search-options">
            <input type="search" id="tag-search-input" placeholder="Search cards by tag..." />
            <input type="search" id="text-search-input" placeholder="Search cards by text..." />
        </div>

            <div class="shrink-wrapper">
            <div class="shrink">
                <div class="row">
                    <div class="search-results" id="search-results"></div>
                </div>
            </div>
            </div>
        </div>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <div id="token-tooltip" style="display: none; position: absolute;">
        <div class="token-tooltip-text" style="font-family: 'Times New Roman', serif; font-size: 14px;"></div>
    </div>

    <p class="empty-deck-message" id="empty-message" style="display: none;">This deck is currently empty.</p>

    <script type="module">
        import { cards } from "./data/cards.js";
        import { tokens } from "./data/tokens.js";
        import { renderCard } from "./utils/cardRenderer.js";
        import { addTooltipListeners } from './utils/cardRenderer.js';
        import { addTokenTooltipListeners } from './utils/cardRenderer.js';

        document.addEventListener("DOMContentLoaded", () => {
            //const sortedCards = cards.sort((a, b) => a.name.localeCompare(b.name));
            //sortedCards.forEach(card => renderCard(card, container));

            const container = document.getElementById("card-wrapper");
            const emptyMessage = document.getElementById("empty-message");
            const deckNameElement = document.getElementById("deck-name");
            const viewingWindow = document.getElementById("viewing-window");
            const scaledCardContainer = document.getElementById("scaled-card");
            let lastHoveredCard = null;

            const searchInput = document.getElementById("search-input");
            const textSearchInput = document.getElementById("text-search-input");
            const searchResults = document.getElementById("search-results");

            const storedDeckName = localStorage.getItem("selectedDeckName") || "My Deck";
            deckNameElement.textContent = storedDeckName;

            if (deckNameElement && deckNameElement.textContent.trim() !== "") {
                document.title = deckNameElement.textContent.trim();
            }

            const toggleBtn = document.getElementById("toggle-options-btn");
            const searchOptions = document.getElementById("search-options");

            toggleBtn.addEventListener("click", () => {
                const isOpen = searchOptions.classList.toggle("open");
                toggleBtn.textContent = isOpen ? "Hide Extra Options ▲" : "Show More Options ▼";
            });

            container.innerHTML = "";  // Clear container before rendering

            let storedCards = localStorage.getItem("selectedDeckCards");
            let cardIds = storedCards ? JSON.parse(storedCards) : [];

            const saveDeckBtn = document.getElementById("save-deck-btn");
            const closeDeckBtn = document.getElementById("close-deck-btn");
            const sortDeckBtn = document.getElementById("sort-deck-btn");

            sortDeckBtn.addEventListener("click", () => {
                const typeOrder = {
                    Champion: 0,
                    Action: 1,
                    Equipment: 2,
                    Obelisk: 3,
                    Rush: 4,
                    Reflex: 5
                };

                const deckCards = cardIds
                    .map(id => cards.find(card => String(card.id) === String(id)))
                    .filter(Boolean);

                const sorted = [...deckCards].sort((a, b) => {
                    const typeCompare = (typeOrder[a.type] ?? 999) - (typeOrder[b.type] ?? 999);
                    if (typeCompare !== 0) return typeCompare;
                    return a.name.localeCompare(b.name);
                });

                cardIds = sorted.map(card => card.id);
                localStorage.setItem("selectedDeckCards", JSON.stringify(cardIds));
                renderDeck();
            });

            // Save Deck button functionality
            saveDeckBtn.addEventListener("click", async () => {
            const deckName = localStorage.getItem("selectedDeckName") || "My Deck";

            try {
            const response = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/saveDeck', {
                method: 'POST',
                credentials: 'include',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ deck_name: deckName, card_ids: cardIds })
            });

            if (!response.ok) {
                const text = await response.text();
                throw new Error(`HTTP ${response.status}: ${text}`);
            }

            const data = await response.json();

            if (data.success) {
                alert("Deck saved!");
            } else {
                alert("Failed to save deck: " + data.error);
            }
            } catch (error) {
            console.error("Error saving deck:", error);
            alert("Error saving deck. See console for details.");
            }
        });


            // Close Deck button functionality
            closeDeckBtn.addEventListener("click", () => {
            window.close();
            });

            function saveDeck() {
                localStorage.setItem("selectedDeckCards", JSON.stringify(cardIds));
                updateDeckInfo(
                    cardIds
                        .map(id => cards.find(card => String(card.id) === String(id)))
                        .filter(Boolean)
                );
            }

            function addCardToDeck(cardId) {
                if (!cardIds.includes(cardId)) {
                    cardIds.push(cardId);
                    saveDeck();
                    renderDeck();
                    renderSearchResults(); // refresh search to update buttons
                } else {
                    console.warn(`Card with ID ${cardId} is already in the deck.`);
                }
            }

            function removeCardFromDeck(cardId) {
                cardIds = cardIds.filter(id => String(id) !== String(cardId));
                saveDeck();
                renderDeck();
                renderSearchResults(); // refresh search to update buttons
            }

            function renderDeck() {
                container.innerHTML = "";
                if (cardIds.length === 0) {
                    emptyMessage.style.display = "block";
                    updateDeckInfo([]);
                } else {
                    emptyMessage.style.display = "none";

                    const deckCards = cardIds
                        .map(id => cards.find(card => String(card.id) === String(id)))
                        .filter(Boolean);

                    updateDeckInfo(deckCards);

                    deckCards.forEach(card => {
                        const cardElement = renderCard(card, container);
                        if (cardElement) {
                            const button = document.createElement("button");
                            button.classList.add("card-button");
                            button.style.zIndex = "1000"; 
                            button.style.pointerEvents = "auto"; 
                            button.title = "Remove card from deck";
                            button.addEventListener("click", () => {
                                removeCardFromDeck(card.id);
                            });

                            cardElement.appendChild(button);

                            cardElement.addEventListener("mouseenter", () => {
                                scaledCardContainer.innerHTML = "";
                                const clone = cardElement.cloneNode(true);
                                const cloneButton = clone.querySelector(".card-button");
                                if (cloneButton) cloneButton.remove();
                                clone.classList.add("scaled-card");
                                scaledCardContainer.appendChild(clone);
                                addTooltipListeners(clone);
                                addTokenTooltipListeners(clone);
                                lastHoveredCard = clone;
                            });
                        }
                    });

                    container.addEventListener("mouseleave", () => {
                        lastHoveredCard = null;
                    });
                }
            }

    renderDeck();

    const sortedCards = [...cards].sort((a, b) => a.name.localeCompare(b.name));

    async function updateDeckInfo(deckCards) {
        const deckInfoDiv = document.getElementById('deck-info');
        deckInfoDiv.textContent = "Loading deck info...";
    // Count card types
    const counts = {
        Champions: 0,
        Actions: 0,
        Equipments: 0,
        Obelisks: 0,
        Rush: 0,
        Reflex: 0,
    };

    deckCards.forEach(card => {
        switch (card.type) {
            case 'Champion': counts.Champions++; break;
            case 'Action': counts.Actions++; break;
            case 'Equipment': counts.Equipments++; break;
            case 'Obelisk': counts.Obelisks++; break;
            case 'Rush': counts.Rush++; break;
            case 'Reflex': counts.Reflex++; break;
        }
    });

    const total = deckCards.length;

    async function checkLegality(deckName) {
    try {
        const response = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/isLegal?deck_name=${encodeURIComponent(deckName)}`, {
        method: 'GET',
        credentials: 'include'
        });
        const data = await response.json();
        return data.legal;
    } catch (error) {
        console.warn("Error fetching deck legality status:", error);
        return false;
    }
    }

    try {
        const storedDeckName = localStorage.getItem("selectedDeckName") || "My Deck";
        const isLegal = await checkLegality(storedDeckName);
        const deckSizeColor = isLegal ? "#4CAF50" : "#ff4d4d";

        deckInfoDiv.innerHTML = `
            <span style="color: ${deckSizeColor};">Deck Size: ${total}</span>
            <span>Champions: ${counts.Champions}</span>
            <span>Actions: ${counts.Actions}</span>
            <span>Equipments: ${counts.Equipments}</span>
            <span>Obelisks: ${counts.Obelisks}</span>
            <span>Rush: ${counts.Rush}</span>
            <span>Reflex: ${counts.Reflex}</span>
        `;
    } catch (e) {
        // In case something fails unexpectedly, still update the info with 0s
        console.error("Failed to update deck info:", e);
        deckInfoDiv.innerHTML = `
            <span style="color: #ff4d4d;">Deck Size: 0</span>
            <span>Champions: 0</span>
            <span>Actions: 0</span>
            <span>Equipments: 0</span>
            <span>Obelisks: 0</span>
            <span>Rush: 0</span>
            <span>Reflex: 0</span>
        `;
    }
}

    searchInput.addEventListener("input", () => {
        renderSearchResults();
    });

    textSearchInput.addEventListener("input", () => {
        renderSearchResults();
    });

    document.getElementById("tag-search-input").addEventListener("input", () => {
        renderSearchResults();
    });

    function renderSearchResults(cardsToRender = sortedCards) {
    searchResults.innerHTML = "";
    const nameQuery = searchInput.value.trim().toLowerCase();
    const textQuery = textSearchInput.value.trim().toLowerCase();
    const tagQuery = (document.getElementById("tag-search-input").value || "").trim().toLowerCase();

    const filteredCards = sortedCards.filter(card => {
        const nameMatches = !nameQuery || card.name.toLowerCase().includes(nameQuery);
        const textMatches = !textQuery || card.abilities.some(ability => ability.text.toLowerCase().includes(textQuery));
        const tagMatches = !tagQuery || (card.tags && card.tags.some(tag => tag.toLowerCase().includes(tagQuery)));
        return nameMatches && textMatches && tagMatches;
    });


    const cardCountElement = document.getElementById("card-count");
    cardCountElement.textContent = `Cards Displayed: ${filteredCards.length}`;

    filteredCards.forEach(card => {
        const cardElement = renderCard(card, searchResults);

        if (cardElement) {
            const button = document.createElement("button");
            button.classList.add("card-button");

            const isInDeck = cardIds.some(id => String(id) === String(card.id));

            if (isInDeck) {
                button.disabled = true;
                button.style.cursor = "not-allowed";
                button.title = "Already in deck";
            } else {
                button.style.cursor = "pointer";
                button.title = "Add card to deck";
                button.addEventListener("click", () => {
                    addCardToDeck(card.id);
                });
            }

            cardElement.appendChild(button);

            cardElement.addEventListener("mouseenter", () => {
                scaledCardContainer.innerHTML = "";
                const clone = cardElement.cloneNode(true);
                const cloneButton = clone.querySelector(".card-button");
                if (cloneButton) cloneButton.remove();
                clone.classList.add("scaled-card");
                scaledCardContainer.appendChild(clone);
                addTooltipListeners(clone);
                addTokenTooltipListeners(clone);
                lastHoveredCard = clone;
            });

            cardElement.addEventListener("mouseleave", () => {
                lastHoveredCard = null;
            });
        }
    });
}
      renderSearchResults();
    });

    function adjustCardSpacing() {
        const wrapper = document.getElementById('card-wrapper');
        const cards = wrapper.children;
        if (!cards.length) return;

        // Reset all cards first
        Array.from(cards).forEach(card => card.classList.remove('stacked'));

        const cardStyle = getComputedStyle(cards[0]);
        const cardWidth = cards[0].offsetWidth +
            parseFloat(cardStyle.marginLeft) +
            parseFloat(cardStyle.marginRight);

        const cardsPerRow = Math.floor(wrapper.offsetWidth / cardWidth);

        // Apply the class to cards in row 2 and beyond
        for (let i = cardsPerRow; i < cards.length; i++) {
            cards[i].classList.add('stacked');
        }
    }

    // Run on load and on resize
    window.addEventListener('DOMContentLoaded', adjustCardSpacing);
    window.addEventListener('resize', adjustCardSpacing);
    </script>
</body>
</html>
