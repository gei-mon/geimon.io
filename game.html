<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
    <link rel="icon" href="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/favicon.png" type="image/png">
    <link rel="stylesheet" href="style.css">
    <title>ACTIVE GAME</title>
</head>
<style>
  #coin {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    transition: transform 0.1s;
}
  #drawn-cards {
    position: fixed;
    bottom: 22px; /* Positions the cards near the bottom */
    left: 850px;
    gap: -960px; /* Allows 5% overlap */
    transform: translate(-25%, 30%);
    display: flex;
    flex-direction: row; /* Aligns cards in a horizontal row */
    align-items: center;
    z-index: 9999; /* Places it over everything */
}
.card {
    width: 240px; /* Reduces card size */
    height: 420px;
    position: relative; /* Ensures controlled placement */
    margin-left: -50%; /* Overlaps cards by 5% */
}
.viewing-window {
    position: fixed;
    left: 10px; /* Keeps it on the left */
    top: 270px;
    transform: translateY(-50%);
    width: 280px; /* Size for zoomed card */
    height: 440px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #1e1e1e;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110; /* Ensures it's on top */
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.context-window {
    position: fixed;
    left: 10px;
    top: 750px;
    transform: translateY(-50%);
    width: 280px;
    height: 440px;
    display: flex;
    flex-direction: column;
    background-color: #1e1e1e;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.player-life-window {
    position: fixed;
    left: 1900px;
    top: 600px;
    transform: translateY(-50%);
    width: 100px;
    height: 100px;
    display: flex;
    flex-direction: column;
    background-color: #2d1eff;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.opponent-life-window {
    position: fixed;
    left: 1900px;
    top: 320px;
    transform: translateY(-50%);
    width: 100px;
    height: 100px;
    display: flex;
    flex-direction: column;
    background-color: #970000;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.tabs {
    display: flex;
    justify-content: space-around;
    padding: 5px;
}
.tab-button {
    padding: 5px;
    cursor: pointer;
    background: #505050;
    color: white;
    border: none;
    border-radius: 5px;
}
.tab-button.active {
    background: #838383;
}
.tab-content-container {
    flex-grow: 1;
    padding: 10px;
    overflow-y: auto;
}
.tab-content {
    display: none;
    color: white;
}
.tab-content.active {
    display: block;
}
#viewing-window .scaled-card {
    pointer-events: auto !important;
    z-index: 100110; /* Ensures it's on top */
    width: 240px;
    height: 420px;
    margin-top: -12%;
}
#viewing-window .scaled-card .card-name {
    max-width: 100%;
}
#viewing-window .scaled-card .card-cost,
#viewing-window .scaled-card .card-text,
#viewing-window .scaled-card .card-name,
#viewing-window .scaled-card .card-condition,
#viewing-window .scaled-card .card-tags,
#viewing-window .scaled-card .bottom-bar,
#viewing-window .scaled-card .card-image {
    z-index: 100200 !important;
}
.tooltip {
    z-index: 110000 !important;
}
#tooltip {
    position: absolute;
    display: none;
    background-color: rgba(0, 0, 0, 1);
    color: white;
    padding: 5px;
    border-radius: 5px;
    font-size: 14px;
    max-width: 250px;
    z-index: 110000; /* Ensure it appears above other elements */
}
.token-tooltip {
    pointer-events: auto !important;
    z-index: 110000 !important;
}
#token-tooltip {
    z-index: 110000; /* Ensure it appears above other elements */
}
.keyword {
    pointer-events: auto !important;
    position: relative; /* Ensures proper hovering */
    z-index: 110000; /* Ensures tooltip appears above other elements */
}
.card-cost .keyword {
    position: relative;
    z-index: 110000 !important;
    pointer-events: auto !important;
}
.card-cost {
    pointer-events: auto !important;
    z-index: 100000 !important;
}
.card-text {
    pointer-events: auto !important;
    z-index: 100000 !important;
}
.scaled-card .card-button {
    display: none !important;
}
.life {
    color: white;
    text-align: center;
    font-weight: bold;
    font-size: 4em;
}
.player-name,
.opponent-name {
    color: white;
    font-size: 1.1em;
    text-align: center;
    font-weight: bold;
    overflow: hidden;          /* Hide overflowed content */
    text-overflow: ellipsis;   /* Show ... when text overflows */
    white-space: nowrap;       /* Prevent text from wrapping */
    max-width: 100%;           /* Optional: control how much space the text gets */
    display: inline-block;     /* Required for ellipsis to take effect */
}
#loss-banner {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0,0,0,0.8);
    padding: 40px 80px;
    border-radius: 16px;
    color: white;
    text-align: center;
    font-family: sans-serif;
    z-index: 120000;
    display: none;
}
#loss-banner .main {
    font-size: 3em;
    font-weight: bold;
    margin-bottom: 10px;
}
#loss-banner .reason {
    font-size: 1.5em;
}
#phase-tracker {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin: 10px auto;
  padding: 10px;
  position: fixed;
  top: 416px;
  left: 949px;
  transform: translateX(-50%);
  z-index: 100600;
  opacity: 0;
}
.phase-box {
  padding: 10px 14px;
  background: dimgray;
  color: white;
  border-radius: 6px;
  font-weight: bold;
  min-width: 90px;
  text-align: center;
  transition: background 0.3s;
}
.phase-box.active {
  background: lightgreen;
  text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;
}
#turn-counter {
  position: fixed;
  top: 442px;
  left: 1545px; /* adjust this to line up visually with the button */
  z-index: 100600;
  color: white;
  font-weight: bold;
  font-size: 1.5em;
  opacity: 0;
  text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;
}
#turn-indicator {
  position: fixed;
  top: 442px;
  left: 1355px;
  z-index: 100600;
  color: white;
  font-weight: bold;
  font-size: 1.5em;
  opacity: 0;
  text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;
}
.card-zone {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  gap: 0px;
  overflow: visible;
  z-index: 100300;
  position: relative;
}
.board-container {
  width: 1920px;
  height: 1080px;
  transform: scale(calc(100vw / 1920));
  transform-origin: top left;
}
</style>
<body style="background-color:rgb(78, 78, 78);">
  <img src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/try_2.png" class="bg-image" alt="">
        <div id="coin-flip-container" style="display: none; text-align: center; margin-top: 50px;">
            <img id="coin" src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png" alt="coin" style="width: 150px; height: 150px;">
            <h2 id="flip-result" style="display: none;"></h2>
        </div>
        <div id="tooltip" class="tooltip"></div>
        <div id="token-tooltip" style="display: none; position: absolute;">
            <div class="token-tooltip-text" style="font-family: 'Times New Roman', serif; font-size: 14px;"></div>
        </div>
        <div id="playerDeckBox"></div>
        <div id="drawn-cards" style="display: flex; flex-wrap: wrap; gap: 10px; padding: 10px;">
            <p id="drawn-message" style="color: white; font-size: 1.5em;"></p>
        </div>
        <div class="viewing-window" id="viewing-window">
            <div class="scaled-card" id="scaled-card" style="transform: scale(0.797); transform-origin: center; pointer-events: none; margin-left: 14%;"></div>
        </div>
        <div class="context-window" id="context-window">
            <div class="tabs">
                <button class="tab-button" data-tab="chat">Chat</button>
                <button class="tab-button active" data-tab="game-log">Game Log</button>
                <button class="tab-button" data-tab="dictionary">Dictionary</button>
            </div>
            <div class="tab-content-container">
                <div class="tab-content" id="chat">
                    <p>This is a Solo Game, and we here at Geimon! do not believe that AI should be allowed to speak.</p>
                </div>
                <div class="tab-content active" id="game-log">
                    <p><span id="totem" style="color: goldenrod;"></span></p>
                    <div id="game-log-placeholder"></div>
                </div>
                <div class="tab-content" id="dictionary">
                    <input type="text" id="dictionary-search" placeholder="Search terms..." style="width: 95%;">
                    <div id="dictionary-results"></div>
                </div>
            </div>
        </div>
        <div class="player-life-window" id="player-life-window">
            <div class="player-name" id="player-name"></div>
            <div class="life" id="player-life"></div>
            <div class="player-name" style="font-size: 80%;">Life</div>
        </div>
        <div class="opponent-life-window" id="opponent-life-window">
            <div class="opponent-name" id="opponent-name"></div>
            <div class="life" id="opponent-life"></div>
            <div class="player-name" style="font-size: 80%;">Life</div>
        </div>
        <div id="loss-banner">
            <div class="main" id="loss-main-text">You Lose</div>
            <div class="reason" id="loss-reason-text">Surrendered</div>
        </div>
        <div id="phase-tracker">
            <div class="phase-box" id="phase-Intermission">Intermission</div>
            <div class="phase-box" id="phase-Draw">Draw</div>
            <div class="phase-box" id="phase-Main 1">Main 1</div>
            <div class="phase-box" id="phase-Battle">Battle</div>
            <div class="phase-box" id="phase-Main 2">Main 2</div>
            <div class="phase-box" id="phase-End">End</div>
        </div>
        <div id="turn-indicator">Your Turn</div>
        <div id="turn-counter">Turn: 1</div>
        <div id="playerArsenalBox" class="card-zone"></div>
        <div id="playerChampionsBox" class="card-zone"></div>
        <div id="playerFaceDownBox" class="card-zone"></div>
        <div id="playerFaceDownArsenalBox" class="card-zone"></div>
        <div id="playerReserveBox" class="card-zone"></div>

        <script type="module">
            import { cards } from "./data/cards.js";
            import { tokens } from "./data/tokens.js";
            import { renderCard } from "./utils/cardRenderer.js";
            import { addTooltipListeners, addTokenTooltipListeners } from "./utils/cardRenderer.js";
            import { keywords } from "./data/keywords.js";
            import { rules } from "./data/rules.js";
            import * as AbilityExecutor from './utils/abilityExecutor.js';

            let gameId = new URLSearchParams(window.location.search).get("gameId");
            if (gameId) {
                // Use the gameId from URL and update localStorage
                localStorage.setItem("gameId", gameId);
            } else {
                // Fallback: create a new one if not in URL or localStorage
                gameId = localStorage.getItem("gameId") || Math.random().toString(36).substr(2, 9);
                localStorage.setItem("gameId", gameId);
            }

            let username = null;
            let hasDrawnInitialHand = false;
            let hasRedrawn = false;
            let lastLoggedIntermissionTurn = null;

            let discardMode = false;
            let discardOngoing = false;
            let userSleeveURL = null;
            let discardSessionId = 0;
            let discardLock = false;
            let discardInstruction = null;

            let sacrificeMode = false;
            let sacrificeCallback = null;

            let intervalId = null;
            let isFetchingGameState = false;
            let gameReady = false;

            const params = new URLSearchParams(window.location.search);
            const isSinglePlayer = params.get("gameType") === "single";
            const otherPlayerName = params.get("opponent") || "Unknown_Opponent"; // if multiplayer later

            let previousHandIds = [];
            let lastDrawTurn = null;

            function addGameLogEntry(message) {
                if (!username) {
                    console.warn("‚ùå addGameLogEntry called before username was set.");
                    return;
                }
                const gameLog = document.getElementById("game-log-placeholder");
                if (!gameLog) {
                    console.warn("No game log container found.");
                    return;
                }
                const time = new Date().toLocaleTimeString();
                const entry = document.createElement("div");
                entry.textContent = `[${time}] ${message}`;
                gameLog.appendChild(entry);
                gameLog.scrollTop = gameLog.scrollHeight;
            }

            function findCardByUidOrId(id) {
                const zones = [
                    ...(gameState[username]["Zone (Champion)"] || []),
                    ...(gameState[username]["FaceDownZone"] || []),
                ];
                return zones.find(c => String(c.id) === String(id) || String(c.id) === String(id));
            }

        function handsAreEqual(currentHand) {
        return (
            currentHand.length === previousHandIds.length &&
            currentHand.every((card, index) => card.id === previousHandIds[index])
        );
        }

        function isMainPhase(phase) {
            return ["Main 1", "Main 2"].includes(gameState?.turn?.currentPhase);
        }

        function cleanupDiscardUI() {
            document.querySelectorAll("div[style*='Select']").forEach(el => el.remove());
            document.querySelectorAll("div[style*='Discard this card?']").forEach(el => el.remove());
            document.querySelectorAll(".card-button").forEach(btn => {
                btn.onclick = btn._originalHandler || null;
            });
            document.querySelectorAll(".phase-box").forEach(box => box.style.pointerEvents = "auto");
        }

        function isCardSettable(cardData, fullCard) {
            if (!cardData || !fullCard) return false;
            if (cardData.boardState !== "Hand") return false;
            if (fullCard.type === "Champion") return false;

            const currentPhase = gameState?.turn?.currentPhase;
            const isMain = currentPhase === "Main 1" || currentPhase === "Main 2";
            if (!isMain) return false;

            const turnPlayer = gameState?.turn?.currentPlayer;

            if (turnPlayer !== username) return false; // ‚úÖ Only current turn player can set

            return ["Action", "Rush", "Reflex", "Equipment", "Obelisk"].includes(fullCard.type);
        }

        function showSetArsenalPrompt(cardData, fullCard) {
            const existingPrompt = document.getElementById("set-arsenal-prompt-overlay");
            if (existingPrompt) {
                document.body.removeChild(existingPrompt);
            }

            const overlay = document.createElement("div");
            overlay.id = "set-arsenal-prompt-overlay";
                Object.assign(overlay.style, {
                    position: "fixed",
                    top: "50%",
                    left: "50%",
                    transform: "translate(-50%, -50%)",
                    padding: "20px",
                    backgroundColor: "#333",
                    color: "white",
                    border: "2px solid white",
                    borderRadius: "10px",
                    zIndex: 120001,
                    textAlign: "center",
                    boxShadow: "0 0 10px black"
                });
                overlay.innerHTML = `
                    <p>Set '${fullCard.name}' face-down in your Arsenal?</p>
                    <button id="confirm-set">Confirm</button>
                    <button id="cancel-set" style="margin-left: 10px;">Cancel</button>
                `;

            document.body.appendChild(overlay);

            document.getElementById("confirm-set").onclick = async () => {
                const handZone = gameState[username].Hand;
                const arsenalZone = gameState[username]["Zone (Arsenal)"];
                const faceDownArsenal = gameState[username]["FaceDownArsenalZone"] || [];

                const index = handZone.findIndex(c => String(c.id) === String(cardData.id));
                if (index === -1) return;
                handZone.splice(index, 1);
                fullCard.boardState = "FaceDownArsenalZone";
                fullCard.lastBoardState = "Hand";
                faceDownArsenal.push(fullCard);
                gameState[username]["FaceDownArsenalZone"] = faceDownArsenal;

                await fetch("https://geimon-app-833627ba44e0.herokuapp.com/updateGameState", {
                    method: "POST",
                    credentials: "include",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        gameId,
                        owner: username,
                        updatedZones: {
                        Hand: handZone,
                        FaceDownArsenalZone: faceDownArsenal
                        }
                    })
                });
                addGameLogEntry(`${username} set a card facedown in the Arsenal.`);
                document.body.removeChild(overlay);
                updateLocalFromGameState();
            };

            document.getElementById("cancel-set").onclick = () => {
                document.body.removeChild(overlay);
            };
        }

        async function updateLocalFromGameState() {
            if (discardMode) return;
            const player = gameState[username];
            const currentHand = player.Hand;

            const prevLength = previousHandIds.length;
            const newLength = currentHand.length;

            if (!handsAreEqual(currentHand)) {
                drawnCardsArray = currentHand;
                previousHandIds = currentHand.map(card => card.id);
                renderDrawnCards();

                if (!hasDrawnInitialHand && newLength >= 5) {
                    //hasDrawnInitialHand = true;
                    return;
                }

                if (hasDrawnInitialHand && newLength > prevLength) {
                    const numDrawn = newLength - prevLength;
                    addGameLogEntry(`${username} drew ${numDrawn} card${numDrawn > 1 ? 's' : ''}`);
                }
            }

            //await renderCardZone(player["Zone (Champion)"], "playerChampionsBox");
            //console.log("Rendering Champions:", gameState[username]["Zone (Champion)"]);

            remainingDeck = player.Deck;
            updateDeckText();

            // ‚úÖ Add this:
            updateTurnDisplay(gameState.turn);
            updatePhaseDisplay(gameState.turn.currentPhase);
            renderLatestTombCard();
            renderLatestVoidCard();
            renderDrawnCards();

            if (gameState[username] && gameState[username].hasBasicRallied === undefined) {
                gameState[username].hasBasicRallied = false;
            }

            const zoneMappings = {
                "Zone (Champion)": "Champions",
                "Zone (Arsenal)": "Arsenal",
                "Reserve": "Reserve",
                "FaceDownZone": "FaceDown",
                "FaceDownArsenalZone": "FaceDownArsenal"
            };

            for (const [zoneKey, domSuffix] of Object.entries(zoneMappings)) {
                await renderCardZone(gameState[username][zoneKey], `player${domSuffix}Box`);
            }
        }

        async function getUsername() {
            const res = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/me', { credentials: 'include' });
            const data = await res.json();
            if (data.loggedIn) {
                username = data.username;
            }
        }

        async function initGameClient() {
            await getUsername();
            if (!username) {
                alert("Could not retrieve username.");
                return; // ‚úÖ This is now valid
            }
        }

        function showCostRallyPrompt(card) {
            const overlay = document.createElement("div");
            Object.assign(overlay.style, {
                position: "fixed",
                top: "50%",
                left: "50%",
                transform: "translate(-50%, -50%)",
                backgroundColor: "#333",
                color: "white",
                padding: "20px",
                border: "2px solid white",
                borderRadius: "10px",
                zIndex: 120001,
                textAlign: "center",
                boxShadow: "0 0 10px black"
            });

            overlay.innerHTML = `
                <p>Would you like to rally <strong>${card.name}</strong>?</p>
                <button id="confirm-cost-rally">Rally</button>
                <button id="cancel-cost-rally" style="margin-left: 10px;">Cancel</button>
            `;
            document.body.appendChild(overlay);

            document.getElementById("cancel-cost-rally").onclick = async () => {
                document.body.removeChild(overlay);
            };

            document.getElementById("confirm-cost-rally").onclick = async () => {
            if (card.cardCostFunction?.startsWith("Sacrifice")) {
                const sacrificeAmount = parseInt(card.cardCostFunction.replace("Sacrifice", ""), 10);
                if (!isNaN(sacrificeAmount)) {
                    document.body.removeChild(overlay);
                    const success = await AbilityExecutor.sacrificeChampions(sacrificeAmount, gameState, username, gameId, updateLocalFromGameState, addGameLogEntry);
                    if (!success) return; // User cancelled or failed to sacrifice
                    // Proceed with rally now
                    const hand = gameState[username].Hand;
                    const handIndex = hand.findIndex(c => String(c.id) === String(card.id));
                    if (handIndex !== -1) {
                        hand.splice(handIndex, 1);
                        card.lastBoardState = "Hand";
                        card.boardState = "Zone (Champion)";
                        gameState[username]["Zone (Champion)"].push(card);

                        addGameLogEntry(`${username} rallied ${card.name} by sacrificing champions.`);
                        
                        await fetch("https://geimon-app-833627ba44e0.herokuapp.com/updateGameState", {
                            method: "POST",
                            credentials: "include",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                gameId,
                                owner: username,
                                updatedZones: {
                                    Hand: hand,
                                    "Zone (Champion)": gameState[username]["Zone (Champion)"]
                                }
                            })
                        });

                        await AbilityExecutor.handleBoardStateChange(
                            card,
                            "Zone (Champion)",
                            "Hand",
                            gameState,
                            username,
                            gameId,
                            updateLocalFromGameState,
                            addGameLogEntry
                        );
                        await updateLocalFromGameState();
                        }
                        return;
                    }
                }

                document.body.removeChild(overlay);

                // Existing code for other costs (Offer, Mill)
                await AbilityExecutor.handleCardCostFunction(card, gameState, username, gameId, updateLocalFromGameState, addGameLogEntry);

                // Move card to Champion zone for other cost types
                const hand = gameState[username].Hand;
                const index = hand.findIndex(c => String(c.id) === String(card.id));
                if (index !== -1) {
                    hand.splice(index, 1);
                    card.lastBoardState = "Hand";
                    card.boardState = "Zone (Champion)";
                    gameState[username]["Zone (Champion)"].push(card);

                    await fetch("https://geimon-app-833627ba44e0.herokuapp.com/updateGameState", {
                        method: "POST",
                        credentials: "include",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            gameId,
                            owner: username,
                            updatedZones: {
                                Hand: hand,
                                "Zone (Champion)": gameState[username]["Zone (Champion)"]
                            }
                        })
                    });

                    addGameLogEntry(`${username} rallied ${card.name} by paying its cost.`);

                    await AbilityExecutor.handleBoardStateChange(card, "Zone (Champion)", "Hand", gameState, username, gameId, updateLocalFromGameState, addGameLogEntry);
                    await updateLocalFromGameState();
                }
            };
        }

        async function showRedrawPrompt() {
            return new Promise((resolve) => {
                const overlay = document.createElement("div");
                overlay.style.position = "fixed";
                overlay.style.top = "50%";
                overlay.style.left = "50%";
                overlay.style.transform = "translate(-50%, -50%)";
                overlay.style.width = "400px";
                overlay.style.padding = "30px 20px";
                overlay.style.backgroundColor = "rgba(0, 0, 0)";
                overlay.style.zIndex = 200000;
                overlay.style.display = "flex";
                overlay.style.flexDirection = "column";
                overlay.style.justifyContent = "center";
                overlay.style.alignItems = "center";
                overlay.style.borderRadius = "12px";
                overlay.style.boxShadow = "0 0 20px black";
                overlay.style.opacity = "0";
                overlay.style.transition = "opacity 1s ease-in-out";

                setTimeout(() => {
                    overlay.style.opacity = "0.8";
                }, 1000);

                const prompt = document.createElement("div");
                prompt.innerHTML = "<h2 style='color:white'>Would you like to redraw your opening hand?</h2>";
                prompt.style.marginBottom = "20px";

                const yesBtn = document.createElement("button");
                yesBtn.textContent = "Yes";
                yesBtn.style.marginRight = "10px";
                yesBtn.onclick = async () => {
                if (!hasRedrawn) {
                    hasRedrawn = true;
                    const player = gameState[username];
                    const hand = player.Hand.splice(0);
                    player.Deck.push(...hand);
                    addGameLogEntry(`${username} elected to redraw their Starting Hand.`);
                    await drawCards(player.Deck, 5);
                    await sendZoneUpdate(["Deck", "Hand"]);
                    await updateLocalFromGameState();
                }
                document.body.removeChild(overlay);
                resolve();
                };

                const noBtn = document.createElement("button");
                noBtn.textContent = "No";
                noBtn.onclick = () => {
                document.body.removeChild(overlay);
                addGameLogEntry(`${username} elected not to redraw their Starting Hand.`);
                resolve();
                };

                const btnContainer = document.createElement("div");
                btnContainer.appendChild(yesBtn);
                btnContainer.appendChild(noBtn);
                overlay.appendChild(prompt);
                overlay.appendChild(btnContainer);

                document.body.appendChild(overlay);


            });
        }

        window.onload = () => {
            (async () => {
                await initGameClient();
                    if (!username) {
                        console.warn("Username not set after init.");
                        return;
                }

            const params = new URLSearchParams(window.location.search);
            const turnOrder = params.get("turnOrder");

            if (turnOrder === "coinflip") {
                const container = document.getElementById("coin-flip-container");
                const coin = document.getElementById("coin");
                const resultText = document.getElementById("flip-result");
                container.style.display = "block";
                resultText.textContent = "";

                // Image paths
                const headsImg = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png";
                const tailsImg = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/tails.png";

                let positionY = window.innerHeight / 2;
                let velocity = -25;
                let gravity = 1;
                let flips = 0;

                function animateFlip() {
                    coin.src = Math.random() > 0.5 ? headsImg : tailsImg;

                    positionY += velocity;
                    velocity += gravity;

                    coin.style.top = `${positionY}px`;

                    if (velocity > 0 && positionY >= window.innerHeight / 2) {
                        clearInterval(interval);

                        const finalResult = Math.random() > 0.5 ? "Heads" : "Tails";
                        coin.src = finalResult === "Heads" ? headsImg : tailsImg;

                        if (finalResult === "Tails") {
                            resultText.textContent = "You are going second.";
                            resultText.style.display = "block";
                            resultText.style.fontSize = "2em";
                            resultText.style.marginTop = "10%";
                            resultText.style.textShadow ="2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black";
                            setTimeout(() => transitionToNextScreen("second"), 2000);
                        } else {
                            resultText.textContent = "You won the coin flip! Choose:";
                            resultText.style.display = "block";
                            resultText.style.fontSize = "2em";
                            resultText.style.marginTop = "10%";
                            resultText.style.textShadow = "2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black";

                            const buttonContainer = document.createElement("div");
                            buttonContainer.style.marginTop = "20px";

                            const goFirstButton = document.createElement("button");
                            goFirstButton.textContent = "Go First";
                            goFirstButton.style.marginRight = "10px";
                            goFirstButton.className = "button button";
                            goFirstButton.onclick = () => {
                                clearTimeout(autoSelectTimer); // Cancel timer if selected manually
                                transitionToNextScreen("first");
                            };

                            const goSecondButton = document.createElement("button");
                            goSecondButton.textContent = "Go Second";
                            goSecondButton.className = "button button";
                            goSecondButton.onclick = () => {
                                clearTimeout(autoSelectTimer); // Cancel timer if selected manually
                                transitionToNextScreen("second");
                            };

                            buttonContainer.appendChild(goFirstButton);
                            buttonContainer.appendChild(goSecondButton);
                            container.appendChild(buttonContainer);

                            // Start 3-second timer for automatic selection
                            const autoSelectTimer = setTimeout(() => {
                                const randomChoice = Math.random() < 0.5 ? "first" : "second"; // 50/50 chance
                                console.log(`Time expired! Automatically choosing: ${randomChoice}`);
                                transitionToNextScreen(randomChoice);
                            }, 3000); // 3 seconds
                        }

                    }
                }
                const interval = setInterval(animateFlip, 50);
            }
            else if (turnOrder === "first" || turnOrder === "second") {
                // Directly proceed to game setup
                transitionToNextScreen(turnOrder);
            }
            else {
                document.body.innerHTML = `
                    <h1>Game Configuration</h1>
                    <p>Player Deck: ${params.get("playerDeck")}</p>
                    <p>Opponent Deck: ${params.get("opponentDeck")}</p>
                    <p>Game Type: ${params.get("gameType")}</p>
                    <p>Totem: ${params.get("totem")}</p>
                    <p>Turn Order: ${turnOrder}</p>
                `;
            }
        })();
    };
        async function fetchLatestTurnState() {
            const res = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`, {
                credentials: "include",
            });
            if (!res.ok) {
                console.warn("fetchLatestTurnState failed:", res.status);
                return gameState;
            }
            return await res.json();
            }
        async function waitForGameState(retries = 10, delayMs = 500) {
            for (let i = 0; i < retries; i++) {
                const res = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`, {
                credentials: "include"
                });

                if (res.ok) {
                const gameState = await res.json();
                if (gameState && gameState.turn) return gameState;
                }

                console.warn(`Retry ${i + 1} of ${retries}... waiting for game state...`);
                await new Promise(resolve => setTimeout(resolve, delayMs));
            }

            throw new Error("Game state failed to initialize in time.");
        }

        async function fetchGameStateFromServer() {
            try {
                const response = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`, {
                    credentials: "include"
                });

                if (!response.ok) {
                console.warn("‚ö†Ô∏è Failed to fetch game state:", response.status);
                return; // Don't continue if response is bad
                }

                const newGameState = await response.json();
                if (!newGameState || !newGameState.turn) {
                    console.warn("‚ö†Ô∏è Game state or turn missing from server");
                    return;
                }

                gameState = newGameState;
                const currentTurn = gameState.turn.count;
                AbilityExecutor.resetEffectUsageForTurn(gameId, currentTurn);

                updateLocalFromGameState();
                const playerState = gameState[username];
            } catch (err) {
                console.error("üí• Error fetching game state:", err);
            }
        }
        window.fetchGameStateFromServer = fetchGameStateFromServer;

        function showLossBanner(mainText, reasonText) {
            const banner = document.getElementById("loss-banner");
            document.getElementById("loss-main-text").textContent = mainText;
            document.getElementById("loss-reason-text").textContent = reasonText;
            banner.style.display = "block";
        }

        function checkActivatableCards() {
            console.log("Check for activatable cards here...");
        }

        async function handleCardDiscard(gameState, username, cards, gameId, phase, updateLocalFromGameState, addGameLogEntry, updatePhaseDisplay) {
            if (discardLock) {
                console.warn("‚õî Discard in progress (locked). Skipping trigger.");
                return;
            }

            discardSessionId += 1;
            const thisSessionId = discardSessionId;

            discardMode = true;
            discardOngoing = true;
            discardLock = true;

            if (gameState[username].Hand.length <= 6) {
                discardMode = false;
                discardOngoing = false;
                discardLock = false;

                if (discardInstruction && discardInstruction.parentNode) {
                    discardInstruction.parentNode.removeChild(discardInstruction);
                    discardInstruction = null;
                }

                return;
            }

            if (discardInstruction && discardInstruction.parentNode) {
                discardInstruction.parentNode.removeChild(discardInstruction);
                discardInstruction = null;
            }
            discardInstruction = document.createElement("div");

            const drawnCardsContainer = document.getElementById("drawn-cards");
            if (!drawnCardsContainer) return;

            drawnCardsContainer.querySelectorAll(".card").forEach(card => {
                const clone = card.cloneNode(true); // removes all listeners and attributes
                card.replaceWith(clone);
            });

            Object.assign(discardInstruction.style, {
                position: "fixed",
                bottom: "50%",
                left: "55%",
                transform: "translateX(-50%)",
                color: "black",
                fontSize: "4em",
                backgroundColor: "rgba(255, 0, 0, 0.85)",
                padding: "12px 20px",
                borderRadius: "10px",
                zIndex: "120000"
            });
            document.body.appendChild(discardInstruction);

            function updateDiscardPrompt() {
                const cardsOver = gameState[username].Hand.length - 6;
                discardInstruction.textContent = `Select ${cardsOver} card${cardsOver !== 1 ? "s" : ""} to discard`;
            }

            updateDiscardPrompt();

            // Disable phase clicks
            document.querySelectorAll(".phase-box").forEach(box => box.style.pointerEvents = "none");

            drawnCardsContainer.querySelectorAll(".card-button").forEach(button => {
                const originalClick = button.onclick;
                button._originalHandler = originalClick;

                button.onclick = () => {
                    if (thisSessionId !== discardSessionId) {
                        console.warn("üõë Discard session outdated, aborting interaction.");
                        return;
                    }
                    const parentCard = button.closest(".card");
                    const cardId = parentCard?.dataset.cardId;
                    if (!cardId) return console.warn("‚ùå No cardId found on clicked button");

                    const cardData = gameState[username].Hand.find(c => String(c.id) === cardId);
                    const fullCard = cards.find(c => String(c.id) === cardId);
                    if (!cardData || !fullCard) return console.warn("‚ùå Could not find card data");

                    // ‚úÖ Skip any setting logic
                    // Force discard prompt only
                    const enrichedCard = {
                        ...cardData,
                        ...fullCard,
                        lastBoardState: "Hand",
                        boardState: "Tomb"
                    };

                    const confirmBox = document.createElement("div");
                    Object.assign(confirmBox.style, {
                        position: "fixed",
                        top: "50%",
                        left: "50%",
                        transform: "translate(-50%, -50%)",
                        padding: "20px",
                        backgroundColor: "#333",
                        color: "white",
                        border: "2px solid white",
                        borderRadius: "10px",
                        zIndex: "120001",
                        textAlign: "center",
                        boxShadow: "0 0 10px black"
                    });
                    confirmBox.innerHTML = `
                        <p>Discard this card?</p>
                        <div style="margin: 10px 0;">${fullCard.name}</div>
                        <button id="confirm-discard">Confirm</button>
                        <button id="cancel-discard" style="margin-left: 10px;">Cancel</button>
                    `;
                    document.body.appendChild(confirmBox);

                    document.getElementById("confirm-discard").onclick = async () => {
                        //console.log("üßæ Hand size before discard:", gameState[username].Hand.length);

                        const index = gameState[username].Hand.findIndex(c => String(c.id) === cardId);
                        if (index === -1) {
                            console.warn("‚ùå Tried to discard a card that no longer exists in hand:", cardId);
                            return;
                        }

                        enrichedCard.lastBoardState = "Hand";
                        enrichedCard.boardState = "Tomb";

                        gameState[username].Hand.splice(index, 1);
                        gameState[username].Tomb.push(enrichedCard);

                        await fetch("https://geimon-app-833627ba44e0.herokuapp.com/updateGameState", {
                            method: "POST",
                            credentials: "include",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                gameId,
                                owner: username,
                                updatedZones: {
                                    Hand: gameState[username].Hand,
                                    Tomb: gameState[username].Tomb
                                }
                            })
                        });

                        addGameLogEntry(`${username} discarded ${fullCard.name} for hand size limit`);

                        await AbilityExecutor.handleBoardStateChange(
                            enrichedCard,
                            "Tomb",
                            "Hand",
                            gameState,
                            username,
                            gameId,
                            updateLocalFromGameState,
                            addGameLogEntry
                        );

                        await renderLatestTombCard();
                        await renderDrawnCards();
                        await updateLocalFromGameState();

                        // üß† Refetch latest state after effects and updates
                        const updatedState = await fetchLatestTurnState();
                        if (!updatedState || !updatedState[username]) {
                            console.error("‚ùå Failed to get latest state during discard");
                            return;
                        }
                        gameState = updatedState;

                        await new Promise(requestAnimationFrame);
                        const updatedHand = gameState[username].Hand;

                        if (updatedHand.length > 6) {
                            //console.log("‚ôªÔ∏è Hand size over limit again after retrieval ‚Äî restarting discard flow.");

                            document.body.removeChild(confirmBox);

                            if (discardInstruction && discardInstruction.parentNode) {
                                discardInstruction.parentNode.removeChild(discardInstruction);
                                discardInstruction = null;
                            }

                            drawnCardsContainer.querySelectorAll(".card-button").forEach(btn => {
                                btn.onclick = btn._originalHandler || null;
                            });

                            discardMode = false;
                            discardOngoing = false;
                            discardLock = false;

                            await handleCardDiscard(
                                gameState,
                                username,
                                cards,
                                gameId,
                                phase,
                                updateLocalFromGameState,
                                addGameLogEntry,
                                updatePhaseDisplay
                            );
                            return;
                        }

                        document.body.removeChild(confirmBox);

                        if (updatedHand.length > 6) {
                            //console.log("üîÅ Still need to discard. Cards in hand:", updatedHand.length);
                            updateDiscardPrompt();
                            return;
                        }

                        //console.log("üéâ Hand size OK. Ending discard mode.");
                        discardMode = false;
                        discardOngoing = false;
                        discardLock = false;

                        if (discardInstruction && discardInstruction.parentNode) {
                            //console.log("üßπ Removing discard instruction popup.");
                            discardInstruction.parentNode.removeChild(discardInstruction);
                            discardInstruction = null;
                        }

                        drawnCardsContainer.querySelectorAll(".card-button").forEach(btn => {
                            btn.onclick = btn._originalHandler || null;
                        });

                        document.querySelectorAll(".phase-box").forEach(box => box.style.pointerEvents = "auto");

                        const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/setPhase", {
                            method: "POST",
                            credentials: "include",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ gameId, username, phase })
                        });

                        if (response.ok) {
                            const updated = await response.json();
                            updatePhaseDisplay(updated.currentPhase);
                            await updateLocalFromGameState();
                            renderLatestTombCard();
                        }
                    };
                        document.getElementById("cancel-discard").onclick = () => {
                        document.body.removeChild(confirmBox);
                    };
                };
            });
        }

        function updateTurnDisplay(turnData) {
        if (turnData && turnData.count) {
            document.getElementById("turn-counter").textContent = `Turn: ${turnData.count}`;

            const indicator = document.getElementById("turn-indicator");
            if (turnData.currentPlayer === username) {
                indicator.textContent = "Your Turn";
            } else {
                indicator.textContent = "Opponent's Turn";
            }
                indicator.style.opacity = "1";

            const colorBox = document.getElementById("turn-color-box");
            if (colorBox) {
                if (turnData.currentPlayer === username) {
                    colorBox.style.backgroundColor = "blue";
                } else {
                    colorBox.style.backgroundColor = "red";
                }
            }
        }
        }
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        document.querySelectorAll(".phase-box").forEach(box => {
            box.style.cursor = "pointer";
            box.addEventListener("click", async () => {
                if (discardMode || discardOngoing) {
                    console.warn("üõë Cannot progress phase during or after triggered discard effects.");
                    return;
                }
                const phase = box.textContent.trim();
                const turnCount = gameState.turn.count;
                const currentPhase = gameState.turn.currentPhase;
                const player = gameState.turn.currentPlayer;

                if (player !== username) return;

                // Turn 1: restrict Battle and Main 2
                if (turnCount === 1 && (phase === "Battle" || phase === "Main 2")) return;

                // Enforce phase flow:
                const allowedTransitions = {
                    "Intermission": ["Draw"],
                    "Draw": ["Main 1"],
                    "Main 1": ["Battle", "End"],
                    "Battle": ["Main 2"],
                    "Main 2": ["End"]
                };

                const validNextPhases = allowedTransitions[currentPhase] || [];

                if (!validNextPhases.includes(phase)) {
                    console.warn(`Invalid transition from ${currentPhase} to ${phase}`);
                    return;
                }

                if (phase === "End" && gameState.turn.currentPlayer === username) {
                    if (gameState[username].Hand.length > 6) {
                        await handleCardDiscard(
                            gameState,
                            username,
                            cards,
                            gameId,
                            phase,
                            updateLocalFromGameState,
                            addGameLogEntry,
                            updatePhaseDisplay
                        );
                    return; // üõë Prevent premature turn advancement
                }
            }

            // ‚úÖ Normal flow if no discards needed
            const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/setPhase", {
            method: "POST",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ gameId, username, phase })
            });

            if (response.ok) {
                const updated = await response.json();
                updatePhaseDisplay(updated.currentPhase);
                addGameLogEntry(`${username} changed phase to ${updated.currentPhase}`);
                await updateLocalFromGameState();
            }
        });
    });

        function sendToTomb(card) {
            console.log("Incoming card to sendToTomb:", card);
            console.log("Card ID:", card?.id);
            const fullCard = cards.find(c => String(c.id) === String(card.id)) || card;
            console.log("Resolved full card:", fullCard);

            if (!fullCard) {
                console.error(`Full card data not found for ID ${card.id}`);
                return;
            }

            // Example insertion point (before zone change is finalized)
            if (AbilityExecutor.checkLingerEffects(fullCard, "Tomb", gameState, addGameLogEntry)) {
                updateLocalFromGameState();
                return; // Don't continue standard move, it's been handled
            }

            fullCard.lastBoardState = card.boardState;
            fullCard.boardState = "Tomb";

            gameState[username].Tomb.push(fullCard);

            AbilityExecutor.handleBoardStateChange(fullCard, fullCard.boardState, fullCard.lastBoardState, gameState, username, gameId, updateLocalFromGameState, addGameLogEntry);
        }

        function renderLatestTombCard() {
            const tombTop = gameState?.[username]?.Tomb?.slice(-1)[0];
            if (!tombTop) return; // ‚úÖ Early return if nothing to show

            const card = cards.find(c => String(c.id) === String(tombTop.id));
            if (!card) return;

            playerTombBox.innerHTML = "";

            // Render card scaled down
            const miniCard = renderCard(card);
                miniCard.style.transform = "scale(0.3)";
                miniCard.style.transformOrigin = "top left";
                miniCard.style.marginTop = "-8%";
                miniCard.style.marginLeft = "0%";
                miniCard.style.pointerEvents = "none"; // Prevent dragging
            playerTombBox.appendChild(miniCard);

            // Tomb hover label (like Deck)
            const tombTextOverlay = document.createElement("div");
                tombTextOverlay.innerText = "Tomb";
                tombTextOverlay.style.position = "absolute";
                tombTextOverlay.style.left = "45%";
                tombTextOverlay.style.top = "3%";
                tombTextOverlay.style.transform = "translate(-50%, -50%)";
                tombTextOverlay.style.fontSize = "1em";
                tombTextOverlay.style.color = "white";
                tombTextOverlay.style.textShadow = `
                    -2px -2px 4px black,  
                    2px -2px 4px black,  
                    -2px 2px 4px black,  
                    2px 2px 4px black
                `;
            playerTombBox.appendChild(tombTextOverlay);

            playerTombBox.addEventListener("mouseenter", () => {
                tombTextOverlay.innerText = `${gameState[username].Tomb.length}`;
            });
            playerTombBox.addEventListener("mouseleave", () => {
                tombTextOverlay.innerText = "Tomb";
            });
        }

        function renderLatestVoidCard() {

            const voidTop = gameState?.[username]?.Void?.slice(-1)[0];
            if (!voidTop) return;

            const card = cards.find(c => String(c.id) === String(voidTop.id));
            if (!card) return;

            playerVoidBox.innerHTML = ""; // ‚úÖ Always clear it first

            // Render card scaled down
            const miniCard = renderCard(card);
            miniCard.style.transform = "scale(0.3)";
            miniCard.style.transformOrigin = "top left";
            miniCard.style.marginTop = "-8%";
            miniCard.style.marginLeft = "0%";
            miniCard.style.pointerEvents = "none"; // Prevent dragging
            playerVoidBox.appendChild(miniCard);

            // Void hover label (like Deck)
            const voidTextOverlay = document.createElement("div");
            voidTextOverlay.innerText = "Void";
            voidTextOverlay.style.position = "absolute";
            voidTextOverlay.style.left = "45%";
            voidTextOverlay.style.top = "3%";
            voidTextOverlay.style.transform = "translate(-50%, -50%)";
            voidTextOverlay.style.fontSize = "1em";
            voidTextOverlay.style.color = "white";
            voidTextOverlay.style.textShadow = `
                -2px -2px 4px black,  
                2px -2px 4px black,  
                -2px 2px 4px black,  
                2px 2px 4px black
            `;
            playerVoidBox.appendChild(voidTextOverlay);

            playerVoidBox.addEventListener("mouseenter", () => {
                voidTextOverlay.innerText = `${gameState[username].Void.length}`;
            });
            playerVoidBox.addEventListener("mouseleave", () => {
                voidTextOverlay.innerText = "Void";
            });
        }

        async function transitionToNextScreen(choice) {
            // Keep the background image visible
            const bgImage = document.querySelector(".bg-image");

            // Create a semi-transparent overlay
            const overlay = document.createElement("div");
            overlay.style.position = "absolute";
            overlay.style.top = "0";
            overlay.style.left = "0";
            overlay.style.width = "100%";
            overlay.style.height = "100%";
            overlay.style.backgroundColor = "rgba(0, 0, 0, 0.4)"; // Dark transparency
            overlay.style.zIndex = "10";

            // Main container for the structured design
            const mainContainer = document.createElement("div");
                mainContainer.style.position = "absolute";
                mainContainer.style.top = "24px";
                mainContainer.style.left = "45px";
                mainContainer.style.width = "1920px";
                mainContainer.style.height = "903px";
                mainContainer.style.display = "flex";
                mainContainer.style.flexDirection = "column";
                mainContainer.style.justifyContent = "center";
                mainContainer.style.alignItems = "center";
                mainContainer.style.gap = "10px";
                mainContainer.style.padding = "20px";
                mainContainer.style.backgroundColor = "rgba(0, 0, 0)";
                mainContainer.style.borderRadius = "20px";
                mainContainer.style.zIndex = "20";
                mainContainer.style.opacity = "0"; // Start fully invisible
                mainContainer.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
                mainContainer.style.transform = "scale(0.8)  translate(100px,-50px)";

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                mainContainer.style.opacity = "1";
            }, 50);

            // Central result box
            const resultBox = document.createElement("div");
                resultBox.style.position = "absolute";
                resultBox.style.top = "50%";
                resultBox.style.left = "50%";
                resultBox.style.transform = "translate(-50%, -50%)";
                resultBox.style.padding = "20px 40px";
                resultBox.style.color = "white";
                resultBox.style.fontSize = "2em";
                resultBox.style.borderRadius = "10px";
                resultBox.style.textAlign = "center";
                resultBox.style.opacity = "0"; // Start fully invisible
                resultBox.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
                resultBox.style.zIndex = "100700"; // On top of everything
                resultBox.style.boxShadow = "0 0 20px black";

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                resultBox.style.opacity = "1";
            }, 50);

            // Set background color based on choice
            resultBox.style.backgroundColor = choice === "first" ? "blue" : "red";
            resultBox.textContent = choice === "first" ? "Your Turn" : "Opponent's Turn";

            // Main board container
            const board = document.createElement("div");
                board.style.position = "absolute";
                board.style.top = "2%";
                board.style.left = "2%";
                board.style.width = "96%";
                board.style.height = "94%";
                board.style.backgroundColor = "black";
                board.style.zIndex = "20";
                board.style.borderRadius = "20px";
                board.style.opacity = "0"; // Start fully invisible
                board.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                board.style.opacity = "1";
            }, 50);

            const turnBox = document.createElement("div");
                turnBox.id = "turn-color-box";
                turnBox.style.position = "absolute";
                turnBox.style.left = "1343px";
                turnBox.style.top = "435px";
                turnBox.style.width = "305px";
                turnBox.style.height = "40px";
                turnBox.style.zIndex = "30";
                turnBox.style.border = "0px solid white";
                turnBox.style.borderRadius = "4px";
                turnBox.style.transition = "background-color 1s ease";
                turnBox.style.opacity = "0";
            document.body.appendChild(turnBox);

            setTimeout(() => {
                turnBox.style.opacity = "1"; // Fades out smoothly
            }, 2700);

            const championBox = document.getElementById("playerChampionsBox");
                championBox.style.position = "fixed";
                championBox.style.left = "725px";
                championBox.style.top = "675px";
                championBox.style.width = "525px";
                championBox.style.height = "128px";
                championBox.style.zIndex = "100300"; // ensure it's above the board
                championBox.style.pointerEvents = "none";
                championBox.style.backgroundColor = "rgba(255, 0, 0, 0)"; // debug transparent background
            
            const facedownBox = document.getElementById("playerFaceDownBox");
                facedownBox.style.position = "fixed";
                facedownBox.style.left = "1235px";
                facedownBox.style.top = "675px";
                facedownBox.style.width = "488px";
                facedownBox.style.height = "128px";
                facedownBox.style.zIndex = "100300";
                facedownBox.style.pointerEvents = "none";
                facedownBox.style.backgroundColor = "rgba(0, 255, 0, 0)";

            const arsenalBox = document.getElementById("playerArsenalBox");
                arsenalBox.style.position = "fixed";
                arsenalBox.style.left = "725px";
                arsenalBox.style.top = "820px";
                arsenalBox.style.width = "525px";
                arsenalBox.style.height = "128px";
                arsenalBox.style.zIndex = "100300"; // ensure it's above the board
                arsenalBox.style.pointerEvents = "none";
                arsenalBox.style.backgroundColor = "rgba(255, 0, 0, 0)"; // debug transparent background
            
            const facedownArsenalBox = document.getElementById("playerFaceDownArsenalBox");
                facedownArsenalBox.style.position = "fixed";
                facedownArsenalBox.style.left = "1235px";
                facedownArsenalBox.style.top = "820px";
                facedownArsenalBox.style.width = "488px";
                facedownArsenalBox.style.height = "128px";
                facedownArsenalBox.style.zIndex = "100300";
                facedownArsenalBox.style.pointerEvents = "none";
                facedownArsenalBox.style.backgroundColor = "rgba(255, 0, 0, 0)";

            const reserveBox = document.createElement("div");
                reserveBox.id = "playerReserveBox";
                reserveBox.className = "card-zone";
                reserveBox.style.position = "absolute";
                reserveBox.style.left = "375px";
                reserveBox.style.top = "525px";
                reserveBox.style.width = "292px";
                reserveBox.style.height = "275px";
                reserveBox.style.zIndex = "1000";
                reserveBox.style.pointerEvents = "none";
                reserveBox.style.backgroundColor = "rgba(255, 0, 0, 0)";
            document.body.appendChild(reserveBox);

            fetchUserData().then(userData => {
                if (userData && userData.zoneArt) {
                    const zoneArtContainer = document.createElement("div");
                        zoneArtContainer.style.position = "absolute";
                        zoneArtContainer.style.left = "0";
                        zoneArtContainer.style.bottom = "0";
                        zoneArtContainer.style.width = "100%";
                        zoneArtContainer.style.height = "50%";
                        zoneArtContainer.style.overflow = "hidden";

                    const zoneArtImage = document.createElement("img");
                        zoneArtImage.src = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Zones/${userData.zoneArt}`;
                        zoneArtImage.style.position = "absolute";
                        zoneArtImage.style.width = "100%";
                        zoneArtImage.style.height = "200%"; // Double height so top half is offscreen
                        zoneArtImage.style.top = "0%"; // Shift to crop top, show only bottom half
                        zoneArtImage.style.left = "0";
                        zoneArtImage.style.zIndex = "10";
                        zoneArtImage.style.border = "6px solid black";
                        zoneArtImage.style.objectFit = "cover";
                    zoneArtContainer.appendChild(zoneArtImage);
                    board.appendChild(zoneArtContainer);
                }
            });

            // After all elements like playerDeckBox and deckText are added
            fetchUserData().then(userData => {
                if (userData && userData.deckSleeve) {
                    playerDeckBox.style.backgroundImage = `url(https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Sleeves/${userData.deckSleeve})`;
                    playerDeckBox.style.backgroundSize = "cover";
                    playerDeckBox.style.backgroundPosition = "center";
                    playerDeckBox.style.backgroundRepeat = "no-repeat";
                }
            });

            // Function to add a box
            function addBox(x, y, w, h, color="green", backColor="black", opa="0.5") {
                const box = document.createElement("div");
                    box.style.position = "absolute";
                    box.style.left = x;
                    box.style.top = y;
                    box.style.width = w;
                    box.style.height = h;
                    box.style.border = `4px solid ${color}`;
                    box.style.backgroundColor = `${backColor}`;
                    box.style.opacity = `${opa}`;
                    box.style.zIndex = "30";
                board.appendChild(box);
            }

            // Reproduce visual layout from image (values are approximate %)
            addBox("1%", "1%", "6%", "19%", "lightsalmon");     // Opponent Deck
            addBox("9%", "1%", "68%", "19%", "lightsalmon");    // Opponent Arsenal

            addBox("79%", "1%", "20%", "40%", "lightsalmon");   // Opponent Reserve

            addBox("1%", "22%", "6%", "19%", "lightsalmon");    // Opponent Tomb
            addBox("9%", "22%", "68%", "19%", "lightsalmon");   // Opponent Champions

            addBox("1%", "44%", "10%", "14%", "lightsalmon");    // Opponent Void

            addBox("14%", "47%", "72%", "7%", "lightgreen");    // Path
            //addBox("65.8%", "48%", "19.75%", "5%", "white","","1"); // Back of turn count, player turn

            addBox("89%", "44%", "10%", "14%", "lightblue");   // Player Void

            addBox("1%", "60%", "20%", "40%", "lightblue");   // Player Reserve

            addBox("23%", "60%", "68%", "19%", "lightblue");  // Player Champions
            addBox("93%", "60%", "6%", "19%", "lightblue");  // Player Tomb

            addBox("23%", "81%", "68%", "19%", "lightblue");  // Player Arsenal
            addBox("93%", "81%", "6%", "19%", "lightblue");  // Player Deck

            document.body.appendChild(overlay);
            document.body.appendChild(mainContainer);
            mainContainer.appendChild(board);
            mainContainer.appendChild(resultBox);

            // Fade out the result box after 3 seconds
            setTimeout(() => {
                resultBox.style.opacity = "0"; // Fades out smoothly
            }, 2000);

            const params = new URLSearchParams(window.location.search);

            // Function to fetch user data from the session
            async function fetchUserData() {
                try {
                    const res = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/me', {
                        credentials: 'include'
                    });
                    if (!res.ok) throw new Error('Response error');

                    const data = await res.json();
                    if (!data.loggedIn) return null;

                    if (data && data.deckSleeve) {
                        userSleeveURL = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Sleeves/${data.deckSleeve}`;
                    }

                    return data;
                } catch (err) {
                    console.error('Failed to fetch user data:', err);
                    return null;
                }
            }

            // Fetch deck and start game
            const playerDeckName = new URLSearchParams(window.location.search).get("playerDeck");
            const opponentDeckName = new URLSearchParams(window.location.search).get("opponentDeck");

            const playerDeckResult = await fetchDeckCards(playerDeckName);
            const opponentDeckResult = await fetchDeckCards(opponentDeckName);

            if (!playerDeckResult.success || !opponentDeckResult.success) {
                console.error("Deck fetch failed");
                return;
            }

            const playerDeck = playerDeckResult.card_ids;
            shuffleDeck(playerDeck);

            const opponentDeck = opponentDeckResult.card_ids;
            shuffleDeck(opponentDeck);

            if (playerDeckResult.success && opponentDeckResult.success) {
                await fetch('https://geimon-app-833627ba44e0.herokuapp.com/startGame', {
                    method: 'POST',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        gameId,
                        playerUsername: username,
                        opponentUsername: isSinglePlayer ? "Bot" : otherPlayerName,
                        playerDeck,
                        opponentDeck,
                        isSinglePlayer: true,
                        goesFirst: choice === "first" ? username : (isSinglePlayer ? "Bot" : otherPlayerName)
                    })
                });

                gameState = await waitForGameState();

                if (gameState[username].Hand.length === 0) {
                    for (let i = 0; i < 5; i++) {
                        await drawCards(gameState[username].Deck, 1);
                    }
                    await sendZoneUpdate(["Deck", "Hand"]);
                }
                drawnCardsArray = gameState[username].Hand; // ‚úÖ Set the global array
                previousHandIds = drawnCardsArray.map(card => card.id); // ‚úÖ Track previous IDs
                await renderDrawnCards();
                await showRedrawPrompt(); // Pause here and show redraw
                hasDrawnInitialHand = true;

                updateDeckText();
                await updateLocalFromGameState();

                if (!intervalId) {
                intervalId = setInterval(async () => {
                    if (isFetchingGameState || discardMode) return;

                    isFetchingGameState = true;
                    try {
                        await fetchGameStateFromServer();
                    } catch (error) {
                        console.error("Error fetching game state:", error);
                    } finally {
                        isFetchingGameState = false;
                    }
                }, 1500);
            }

            const selectedTotem = params.get("totem");
            const selectedTotemText = params.get("totemText");

            const totemElement = document.createElement("p");
                totemElement.innerHTML = `${selectedTotem}`;
                totemElement.style.color = "goldenrod";
            const totemTextElement = document.createElement("p");
                totemTextElement.innerHTML = `<strong>Description:</strong> ${selectedTotemText}`;
            document.getElementById("game-log-placeholder").appendChild(totemElement);
            document.getElementById("game-log-placeholder").appendChild(totemTextElement);

            const totemBox = document.createElement("div");
                totemBox.style.position = "absolute";
                totemBox.style.top = "46%";
                totemBox.style.left = "53%";
                totemBox.style.transform = "translate(-50%, -50%)";
                totemBox.style.padding = "16px 32px";
                totemBox.style.backgroundColor = "goldenrod";
                totemBox.style.color = "white";
                totemBox.style.fontSize = "1.5em";
                totemBox.style.borderRadius = "10px";
                totemBox.style.textAlign = "center";
                totemBox.style.opacity = "0"; // Start invisible
                totemBox.style.transition = "opacity 1s ease-in-out";
                totemBox.style.zIndex = "100900";
                totemBox.style.boxShadow = "0 0 20px black";
                totemBox.textContent = `Selected Totem: ${selectedTotem} - ${selectedTotemText}`;

            // Add to document
            document.body.appendChild(totemBox);

            // Trigger fade-in
            setTimeout(() => {
                totemBox.style.opacity = "1";
            }, 1000); // Slight delay after result box

            setTimeout(() => {
                totemBox.style.opacity = "0";
                totemBox.style.zIndex = "10";
            }, 4000);

                const opponentName = isSinglePlayer ? "Bot" : otherPlayerName;
                document.getElementById("player-name").textContent = username;
                document.getElementById("player-life").textContent = gameState[username].life;

                document.getElementById("opponent-name").textContent = opponentName;
                document.getElementById("opponent-life").textContent = gameState[opponentName].life;

                //console.log("Creating game for", username, "vs", isSinglePlayer ? "Bot" : otherPlayerName);
                if (!gameReady) {
                    await fetchGameStateFromServer();
                    gameReady = true;
                }
                if (!gameState || !gameState[username]) {
                    alert("Game could not be started.");
                    return;
                }
            } else {
                console.error("Deck loading failed:", playerDeckResult.message);
            }
        }

        async function fetchDeckCards(deckName) {
        if (deckName === "Random") {
            // Generate a random deck locally
            const cardPool = cards.map(card => card.id); // Extract all IDs
            const deckSize = Math.floor(Math.random() * 41) + 60; // Random between 60‚Äì100
            const shuffled = cardPool.sort(() => 0.5 - Math.random());
            const card_ids = shuffled.slice(0, deckSize);

            deckCount = `${card_ids.length}`;
            if (playerDeckBox) {
                playerDeckBox.innerText = "Deck";
            }

            return { success: true, card_ids };
        }

        // Fallback to real server call for named decks
        try {
            const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                method: "POST",
                credentials: 'include',
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ deck_name: deckName })
            });

            const data = await response.json();

            if (data.success) {
                deckCount = `${data.card_ids.length}`;
                if (playerDeckBox) {
                    playerDeckBox.innerText = "Deck";
                }
            } else {
                deckCount = data.message;
            }

            return data;
        } catch (error) {
            console.error("Error fetching deck cards:", error);
            return { success: false, message: 'Fetch error' };
        }
    }

    // Select the existing Player Deck box after it's created
    const playerDeckBox = document.createElement("div");
        playerDeckBox.id = "playerDeckBox";
        playerDeckBox.style.position = "absolute";
        playerDeckBox.style.left = "1759px";
        playerDeckBox.style.top = "675px";
        playerDeckBox.style.width = "82px";
        playerDeckBox.style.height = "126px";
        //playerDeckBox.style.backgroundColor = "lightblue";
        playerDeckBox.style.outline = "0px solid white"; // Bright white outline for debugging
        playerDeckBox.style.display = "block"; // Ensure it's always visible
        playerDeckBox.style.zIndex = "1000"; // Bring it to the front layer
        playerDeckBox.style.opacity = "0"; // Start fully invisible
        playerDeckBox.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
        playerDeckBox.style.textAlign = "center"; // Ensures proper alignment
        playerDeckBox.style.fontWeight = "bold";
        playerDeckBox.style.fontSize = "1.2em";
        playerDeckBox.style.color = "white";
        playerDeckBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

    // Create the text span element separately
    const deckText = document.createElement("span");
        deckText.innerText = "Deck";
        deckText.style.position = "absolute"; // Positions independently inside the box
        deckText.style.left = "50%"; // Centers horizontally
        deckText.style.top = "70%"; // Moves text downward
        deckText.style.transform = "translate(-50%, -50%)"; // Ensures precise centering
    playerDeckBox.appendChild(deckText);
    document.body.appendChild(playerDeckBox); // Add to the document

    //Start of Tomb Box Stuff
    const playerTombBox = document.createElement("div");
        playerTombBox.id = "playerTombBox";
        playerTombBox.style.position = "absolute";
        playerTombBox.style.left = "1762px";  // Same X as Deck
        playerTombBox.style.top = "532px";   // Directly above the Deck
        playerTombBox.style.width = "88px";
        playerTombBox.style.height = "126px";
        playerTombBox.style.outline = "none";//"4px solid white";
        playerTombBox.style.zIndex = "1000";
        //playerTombBox.style.backgroundColor = "rgba(255, 0, 0)";
        playerTombBox.style.opacity = "0";
        playerTombBox.style.transition = "opacity 1s ease-in-out";
        playerTombBox.style.textAlign = "center";
        playerTombBox.style.fontWeight = "bold";
        playerTombBox.style.fontSize = "1.2em";
        playerTombBox.style.color = "white";
        playerTombBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

        const tombText = document.createElement("span");
            tombText.innerText = "Tomb";
            tombText.style.position = "absolute";
            tombText.style.left = "43%";
            tombText.style.top = "2%";
            tombText.style.transform = "translate(-50%, -50%)";
        playerTombBox.appendChild(tombText);
        document.body.appendChild(playerTombBox);

        setTimeout(() => {
            playerTombBox.style.opacity = "1";
        }, 6500);

        function updateTombText() {
            if (gameState && gameState[username]) {
                const count = gameState[username].Tomb.length;
                tombText.innerText = `${count}`;
                tombText.style.position = "absolute";
                tombText.style.left = "43%";
                tombText.style.top = "2%";
                tombText.style.transform = "translate(-50%, -50%)";
            }
        }

        playerTombBox.addEventListener("mouseenter", updateTombText);
        playerTombBox.addEventListener("mouseleave", () => {
            tombText.innerText = "Tomb";
            tombText.style.position = "absolute";
            tombText.style.left = "45%";
            tombText.style.top = "2%";
            tombText.style.transform = "translate(-50%, -50%)";
        });

    // Create Tomb Button Overlay
    const tombButton = document.createElement("button");
        tombButton.style.position = "absolute";
        tombButton.style.left = "1758px";
        tombButton.style.top = "540px";
        tombButton.style.width = "85px";
        tombButton.style.height = "113px"; //addBox("93%", "60%", "6%", "19%", "lightblue");  // Player Tomb
        tombButton.style.backgroundColor = "rgba(0, 255, 0)";
        tombButton.style.opacity = "0";
        tombButton.style.border = "none";
        tombButton.style.zIndex = "100800";
        tombButton.style.cursor = "pointer";
        tombButton.title = "Tomb";

        // Add event listener for click
        tombButton.addEventListener("click", () => {
            const popup = document.createElement("div");
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.maxWidth = "min(90%, 800px)";
                popup.style.overflowY = "auto";
                popup.style.maxHeight = "unset";
                popup.style.height = "auto";
                popup.style.overflow = "visible";
                popup.style.padding = "10px 20px";
                popup.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
                popup.style.border = "3px solid white";
                popup.style.borderRadius = "12px";
                popup.style.zIndex = "100900";
                popup.style.display = "flex";
                popup.style.flexDirection = "column";
                popup.style.alignItems = "center";
                popup.style.gap = "20px";

            const title = document.createElement("div");
                title.textContent = "Tomb";
                title.style.color = "white";
                title.style.fontSize = "2em";
                title.style.textAlign = "center";
            popup.appendChild(title);

            const tombCards = gameState?.[username]?.Tomb || [];

            if (tombCards.length === 0) {
                const none = document.createElement("div");
                none.textContent = "Tomb is empty.";
                none.style.color = "white";
                popup.appendChild(none);
            } else {
                const cardContainer = document.createElement("div");
                    cardContainer.style.display = "flex";
                    cardContainer.style.flexWrap = "wrap";
                    cardContainer.style.justifyContent = "center";
                    cardContainer.style.gap = "10px";
                    cardContainer.style.marginLeft = "-9px";
                    cardContainer.style.marginRight = "10px";
                    cardContainer.style.maxWidth = "100%";
                    cardContainer.style.overflow = "visible";

                const scale = 0.3;
                const cardWidth = 240;
                const cardHeight = 420;

                tombCards.forEach(cardData => {
                    const card = cards.find(c => String(c.id) === String(cardData.id));
                    if (!card) return;

                    const scale = 0.3;
                    const scaledCard = renderCard(card);
                        scaledCard.style.transform = `scale(${scale})`;
                        scaledCard.style.transformOrigin = "top left";
                        scaledCard.style.margin = "5px";
                        scaledCard.style.position = "relative";

                    const wrapper = document.createElement("div");
                        wrapper.style.width = `${260 * scale}px`;
                        wrapper.style.height = `${400 * scale}px`;
                        wrapper.style.overflow = "visible";
                        wrapper.style.position = "relative";

                    // Tomb card click overlay
                    const overlay = document.createElement("button");
                        overlay.style.position = "absolute";
                        overlay.style.top = "0";
                        overlay.style.left = "0";
                        overlay.style.width = "100%";
                        overlay.style.height = "100%";
                        overlay.style.opacity = "0";
                        overlay.style.border = "none";
                        overlay.style.background = "transparent";
                        overlay.style.cursor = "pointer";
                    overlay.onclick = () => alert(`Card in Tomb Clicked: ${card.name}`);

                    wrapper.appendChild(scaledCard);
                    wrapper.appendChild(overlay);

                    // Hover preview
                    wrapper.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                            scaled.innerHTML = "";
                        const preview = renderCard(card);
                            preview.style.width = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop = "7%";
                        scaled.appendChild(preview);
                    });

                    cardContainer.appendChild(wrapper);
                });
                popup.appendChild(cardContainer);
            }

            const closeBtn = document.createElement("button");
                closeBtn.textContent = "Close";
                closeBtn.style.marginTop = "10px";
                closeBtn.style.padding = "10px 20px";
                closeBtn.style.fontSize = "1.2em";
                closeBtn.style.cursor = "pointer";
                closeBtn.style.zIndex = "120000";
            closeBtn.onclick = () => popup.remove();
            popup.appendChild(closeBtn);

            document.body.appendChild(popup);
    });

    document.body.appendChild(tombButton);
    //End of Tomb Creation Stuff

    //Start of Void Box Stuff
    const playerVoidBox = document.createElement("div");
        playerVoidBox.id = "playerVoidBox";
        playerVoidBox.style.position = "absolute";
        playerVoidBox.style.left = "1697px";  // Same X as Deck
        playerVoidBox.style.top = "415px";   // Directly above the Deck
        playerVoidBox.style.width = "147px";
        playerVoidBox.style.height = "90px";
        playerVoidBox.style.outline = "none";//"4px solid white";
        playerVoidBox.style.zIndex = "1000";
        //playerVoidBox.style.backgroundColor = "rgba(255, 0, 0)";
        playerVoidBox.style.opacity = "0";
        playerVoidBox.style.transition = "opacity 1s ease-in-out";
        playerVoidBox.style.textAlign = "center";
        playerVoidBox.style.fontWeight = "bold";
        playerVoidBox.style.fontSize = "1.2em";
        playerVoidBox.style.color = "white";
        playerVoidBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

        const voidText = document.createElement("span");
            voidText.innerText = "Void";
            voidText.style.position = "absolute";
            voidText.style.left = "50%";
            voidText.style.top = "5%";
            voidText.style.transform = "translate(-50%, -50%)";

        playerVoidBox.appendChild(voidText);
        document.body.appendChild(playerVoidBox);

        setTimeout(() => {
            playerVoidBox.style.opacity = "1";
        }, 6500);

        function updateVoidText() {
            if (gameState && gameState[username]) {
                const count = gameState[username].Void.length;
                voidText.innerText = `${count}`;
            }
        }

        playerVoidBox.addEventListener("mouseenter", updateVoidText);
        playerVoidBox.addEventListener("mouseleave", () => {
            voidText.innerText = "Void";
        });

    // Create Void Button Overlay
    const voidButton = document.createElement("button");
        voidButton.style.position = "absolute";
        voidButton.style.left = "1697px";
        voidButton.style.top = "425px";
        voidButton.style.width = "149px";
        voidButton.style.height = "80px"; //addBox("89%", "44%", "10%", "14%", "lightblue");   // Player Void
        voidButton.style.backgroundColor = "rgba(255, 0, 0)";
        voidButton.style.opacity = "0";
        voidButton.style.border = "none";
        voidButton.style.zIndex = "100800";
        voidButton.style.cursor = "pointer";
        voidButton.title = "Void";

        // Add event listener for click
        voidButton.addEventListener("click", () => {
            const popup = document.createElement("div");
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.maxWidth = "min(90%, 800px)";
                popup.style.overflowY = "auto";
                popup.style.maxHeight = "unset";
                popup.style.height = "auto";
                popup.style.overflow = "visible";
                popup.style.padding = "10px 20px";
                popup.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
                popup.style.border = "3px solid white";
                popup.style.borderRadius = "12px";
                popup.style.zIndex = "100900";
                popup.style.display = "flex";
                popup.style.flexDirection = "column";
                popup.style.alignItems = "center";
                popup.style.gap = "20px";

            const title = document.createElement("div");
                title.textContent = "Void";
                title.style.color = "white";
                title.style.fontSize = "2em";
                title.style.textAlign = "center";
            popup.appendChild(title);

            const voidCards = gameState?.[username]?.Void || [];

            if (voidCards.length === 0) {
                const none = document.createElement("div");
                none.textContent = "Void is empty.";
                none.style.color = "white";
                popup.appendChild(none);
            } else {
                const cardContainer = document.createElement("div");
                    cardContainer.style.display = "flex";
                    cardContainer.style.flexWrap = "wrap";
                    cardContainer.style.justifyContent = "center";
                    cardContainer.style.gap = "10px";
                    cardContainer.style.maxWidth = "100%";
                    cardContainer.style.overflow = "visible";

                const scale = 0.3;
                const cardWidth = 240;
                const cardHeight = 420;

                voidCards.forEach(cardData => {
                    const card = cards.find(c => String(c.id) === String(cardData.id));
                    if (!card) return;

                    const scale = 0.3;
                    const scaledCard = renderCard(card);
                        scaledCard.style.transform = `scale(${scale})`;
                        scaledCard.style.transformOrigin = "top left";
                        scaledCard.style.margin = "5px";
                        scaledCard.style.position = "relative";

                    const wrapper = document.createElement("div");
                        wrapper.style.width = `${240 * scale}px`;
                        wrapper.style.height = `${420 * scale}px`;
                        wrapper.style.overflow = "visible";
                        wrapper.style.position = "relative";

                    // Void card click overlay
                    const overlay = document.createElement("button");
                        overlay.style.position = "absolute";
                        overlay.style.top = "0";
                        overlay.style.left = "0";
                        overlay.style.width = "100%";
                        overlay.style.height = "100%";
                        overlay.style.opacity = "0";
                        overlay.style.border = "none";
                        overlay.style.background = "transparent";
                        overlay.style.cursor = "pointer";
                    overlay.onclick = () => alert(`Card in Void Clicked: ${card.name}`);

                    wrapper.appendChild(scaledCard);
                    wrapper.appendChild(overlay);

                    // Hover preview
                    wrapper.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                            scaled.innerHTML = "";
                        const preview = renderCard(card);
                            preview.style.width = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop = "7%";
                        scaled.appendChild(preview);
                    });

                    cardContainer.appendChild(wrapper);
                });
                popup.appendChild(cardContainer);
            }

            const closeBtn = document.createElement("button");
                closeBtn.textContent = "Close";
                closeBtn.style.marginTop = "10px";
                closeBtn.style.padding = "10px 20px";
                closeBtn.style.fontSize = "1.2em";
                closeBtn.style.cursor = "pointer";
                closeBtn.style.zIndex = "120000";
            closeBtn.onclick = () => popup.remove();
            popup.appendChild(closeBtn);

            document.body.appendChild(popup);
    });

    document.body.appendChild(voidButton);
    //End of Void Stack Creation

    // Create Surrender Button Overlay
    const surrenderButton = document.createElement("button");
        surrenderButton.style.position = "absolute";
        surrenderButton.style.left = "1758px";
        surrenderButton.style.top = "690px";
        surrenderButton.style.width = "85px";
        surrenderButton.style.height = "113px";//addBox("93%", "81%", "6%", "19%", "lightblue");  // Player Deck
        surrenderButton.style.backgroundColor = "rgba(255, 0, 0)";
        surrenderButton.style.opacity = "0";
        surrenderButton.style.border = "none";
        surrenderButton.style.zIndex = "1001";
        surrenderButton.style.cursor = "pointer";
        surrenderButton.title = "Surrender";

    // Add event listener for click
    surrenderButton.addEventListener("click", () => {
        const confirmBox = document.createElement("div");
        confirmBox.style.position = "fixed";
        confirmBox.style.top = "50%";
        confirmBox.style.left = "50%";
        confirmBox.style.transform = "translate(-50%, -50%)";
        confirmBox.style.padding = "20px";
        confirmBox.style.backgroundColor = "#333";
        confirmBox.style.color = "white";
        confirmBox.style.border = "2px solid red";
        confirmBox.style.borderRadius = "10px";
        confirmBox.style.zIndex = "100900";
        confirmBox.style.textAlign = "center";
        confirmBox.style.boxShadow = "0 0 10px black";

        confirmBox.innerHTML = `
            <p style="margin-bottom: 20px;">Are you sure you'd like to surrender?</p>
            <button id="confirm-surrender" style="margin-right: 10px;">Surrender</button>
            <button id="cancel-surrender">Cancel</button>
        `;

        document.body.appendChild(confirmBox);

        document.getElementById("confirm-surrender").onclick = async () => {
            try {
                await fetch("https://geimon-app-833627ba44e0.herokuapp.com/endGame", {
                    method: "POST",
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        gameId,
                        loser: username,
                        reason: "Surrendered"
                    })
                });

                showLossBanner("You Lose", "Surrendered");
                document.body.removeChild(confirmBox);
            } catch (err) {
                console.error("Error ending game:", err);
                alert("Failed to surrender. Please try again.");
            }
        };

        document.getElementById("cancel-surrender").onclick = () => {
            document.body.removeChild(confirmBox);
        };
    });

    document.body.appendChild(surrenderButton);

        setTimeout(() => {
            playerDeckBox.style.opacity = "1";
        }, 6500);
        let deckCount = "Deck";

    // Ensure it exists before adding event listeners
    if (playerDeckBox) {
        playerDeckBox.style.display = "block";
        playerDeckBox.style.outline = "1px solid white";

        playerDeckBox.addEventListener("mouseenter", () => {
            playerDeckBox.innerText = deckCount;
        });

        // Mouse leave resets to "Deck"
        playerDeckBox.addEventListener("mouseleave", () => {
            playerDeckBox.innerText = "Deck";
        });
    }

    // Fetch deck count dynamically
    setTimeout(async () => {
        const urlParams = new URLSearchParams(window.location.search);

        async function getDeckFromParam(paramName) {
            const paramValue = urlParams.get(paramName);
            try {
                const parsed = JSON.parse(paramValue);
                if (Array.isArray(parsed)) {
                    return parsed; // Already a full random deck
                }
            } catch (e) {
                const result = await fetchDeckCards(paramValue);
                if (result.success) return result.card_ids;
                console.error(`Failed to load deck '${paramName}':`, result.message);
                return [];
            }
        }

        const playerDeckCardIds = await getDeckFromParam("playerDeck");
        const opponentDeckCardIds = await getDeckFromParam("opponentDeck");

        // You can now use these arrays:
        //console.log("Player Deck:", playerDeckCardIds);
        //console.log("Opponent Deck:", opponentDeckCardIds);

        // Optionally continue setup:
        // startGameWithDecks(playerDeckCardIds, opponentDeckCardIds);
    }, 200);


        let remainingDeck = []; // Store shuffled deck globally
        let drawnCardsArray = []; // Track drawn cards separately
        let initialDeckSize = 0; // Store starting deck size globally
        Object.defineProperty(window, 'gameState', {
            configurable: true,
            enumerable: true,
            get() {
                return window._gameState;
            },
            set(value) {
                //console.trace("üß† gameState updated:", value);
                if (value === undefined) {
                    console.warn("‚ö†Ô∏è gameState was set to undefined!");
                }
                window._gameState = value;
            }
        });

        // Initialize to empty object or null to avoid undefined errors
        window._gameState = {};


        // Function to update deck text dynamically
        function updateDeckText() {
            if (deckText) {
                deckText.innerText = `Deck (${remainingDeck.length}/${initialDeckSize})`; // Correct dynamic update
            }
        }

        // Function to shuffle the deck using Fisher-Yates algorithm
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        const CHAMPION_ZONE = "Zone (Champion)";
        const FACEDOWN_ZONE = "FaceDownZone";

        async function handleBasicRally(card) {
            //console.log("üîµ handleBasicRally invoked for:", card);

            if (!isBasicRallyAvailable(card, gameState.turn.currentPhase, gameState, username)) {
                console.warn("‚õî Rally not available for:", card.name);
                return;
            }

            // ‚úÖ Ask player how to rally
            const choice = await new Promise(resolve => {
                const popup = document.createElement("div");
                Object.assign(popup.style, {
                    position: "fixed",
                    top: "50%", left: "50%",
                    transform: "translate(-50%, -50%)",
                    backgroundColor: "#222",
                    padding: "20px",
                    border: "2px solid white",
                    borderRadius: "10px",
                    color: "white",
                    textAlign: "center",
                    zIndex: "120000"
                });

                popup.innerHTML = `
                    <p>Do you want to Rally this Champion?</p>
                    <button id="rally-faceup">Yes, Face-Up</button>
                    <button id="rally-facedown">Yes, Face-Down</button>
                    <button id="rally-cancel">Cancel Rally</button>
                `;

                document.body.appendChild(popup);

                document.getElementById("rally-faceup").onclick = () => {
                    document.body.removeChild(popup);
                    resolve("faceup");
                };
                document.getElementById("rally-facedown").onclick = () => {
                    document.body.removeChild(popup);
                    resolve("facedown");
                };
                document.getElementById("rally-cancel").onclick = () => {
                    document.body.removeChild(popup);
                    resolve("cancel");
                };
            });

            if (choice === "cancel") {
                console.log("‚ùå Rally cancelled by user.");
                return;
            }

            const ralliedCard = gameState[username].Hand.find(c => String(c.id) === String(card.id));
            if (!ralliedCard) {
                console.warn("‚ùå Card not found in Hand for rally:", card.id);
                return;
            }

            Object.assign(ralliedCard, card); // Enrich card
            ralliedCard.lastBoardState = "Hand";
            ralliedCard.boardState = choice === "facedown" ? FACEDOWN_ZONE : "Zone";

            // ‚úÖ Remove from hand
            gameState[username].Hand = gameState[username].Hand.filter(c => c.id !== ralliedCard.id);

            if (choice === "facedown") {
                // ‚ö†Ô∏è Mark card for flipping restriction
                ralliedCard.faceDown = true;
                ralliedCard.setTurn = gameState.turn.count;

                if (!gameState[username][FACEDOWN_ZONE]) {
                    gameState[username][FACEDOWN_ZONE] = [];
                }

                gameState[username][FACEDOWN_ZONE].push(ralliedCard);
                gameState[username].hasBasicRallied = true;

                addGameLogEntry(`${username} Basic Rallied a Champion face-down`);
            } else {
                gameState[username][CHAMPION_ZONE].push(ralliedCard);
                gameState[username].hasBasicRallied = true;

                // ‚úÖ Trigger Rally effects (Face-Up only)
                AbilityExecutor.handleBoardStateChange(
                    ralliedCard,
                    ralliedCard.boardState,
                    ralliedCard.lastBoardState,
                    gameState,
                    username,
                    gameId,
                    updateLocalFromGameState,
                    addGameLogEntry
                );

                addGameLogEntry(`${username} performed a Basic Rally with ${card.name}`);
            }

            try {
                const updatedZones = {
                    Hand: gameState[username].Hand,
                    hasBasicRallied: true
                };
                if (choice === "facedown") {
                    updatedZones[FACEDOWN_ZONE] = gameState[username][FACEDOWN_ZONE];
                } else {
                    updatedZones[CHAMPION_ZONE] = gameState[username][CHAMPION_ZONE];
                }

                const res = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/updateGameState", {
                    method: "POST",
                    credentials: "include",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        gameId,
                        owner: username,
                        updatedZones
                    })
                });

                const responseJson = await res.json();
                if (responseJson?.updatedPlayerZone) {
                    gameState[username] = responseJson.updatedPlayerZone;
                }
                updateLocalFromGameState();
            } catch (err) {
                console.error("üí• Error sending rally update:", err);
            }

            updateAllRallyHighlights(gameState.turn.currentPhase, gameState, username);
        }

        const ARSENAL_ZONE = "Zone (Arsenal)";
        const FACEDOWN_ARSENAL_ZONE = "FaceDownArsenalZone";

        function renderDrawnCards() {
            const drawnCardsContainer = document.getElementById("drawn-cards");
            const scaledCardContainer = document.getElementById("scaled-card");
            const viewingWindow = document.getElementById("viewing-window");
            const contextWindow = document.getElementById("context-window");
            const playerLifeWindow = document.getElementById("player-life-window");
            const opponentLifeWindow = document.getElementById("opponent-life-window");
            const phaseTracker = document.getElementById("phase-tracker");
            const turnCounter = document.getElementById("turn-counter");
            const currentPhase = gameState?.turn?.currentPhase;

            drawnCardsContainer.innerHTML = ""; // Clear previous renders

            if (drawnCardsArray.length === 0) {
                console.log("No cards have been drawn yet.");
                return;
            }

            // Sort drawn cards (optional, as you had)
            drawnCardsArray.sort((a, b) => {
                const cardA = cards.find(c => String(c.id) === String(a.id));
                const cardB = cards.find(c => String(c.id) === String(b.id));
                if (!cardA || !cardB) return 0;

                const typeOrder = ["Champion", "Action", "Equipment", "Obelisk", "Rush", "Reflex"];
                const indexA = typeOrder.indexOf(cardA.type);
                const indexB = typeOrder.indexOf(cardB.type);

                if (indexA !== indexB) return indexA - indexB;
                return cardA.name.localeCompare(cardB.name);
            });

            // --- Now render each drawn card ---
            drawnCardsArray.forEach(cardObj => {
                const card = cards.find(c => String(c.id) === String(cardObj.id));
                if (!card) return;

                const cardElement = renderCard(card);
                cardElement.dataset.boardState = cardObj.boardState;
                cardElement.dataset.lastBoardState = cardObj.lastBoardState;
                cardElement.dataset.cardId = String(card.id); // Ensure this is set for lookup!
                cardElement.style.transform = "scale(0.5)";
                cardElement.style.position = "relative";
                cardElement.style.marginLeft = "-15%";
                cardElement.style.opacity = "1";
                cardElement.style.transition = "opacity 1s ease-in-out";

                // Invisible button to capture clicks
                const cardButton = document.createElement("button");
                cardButton.classList.add("card-button");
                cardButton.style.position = "absolute";
                cardButton.style.top = "0";
                cardButton.style.right = "0";
                cardButton.style.width = "100%";
                cardButton.style.height = "100%";
                cardButton.style.opacity = "0";
                cardButton.style.background = "transparent";
                cardButton.style.border = "none";
                cardButton.style.pointerEvents = "auto";
                cardButton.style.padding = "5px";
                cardButton.style.zIndex = "100100";
                cardButton.style.cursor = "pointer";

                cardButton.onclick = () => {
                    const parentCard = cardButton.closest(".card");
                    const cardId = parentCard?.dataset.cardId;
                    
                    if (window.sacrificeMode && window.validSacrificeIds?.has(cardId)) {
                        const cardData = findCardByUidOrId(cardId);
                        if (!cardData) return;

                        const confirmBox = document.createElement("div");
                        Object.assign(confirmBox.style, {
                            position: "fixed",
                            top: "50%",
                            left: "50%",
                            transform: "translate(-50%, -50%)",
                            padding: "20px",
                            backgroundColor: "#333",
                            color: "white",
                            border: "2px solid white",
                            borderRadius: "10px",
                            zIndex: "120001",
                            textAlign: "center",
                            boxShadow: "0 0 10px black"
                        });

                        confirmBox.innerHTML = `
                            <p>Sacrifice <strong>${cardData.name}</strong>?</p>
                            <button id="confirm-sacrifice">Confirm</button>
                            <button id="cancel-sacrifice" style="margin-left: 10px;">Cancel</button>
                        `;

                        document.body.appendChild(confirmBox);

                        document.getElementById("confirm-sacrifice").onclick = () => {
                            document.body.removeChild(confirmBox);
                            const matchingCard = validCards.find(c => String(c.id) === String(cardId) || String(c.id) === String(cardId));
                            if (matchingCard) {
                                selected.push(matchingCard);
                                parentCard.classList.add("selected");

                                if (selected.length === amount) {
                                    for (const c of validCards) {
                                        const el2 = document.getElementById(`card-${c.id}`);
                                        if (el2) {
                                            el2.classList.remove("selectable", "selected");
                                            el2.onclick = null;
                                        }
                                    }
                                    document.body.removeChild(confirmBox);
                                    document.body.removeChild(banner);
                                    window.sacrificeMode = false;
                                    window.validSacrificeIds = null;
                                    resolve(selected);
                                }
                            }
                        };

                        document.getElementById("cancel-sacrifice").onclick = () => {
                            document.body.removeChild(confirmBox);
                        };

                        return; // ‚õî Block normal behavior
                    }

                    // Existing behavior follows below...
                    //console.log("Card button clicked");

                    if (!cardId) {
                        console.warn("‚ùå No cardId found on clicked card");
                        return;
                    }

                    if (discardMode) {
                        event.stopPropagation();
                        event.preventDefault();
                        return handleCardDiscard(gameState, username, cards, gameId, currentPhase, updateLocalFromGameState, addGameLogEntry, updatePhaseDisplay);
                    }

                    const fullCard = cards.find(c => String(c.id) === String(cardId));
                    if (!fullCard) {
                        console.warn("‚ùå Card not found in cards array:", cardId);
                        return;
                    }

                    if (isBasicRallyAvailable(fullCard, currentPhase, gameState, username)) {
                        handleBasicRally(fullCard); // ‚úÖ Trigger Basic Rally
                    } else if (isCostRallyAvailable(fullCard, currentPhase, gameState, username)) {
                        showCostRallyPrompt(fullCard); // ‚úÖ Trigger Cost Rally
                    }

                    updateAllRallyHighlights(currentPhase, gameState, username);
                };

                cardButton._originalHandler = cardButton.onclick;

                cardElement.classList.remove("highlight-rally", "card-select-for-arsenal");

                // Initial highlight check for this card
                updateBasicRallyHighlight(cardElement, card, currentPhase, gameState, username);
                updateCostRallyHighlight(cardElement, card, currentPhase, gameState, username);

                if (!discardMode && isArsenalSetAvailable(card, currentPhase, gameState, username)) {
                    cardElement.classList.add("card-select-for-arsenal");
                    cardElement.addEventListener("click", (e) => {
                        e.stopPropagation();
                        showSetArsenalPrompt(cardObj, card);
                    });
                } else {
                    cardElement.classList.remove("card-select-for-arsenal");
                }

                // Hover effect for preview
                cardElement.addEventListener("mouseenter", () => {
                    scaledCardContainer.innerHTML = "";
                    const clone = cardElement.cloneNode(true);
                    const cloneButton = clone.querySelector(".card-button");
                    if (cloneButton) cloneButton.remove();
                    clone.style.transform = "scale(1.2)";
                    clone.style.width = "100%";
                    clone.style.position = "relative";
                    scaledCardContainer.appendChild(clone);
                    addTooltipListeners(clone);
                    addTokenTooltipListeners(clone);
                });

                cardElement.appendChild(cardButton);
                drawnCardsContainer.appendChild(cardElement);

                // Fade in after render
                setTimeout(() => {
                    cardElement.style.opacity = "1";
                    cardButton.style.opacity = "1";
                    cardButton.style.cursor = "pointer";
                }, 1500);
            });

            // Fade in UI overlays
            setTimeout(() => {
                viewingWindow.style.opacity = "1";
                contextWindow.style.opacity = "1";
                playerLifeWindow.style.opacity = "1";
                opponentLifeWindow.style.opacity = "1";
                phaseTracker.style.opacity = "1";
                turnCounter.style.opacity = "1";
            }, 2500);
        }

        function updateBasicRallyHighlight(cardElement, cardData, currentPhase, gameState, username) {
            if (isBasicRallyAvailable(cardData, currentPhase, gameState, username)) {
                //console.log("üîµ Adding glow to", cardData.name);
                cardElement.classList.add("basic-rally-highlight");
            } else {
                //console.log("‚ö™ Removing glow from", cardData.name);
                cardElement.classList.remove("basic-rally-highlight");
            }
        }

        function updateCostRallyHighlight(cardElement, cardData, currentPhase, gameState, username) {
            if (isCostRallyAvailable(cardData, currentPhase, gameState, username)) {
                //console.log("üîµ Adding glow to", cardData.name);
                cardElement.classList.add("cost-rally-highlight");
            } else {
                //console.log("‚ö™ Removing glow from", cardData.name);
                cardElement.classList.remove("cost-rally-highlight");
            }
        }

        async function updateAllRallyHighlights(currentPhase, gameState, username) {
            const cardElements = document.querySelectorAll(".card");
            cardElements.forEach(cardEl => {
                const cardId = cardEl.dataset.cardId;
                // Look up the full card by ID from full cards array
                const fullCard = cards.find(c => String(c.id) === String(cardId));
                if (!fullCard) {
                    console.warn("Card data not found for rally highlight ID:", cardId);
                    return;
                }
                updateBasicRallyHighlight(cardEl, fullCard, currentPhase, gameState, username);
                updateCostRallyHighlight(cardEl, fullCard, currentPhase, gameState, username);
            });
        }

        function isArsenalSetAvailable(card, currentPhase, gameState, username) {
            const isMainPhase = currentPhase.toLowerCase().startsWith("main") &&
                                gameState?.turn?.currentPlayer === username;
            const type = String(card.type || "").toLowerCase();
            const isValidType = ["action", "rush", "reflex", "equipment", "obelisk"].includes(type);
            return isMainPhase && isValidType;
        }

        function isBasicRallyAvailable(card, currentPhase, gameState, username) {
            //console.log("=== Checking Basic Rally ===");
            //console.log("currentPhase:", currentPhase);
            //console.log("gameState.turn:", gameState.turn, "username:", username);
            //console.log("card.cost:", card.cost);
            //console.log("hasBasicRallied:", gameState[username]?.hasBasicRallied);
            //console.log("User zone data:", gameState[username]);
            const isMainPhase = currentPhase.toLowerCase().startsWith("main") && gameState?.turn?.currentPlayer === username;
            const cost = String(card.cost || "").toLowerCase();
            const hasRallied = gameState[username]?.hasBasicRallied === true;
            return isMainPhase && cost === "basic" && !hasRallied;
        }

        function isCostRallyAvailable(card, currentPhase, gameState, username) {
            if (!card || card.type !== "Champion") return false;
            if (!card.cardCostFunction || card.cardCostFunction === "UseBasic") return false;

            const turnPlayer = gameState.turn?.currentPlayer;
            const isMain = currentPhase === "Main 1" || currentPhase === "Main 2";
            if (turnPlayer !== username || !isMain) return false;

            const deck = gameState[username]?.Deck || [];
            const life = gameState[username]?.life ?? 0;
            const controlledChampions = [
                ...(gameState[username]["Zone (Champion)"] || []),
                ...(gameState[username]["FaceDownZone"] || [])
            ];

            const costString = card.cardCostFunction;
            const costRegex = /(Offer|Mill|Sacrifice)(\d+)/g;

            let match;
            const checks = [];

            while ((match = costRegex.exec(costString)) !== null) {
                const [_, costType, amountStr] = match;
                const amount = parseInt(amountStr, 10);
                if (isNaN(amount)) return false;

                if (costType === "Offer") {
                    checks.push(life > amount);
                } else if (costType === "Mill") {
                    checks.push(deck.length >= amount);
                } else if (costType === "Sacrifice") {
                    checks.push(controlledChampions.length >= amount);
                }
            }
            return checks.length > 0 && checks.every(Boolean);
        }

        function showRallyPrompt(card, rallyHandler) {
            const popup = document.createElement("div");
            Object.assign(popup.style, {
                position: "fixed",
                top: "50%", left: "50%",
                transform: "translate(-50%, -50%)",
                padding: "20px",
                backgroundColor: "#222",
                border: "2px solid white",
                color: "white",
                borderRadius: "10px",
                zIndex: "100000",
                textAlign: "center"
            });

            popup.innerHTML = `
                <p>Do you want to Rally this Champion?</p>
                <button id="rally-faceup">Yes, Face-Up</button>
                <button id="rally-facedown">Yes, Face-Down</button>
                <button id="rally-cancel">Cancel Rally</button>
            `;

            document.body.appendChild(popup);

            document.getElementById("rally-faceup").onclick = () => {
                document.body.removeChild(popup);
                rallyHandler(card, true); // true = face-up
            };

            document.getElementById("rally-facedown").onclick = () => {
                document.body.removeChild(popup);
                rallyHandler(card, false); // false = face-down
            };

            document.getElementById("rally-cancel").onclick = () => {
                document.body.removeChild(popup);
            };
        }

        async function updatePhaseDisplay(currentPhase) {
            const turnCount = gameState?.turn?.count || 0;
            const currentPlayer = gameState?.turn?.currentPlayer;
            const isPlayerTurn = currentPlayer === username;

            // Define valid transitions
            const allowedTransitions = {
                "Intermission": ["Draw"],
                "Draw": ["Main 1"],
                "Main 1": ["Battle", "End"],
                "Battle": ["Main 2"],
                "Main 2": ["End"]
            };

            document.querySelectorAll('.phase-box').forEach(box => {
                const phase = box.textContent.trim();
                box.classList.remove('active');
                if (turnCount === 1 && (phase === "Battle" || phase === "Main 2")) {
                    box.style.backgroundColor = "darkred";
                    box.style.cursor = "not-allowed";
                    return;
                }
                if (!isPlayerTurn) {
                    box.style.cursor = "not-allowed";
                    box.style.backgroundColor = "dimgray";
                    return;
                }
                const validNextPhases = allowedTransitions[currentPhase] || [];
                if (validNextPhases.includes(phase)) {
                    box.style.cursor = "pointer";
                    box.style.backgroundColor = "lightgray";
                } else {
                    box.style.cursor = "not-allowed";
                    box.style.backgroundColor = "dimgray";
                }
            });

            const activeBox = document.getElementById(`phase-${currentPhase}`);
            if (activeBox) {
                activeBox.classList.add('active');
                activeBox.style.backgroundColor = "lightgreen";
            }

            const turnNum = gameState.turn?.count;

            if (
                currentPhase === "Intermission" &&
                isPlayerTurn &&
                turnNum !== lastLoggedIntermissionTurn
            ) {
                addGameLogEntry(`${username}'s turn. Turn #${turnNum}`);
                addGameLogEntry(`${username} changed phase to Intermission`);
                lastLoggedIntermissionTurn = turnNum; // ‚úÖ Prevent duplicate logs
                if (gameState[username]) {
                    gameState[username].hasBasicRallied = false;
                    await fetch("https://geimon-app-833627ba44e0.herokuapp.com/updateGameState", {
                        method: "POST",
                        credentials: "include",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            gameId,
                            owner: username,
                            updatedZones: {
                                hasBasicRallied: false
                            }
                        })
                    });
                    //console.log("üîÑ Reset hasBasicRallied for", username);
                }
            }
            if (currentPhase === "Main 1" || currentPhase === "Main 2") {
                renderDrawnCards();
            }
        }
        async function drawCards(deck, numCards = 5) {
        if (deck.length < numCards) {
            console.warn("Not enough cards left to draw.");
            return [];
        }

        function getCardsFromZone(zone, count) {
            return zone.splice(0, count);
        }

        function renderZone(zoneName, owner = username) {
            const cards = gameState[owner][zoneName];
        }

        const drawnCards = getCardsFromZone(gameState[username].Deck, numCards);
        drawnCards.forEach(card => {
            card.lastBoardState = card.boardState;
            card.boardState = "Hand";
        });
        gameState[username].Hand.push(...drawnCards);

        // Debugging logs for confirmation
        //console.log("Initial Hand:", drawnCards);
        //console.log("Remaining Deck Contents:", deck);

        await sendZoneUpdate(["Deck", "Hand"]);

        renderDrawnCards();
        updateDeckText();
        return drawnCards;
        }

        async function sendZoneUpdate(zones) {
            const updatedZones = {};
            zones.forEach(z => {
                updatedZones[z] = gameState[username][z];
            });

            await fetch('https://geimon-app-833627ba44e0.herokuapp.com/updateGameState', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    gameId,
                    updatedZones,
                    owner: username
                })
            });
        }

        // Function to update deck count visually
        function updateDeckCount() {
            if (playerDeckBox) {
                playerDeckBox.innerText = `Deck`;
            }
        }

        async function renderCardZone(cardsArray, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            container.innerHTML = ""; // Clear previous

            if (!cardsArray || cardsArray.length === 0) return;

            const half = Math.floor(cardsArray.length / 2);
            const ordered = [];

            for (let i = 0; i < cardsArray.length; i++) {
                const offset = i % 2 === 0 ? i / 2 : -(Math.ceil(i / 2));
                ordered.push(cardsArray[half + offset] || cardsArray[half - offset]);
            }

            if (!userSleeveURL) {
                userSleeveURL = await fetchUserData();
            }

            ordered.forEach(cardData => {
                if (!cardData || !cardData.id) {
                    console.warn("‚ùó Skipping cardData due to missing ID:", cardData);
                    return;
                }
                const card = cards.find(c => String(c.id) === String(cardData.id));
                const isFaceDownArsenal = cardData.boardState === "FaceDownArsenalZone";

                const isFaceDown = !!cardData.faceDown;
                if (!cardData.id) {
                    console.warn("‚ùó Invalid cardData: missing ID", cardData);
                    return;
                }

                if (!card && !isFaceDown) return;

                let element;

                if (isFaceDownArsenal) {
                    const arsenalWrapper = document.createElement("div");
                    arsenalWrapper.style.display = "inline-block";
                    arsenalWrapper.style.position = "relative";
                    arsenalWrapper.style.marginLeft = "-33.8%";
                    arsenalWrapper.style.transformOrigin = "top center";
                    arsenalWrapper.style.marginTop = "-16px";
                    arsenalWrapper.style.pointerEvents = "auto";
                    arsenalWrapper.style.backgroundColor = "rgba(255,0,0,0)";
                    arsenalWrapper.style.width = "260px";
                    arsenalWrapper.style.height = "400px";
                    arsenalWrapper.style.transform = "scale(0.3)";
                    arsenalWrapper.style.outline = "0px dashed red";
                    arsenalWrapper.style.cursor = "pointer";

                    const arsenalCard = document.createElement("div");
                    arsenalCard.style.width = "100%";
                    arsenalCard.style.height = "100%";
                    arsenalCard.style.backgroundImage = `url(${userSleeveURL || 'default-sleeve.png'})`;
                    arsenalCard.style.backgroundSize = "cover";
                    arsenalCard.style.backgroundPosition = "center";
                    arsenalCard.style.border = "2px solid white";
                    arsenalCard.style.position = "relative";
                    arsenalCard.style.zIndex = "110";
                    arsenalCard.style.pointerEvents = "none";
                    arsenalCard.style.opacity = "1";
                    arsenalCard.style.transition = "opacity 1s ease-in-out";

                    // Hover logic for scaled preview
                    arsenalWrapper.addEventListener("mouseenter", () => {
                        const full = cards.find(c => String(c.id) === String(cardData.id));
                        if (!full) {
                            console.error(`‚ùå No card found with ID '${cardData.id}' for preview.`);
                            return;
                        }

                        const scaled = document.querySelector("#viewing-window .scaled-card");
                        if (!scaled) {
                            console.warn("‚ö†Ô∏è #viewing-window .scaled-card not found.");
                            return;
                        }

                        scaled.innerHTML = "";

                        const preview = renderCard(full);
                        preview.style.width = "240px";
                        preview.style.height = "420px";
                        preview.style.transform = "scale(1.2)";
                        preview.style.marginLeft = "-15%";
                        preview.style.marginTop = "7%";

                        scaled.appendChild(preview);
                    });

                    arsenalWrapper.appendChild(arsenalCard);
                    container.appendChild(arsenalWrapper);
                    return;
                }

                if (isFaceDown) {
                    const wrapperDiv = document.createElement("div");
                    wrapperDiv.id = `card-${cardData.id}`;
                        wrapperDiv.style.display = "inline-block";
                        wrapperDiv.style.position = "relative";
                        wrapperDiv.style.marginLeft = "-39.3%";
                        wrapperDiv.style.transformOrigin = "top center";
                        wrapperDiv.style.marginTop = "16px";
                        wrapperDiv.style.pointerEvents = "auto";
                        wrapperDiv.style.backgroundColor = "rgba(255,0,0,0)";
                        wrapperDiv.style.width = "260px";
                        wrapperDiv.style.height = "400px";
                        wrapperDiv.style.transform = "translateY(11%) rotate(270deg) scale(0.33)";
                        wrapperDiv.style.outline = "0px dashed red"; // visually show wrapperDiv box
                        wrapperDiv.style.cursor = "pointer";

                    if (window.sacrificeMode && window.validSacrificeIds?.has(String(cardData.id))) {
                        const button = document.createElement("div");
                            button.className = "card-button";
                            button.style.position = "absolute";
                            button.style.top = "0";
                            button.style.left = "0";
                            button.style.width = "100%";
                            button.style.height = "100%";
                            button.style.backgroundColor = "rgba(255,0,0,0)";
                            button.style.display = "flex";
                            button.style.alignItems = "center";
                            button.style.justifyContent = "center";
                            button.style.fontWeight = "bold";
                            button.style.cursor = "pointer";
                            button.style.zIndex = "999";
                        wrapperDiv.appendChild(button);

                        button.onclick = (e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            console.log("üî• Sacrifice button clicked (facedown):", cardData.id);
                            // Try to find the actual card object from gameState zones (not just from 'cards' array)
                            const fullCard = (gameState[username]["Zone (Champion)"] || [])
                                .concat(gameState[username]["FaceDownZone"] || [])
                                .find(c => String(c.id) === String(cardData.id));

                            if (!fullCard) {
                                console.error("‚ùå Could not find full card in gameState for sacrifice.");
                                return;
                            }

                            // Create confirmation popup
                            const confirmBox = document.createElement("div");
                            Object.assign(confirmBox.style, {
                                position: "fixed",
                                top: "50%",
                                left: "50%",
                                transform: "translate(-50%, -50%)",
                                padding: "20px",
                                backgroundColor: "#333",
                                color: "white",
                                border: "2px solid white",
                                borderRadius: "10px",
                                zIndex: "120001",
                                textAlign: "center",
                                boxShadow: "0 0 10px black"
                            });

                            confirmBox.innerHTML = `
                                <p>Are you sure you want to sacrifice <strong>${fullCard.name}</strong>?</p>
                                <button id="confirm-sacrifice">Confirm</button>
                                <button id="cancel-sacrifice" style="margin-left: 10px;">Cancel</button>
                            `;

                            document.body.appendChild(confirmBox);

                            // Confirm button handler
                            document.getElementById("confirm-sacrifice").onclick = () => {
                                document.body.removeChild(confirmBox);
                                if (window.__pendingSacrificeSelection) {
                                    window.__pendingSacrificeSelection(fullCard);
                                }
                            };

                            // Cancel button handler
                            document.getElementById("cancel-sacrifice").onclick = () => {
                                document.body.removeChild(confirmBox);
                            };
                        };
                    }

                    element = document.createElement("div");
                        element.style.width = "100%"; // fill wrapper
                        element.style.height = "100%";
                        element.style.backgroundImage = `url(${userSleeveURL || 'default-sleeve.png'})`;
                        element.style.backgroundSize = "cover";
                        element.style.backgroundPosition = "center";
                        element.style.transform = ""; // reset transform
                        element.style.marginTop = "0px";
                        element.style.position = "relative";
                        element.style.zIndex = "110";
                        element.style.border = "2px solid white";
                        element.style.pointerEvents = "none";
                        element.style.opacity = "1";
                        element.style.transition = "opacity 1s ease-in-out";

                    wrapperDiv.addEventListener("mouseenter", () => {
                        //console.log("mouseenter fired on face-down card", cardData.id);
                        const realCard = cards.find(c => String(c.id) === String(cardData.id));
                        if (!realCard) {
                            console.error(`‚ùå Hover preview: No card found with ID '${cardData.id}'. Check if the card exists in 'cards' array.`);
                            return;
                        }

                        const scaled = document.querySelector("#viewing-window .scaled-card");
                        if (!scaled) {
                            console.warn("‚ö†Ô∏è #viewing-window .scaled-card not found!");
                            return;
                        }

                        scaled.innerHTML = "";

                        const preview = renderCard(realCard);
                        preview.style.width = "240px";
                        preview.style.height = "420px";
                        preview.style.transform = "scale(1.2)";
                        preview.style.marginLeft = "-15%";
                        preview.style.marginTop = "7%";

                        scaled.appendChild(preview);
                    });

                    const canFlip =
                        gameState.turn.currentPlayer === username &&
                        gameState.turn.count > cardData.setTurn &&
                        (gameState.turn.currentPhase === "Main 1" || gameState.turn.currentPhase === "Main 2");

                    if (canFlip) {
                        wrapperDiv.style.outline = "4px solid yellow"; // ‚ú® glow
                        wrapperDiv.style.boxShadow = "0 0 12px 4px yellow";
                        wrapperDiv.style.cursor = "pointer";
                        wrapperDiv.style.transition = "box-shadow 0.3s ease-in-out, outline 0.3s ease-in-out";

                        wrapperDiv.onclick = () => {
                            const fullCard = cards.find(c => String(c.id) === String(cardData.id));
                            if (!fullCard) {
                                console.error("‚ùå Could not find full card data for flip prompt.");
                                return;
                            }

                            // Create popup
                            const popup = document.createElement("div");
                            Object.assign(popup.style, {
                                position: "fixed",
                                top: "50%",
                                left: "50%",
                                transform: "translate(-50%, -50%)",
                                backgroundColor: "rgba(0, 0, 0, 0.9)",
                                color: "white",
                                padding: "20px 30px",
                                border: "2px solid white",
                                borderRadius: "10px",
                                zIndex: "120000",
                                textAlign: "center",
                                boxShadow: "0 0 15px black",
                            });

                            popup.innerHTML = `
                                <p style="font-size: 1.2em; margin-bottom: 10px;">Flip <strong>${fullCard.name}</strong> face-up?</p>
                                <button id="confirm-flip" style="margin: 5px; padding: 6px 12px; font-size: 1em;">Flip</button>
                                <button id="cancel-flip" style="margin: 5px; padding: 6px 12px; font-size: 1em;">Cancel</button>
                            `;

                            document.body.appendChild(popup);

                            document.getElementById("confirm-flip").onclick = () => {
                                popup.remove();
                                flipCard(cardData.id);
                            };

                            document.getElementById("cancel-flip").onclick = () => {
                                popup.remove();
                            };
                        };
                    }
                    wrapperDiv.appendChild(element);
                    container.appendChild(wrapperDiv);
                } else {
                    element = renderCard(card);
                    //console.log("Trying to render:", card);
                        element.style.transform = "scale(0.3)";
                        element.style.marginLeft = "-19%";
                        element.style.transformOrigin = "top center";
                        element.style.position = "relative";
                        element.style.pointerEvents = "auto";

                    element.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                        scaled.innerHTML = "";

                        const preview = renderCard(card);
                            preview.style.width = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop = "7%";

                        scaled.appendChild(preview);
                    });
                    //console.log("Rendering Champion Zone IDs:", cardsArray.map(c => c.id));
                    //console.log("DOM children count before:", container.children.length);
                    container.appendChild(element);
                }
            });
        }

        async function flipCard(cardId) {
            const facedownZone = gameState[username].FaceDownZone;
            const championsZone = gameState[username]["Zone (Champion)"];

            const cardIndex = facedownZone.findIndex(c => String(c.id) === String(cardId));
            if (cardIndex === -1) {
                console.warn("‚ùå Card not found in FaceDownZone:", cardId);
                return;
            }

            const card = facedownZone[cardIndex];

            // ‚ùå Only the player on their turn can flip
            if (gameState.turn.currentPlayer !== username) {
                alert("You can only flip cards during your turn.");
                return;
            }

            // ‚ùå Only during Main 1 or Main 2
            const phase = gameState.turn.currentPhase;
            if (phase !== "Main 1" && phase !== "Main 2") {
                alert("You can only flip champions face-up during your Main Phase.");
                return;
            }

            // ‚ùå Cannot flip the turn it's set
            if (gameState.turn.count <= card.setTurn) {
                alert("You cannot flip this card the turn it was set.");
                return;
            }

            // ‚úÖ Move to Champion Zone
            facedownZone.splice(cardIndex, 1);
            delete card.faceDown;
            delete card.setTurn;
            card.lastBoardState = "FaceDownZone";
            card.boardState = "Zone (Champion)";
            championsZone.push(card);

            AbilityExecutor.handleBoardStateChange(
                card,
                "Zone (Champion)",
                "FaceDownZone",
                gameState,
                username,
                gameId,
                updateLocalFromGameState,
                addGameLogEntry
            );

            addGameLogEntry(`${username} flipped a champion face-up: ${card.name}`);

            await fetch("https://geimon-app-833627ba44e0.herokuapp.com/updateGameState", {
                method: "POST",
                credentials: "include",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    gameId,
                    owner: username,
                    updatedZones: {
                        FaceDownZone: facedownZone,
                        [CHAMPION_ZONE]: championsZone
                    }
                })
            });

            updateLocalFromGameState();
        }

        // Fetch and shuffle deck, then update count
        async function fetchAndShuffleDeck(deckParam) {
            let cardIds = [];

            try {
                // Try to parse as a JSON array
                const parsed = JSON.parse(deckParam);
                if (Array.isArray(parsed)) {
                    cardIds = parsed;
                } else {
                    // Fallback to server fetch
                    const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                        method: "POST",
                        credentials: "include",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({ deck_name: deckParam }),
                    });

                    const data = await response.json();
                    if (!data.success) {
                        console.error("Error:", data.message);
                        return;
                    }

                    cardIds = data.card_ids;
                }
            } catch (e) {
                // Not valid JSON ‚Äî must be a normal deck name
                const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                    method: "POST",
                    credentials: "include",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ deck_name: deckParam }),
                });

                const data = await response.json();
                if (!data.success) {
                    console.error("Error:", data.message);
                    return;
                }

                cardIds = data.card_ids;
            }

            // At this point, cardIds is valid
            initialDeckSize = cardIds.length;
            remainingDeck = shuffleDeck(cardIds).map(id => ({
                id,
                boardState: "Deck",
                lastBoardState: null
            }));

            console.log("Deck Shuffled:", remainingDeck);
            console.log("Total Cards in Deck:", initialDeckSize);
        }

        // Attach event listeners to update deck count dynamically
        if (playerDeckBox) {
            playerDeckBox.addEventListener("mouseenter", () => {
                playerDeckBox.innerText = `${remainingDeck.length}`;
            });

            playerDeckBox.addEventListener("mouseleave", () => {
                playerDeckBox.innerText = "Deck";
            });
        }

    document.addEventListener("DOMContentLoaded", () => {
        const tooltip = document.getElementById("tooltip");
        const tokenTooltip = document.getElementById("token-tooltip");

        const tabs = document.querySelectorAll(".tab-button");
        const contents = document.querySelectorAll(".tab-content");

        tabs.forEach(tab => {
            tab.addEventListener("click", () => {
                tabs.forEach(t => t.classList.remove("active"));
                contents.forEach(c => c.classList.remove("active"));

                tab.classList.add("active");
                document.getElementById(tab.dataset.tab).classList.add("active");
            });
        });

        // Game Log Data Population
        const params = new URLSearchParams(window.location.search);
        //document.getElementById("totem").textContent = params.get("totem");

        const dictionarySearch = document.getElementById("dictionary-search");
        const dictionaryResults = document.getElementById("dictionary-results");

        const loadAllTerms = () => {
            dictionaryResults.innerHTML = "";
            const allTerms = [...Object.entries(keywords), ...Object.entries(rules)];
            allTerms.sort((a, b) => a[0].localeCompare(b[0]));
            allTerms.forEach(([key, value]) => {
                const resultItem = document.createElement("p");
                resultItem.innerHTML = `<strong>${key}:</strong> ${value}`;
                dictionaryResults.appendChild(resultItem);
            });
        };
        loadAllTerms();

        dictionarySearch.addEventListener("input", () => {
            const query = dictionarySearch.value.toLowerCase();
            dictionaryResults.innerHTML = "";

            if (!query) {
                loadAllTerms();
                return;
            }

            const matchedKeywords = Object.entries(keywords).filter(([key]) =>
                key.toLowerCase().includes(query)
            );

            const matchedRules = Object.entries(rules).filter(([key]) =>
                key.toLowerCase().includes(query)
            );

            [...matchedKeywords, ...matchedRules].forEach(([key, value]) => {
                const resultItem = document.createElement("p");
                resultItem.innerHTML = `<strong>${key}:</strong> ${value}`;
                dictionaryResults.appendChild(resultItem);
            });
        });

        document.querySelectorAll(".keyword").forEach(keyword => {
            const description = keyword.dataset.description;

            if (description && description.trim() !== "") {
                keyword.addEventListener("mouseenter", (e) => {
                    tooltip.textContent = description;
                    tooltip.style.display = "block";
                    tokenTooltip.querySelector(".token-tooltip-text").textContent = description;
                    tokenTooltip.style.display = "block";
                });

                keyword.addEventListener("mouseleave", () => {
                    tooltip.style.display = "none";
                    tokenTooltip.style.display = "none";
                });

                keyword.addEventListener("mousemove", (e) => {
                    if (tooltip.style.display === "block") {
                        tooltip.style.left = `${e.pageX + 10}px`;
                        tooltip.style.top = `${e.pageY - 40}px`;
                    }
                    if (tokenTooltip.style.display === "block") { // ‚úÖ Fix: Remove `else if`
                        tokenTooltip.style.left = `${e.pageX + 10}px`;
                        tokenTooltip.style.top = `${e.pageY - 40}px`;
                    }
                });
            }
        });
    });
    initGameClient();
    </script>
</body>
</html>