<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
    <link rel="icon" href="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/favicon.png" type="image/png">
    <link rel="stylesheet" href="style.css">
    <title>ACTIVE GAME</title>
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <script>
        window.socket = io("https://geimon-app-833627ba44e0.herokuapp.com", {
            withCredentials: true
        });
    </script>
</head>
<style>
  #coin {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    transition: transform 0.1s;
}
  #drawn-cards {
    position: fixed;
    bottom: -180px; /* Positions the cards near the bottom */
    left: 775px;
    display: flex;
    flex-direction: row; /* Aligns cards in a horizontal row */
    align-items: center;
    z-index: 110020; /* Places it over (almost) everything */
    overflow: visible;
    pointer-events: none;
    max-height: 475px;
}
#drawn-cards > * {
  pointer-events: auto; /* re-enable interaction on individual cards */
}
.card {
    width: 240px; /* Reduces card size */
    height: 420px;
    position: relative; /* Ensures controlled placement */
    margin-left: -50%; /* Overlaps cards by 5% */
}
.viewing-window {
    position: fixed;
    left: 10px; /* Keeps it on the left */
    top: 270px;
    transform: translateY(-50%);
    width: 280px; /* Size for zoomed card */
    height: 440px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #1e1e1e;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110; /* Ensures it's on top */
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.context-window {
    position: fixed;
    left: 10px;
    top: 750px;
    transform: translateY(-50%);
    width: 280px;
    height: 440px;
    display: flex;
    flex-direction: column;
    background-color: #1e1e1e;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.player-life-window {
    position: fixed;
    left: 1900px;
    top: 600px;
    transform: translateY(-50%);
    width: 100px;
    height: 100px;
    display: flex;
    flex-direction: column;
    background-color: #2d1eff;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.opponent-life-window {
    position: fixed;
    left: 1900px;
    top: 320px;
    transform: translateY(-50%);
    width: 100px;
    height: 100px;
    display: flex;
    flex-direction: column;
    background-color: #970000;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.tabs {
    display: flex;
    justify-content: space-around;
    padding: 5px;
}
.tab-button {
    padding: 5px;
    cursor: pointer;
    background: #505050;
    color: white;
    border: none;
    border-radius: 5px;
}
.tab-button.active {
    background: #838383;
}
.tab-content-container {
    flex-grow: 1;
    padding: 10px;
    overflow-y: auto;
}
.tab-content {
    display: none;
    color: white;
}
.tab-content.active {
    display: block;
}
#viewing-window .scaled-card {
    pointer-events: auto !important;
    z-index: 100110; /* Ensures it's on top */
    width: 240px;
    height: 420px;
    margin-top: -12%;
}
#viewing-window .scaled-card .card-name {
    max-width: 100%;
}
#viewing-window .scaled-card .card-cost,
#viewing-window .scaled-card .card-text,
#viewing-window .scaled-card .card-name,
#viewing-window .scaled-card .card-condition,
#viewing-window .scaled-card .card-tags,
#viewing-window .scaled-card .bottom-bar,
#viewing-window .scaled-card .card-image {
    z-index: 100200 !important;
}
#viewing-window .scaled-card,
#viewing-window .scaled-card * {
  outline: none   !important;
  box-shadow: none !important;
  animation: none !important;
}
.tooltip {
    z-index: 110000 !important;
}
#tooltip {
    position: absolute;
    display: none;
    background-color: rgba(0, 0, 0, 1);
    color: white;
    padding: 5px;
    border-radius: 5px;
    font-size: 14px;
    max-width: 250px;
    z-index: 110000; /* Ensure it appears above other elements */
}
.token-tooltip {
    pointer-events: auto !important;
    z-index: 110000 !important;
}
#token-tooltip {
    z-index: 110000; /* Ensure it appears above other elements */
}
.keyword {
    pointer-events: auto !important;
    position: relative; /* Ensures proper hovering */
    z-index: 110000; /* Ensures tooltip appears above other elements */
}
.card-cost .keyword {
    position: relative;
    z-index: 110000 !important;
    pointer-events: auto !important;
}
.card-cost {
    pointer-events: auto !important;
    z-index: 100000 !important;
}
.card-text {
    pointer-events: auto !important;
    z-index: 100000 !important;
}
.scaled-card .card-button {
    display: none !important;
}
.life {
    color: white;
    text-align: center;
    font-weight: bold;
    font-size: 4em;
}
.player-name,
.opponent-name {
    color: white;
    font-size: 1.1em;
    text-align: center;
    font-weight: bold;
    overflow: hidden;          /* Hide overflowed content */
    text-overflow: ellipsis;   /* Show ... when text overflows */
    white-space: nowrap;       /* Prevent text from wrapping */
    max-width: 100%;           /* Optional: control how much space the text gets */
    display: inline-block;     /* Required for ellipsis to take effect */
}
#win-loss-banner {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0,0,0,0.8);
    padding: 40px 80px;
    border-radius: 16px;
    color: white;
    text-align: center;
    font-family: sans-serif;
    z-index: 120000;
    display: none;
}
#win-loss-banner .main {
    font-size: 3em;
    font-weight: bold;
    margin-bottom: 10px;
}
#win-loss-banner .reason {
    font-size: 1.5em;
}
#phase-tracker {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin: 10px auto;
  padding: 10px;
  position: fixed;
  top: 416px;
  left: 949px;
  transform: translateX(-50%);
  z-index: 100600;
  opacity: 0;
}
.phase-box {
  padding: 10px 14px;
  background: dimgray;
  color: white;
  border-radius: 6px;
  font-weight: bold;
  min-width: 90px;
  text-align: center;
  transition: background 0.3s;
}
.phase-box.active {
  background: lightgreen;
  text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;
}
#turn-counter {
  position: fixed;
  top: 442px;
  left: 1545px; /* adjust this to line up visually with the button */
  z-index: 100600;
  color: white;
  font-weight: bold;
  font-size: 1.5em;
  opacity: 0;
  text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;
}
#turn-indicator {
  position: fixed;
  top: 442px;
  left: 1355px;
  z-index: 100600;
  color: white;
  font-weight: bold;
  font-size: 1.5em;
  opacity: 0;
  text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;
}
.card-zone {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  gap: 0px;
  overflow: visible;
  z-index: 110000;
  position: relative;
}
.board-container {
  width: 1920px;
  height: 1080px;
  transform: scale(calc(100vw / 1920));
  transform-origin: top left;
}
@keyframes phaseWave {
  0% {
    left: 0px;
    opacity: 0.5;
  }
  50% {
    left: 250px;
    opacity: 0.8;
  }
  100% {
    left: 500px;
    opacity: 0;
  }
}
.phase-wave-effect {
  position: absolute;
  top: 0;
  left: 0px;
  width: 500px;
  height: 50px;
  background: linear-gradient(90deg, rgba(0,255,0,0.2) 0%, rgba(0,255,0,0.6) 50%, rgba(0,255,0,0.2) 100%);
  z-index: 5;
  pointer-events: none;
  animation: phaseWave 1s ease-out forwards;
  border-radius: 10px;
}
</style>
<body style="background-color:rgb(78, 78, 78);">
  <img src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/try_2.png" class="bg-image" alt="">
        <div id="coin-flip-container" style="display: none; text-align: center; margin-top: 50px;">
            <img id="coin" src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png" alt="coin" style="width: 150px; height: 150px;">
            <h2 id="flip-result" style="display: none;"></h2>
        </div>
        <div id="tooltip" class="tooltip"></div>
        <div id="token-tooltip" style="display: none; position: absolute;">
            <div class="token-tooltip-text" style="font-family: 'Times New Roman', serif; font-size: 14px;"></div>
        </div>
        <div id="drawn-cards" style="display: flex; flex-wrap: wrap; gap: 10px; padding: 10px;">
            <p id="drawn-message" style="color: white; font-size: 1.5em;"></p>
        </div>
        <div id="opponent-hand" style="display: flex; flex-wrap: nowrap; gap: 30px; padding: 10px; position: fixed; top: -235px; left: 765px; transform: none; z-index: 100350;"></div>
        <div id="opponentDeckBox"></div>
        <div class="viewing-window" id="viewing-window">
            <div class="scaled-card" id="scaled-card" style="transform: scale(0.797); transform-origin: center; pointer-events: none; margin-left: 14%;"></div>
        </div>
        <div class="context-window" id="context-window">
            <div class="tabs">
                <button class="tab-button" data-tab="chat">Chat</button>
                <button class="tab-button active" data-tab="game-log">Game Log</button>
                <button class="tab-button" data-tab="dictionary">Dictionary</button>
            </div>
            <div class="tab-content-container">
                <div class="tab-content" id="chat">
                    <p>This is a Solo Game, and we here at Geimon! do not believe that AI should be allowed to speak.</p>
                </div>
                <div class="tab-content active" id="game-log">
                    <p><span id="totem" style="color: goldenrod;"></span></p>
                    <div id="game-log-placeholder"></div>
                </div>
                <div class="tab-content" id="dictionary">
                    <input type="text" id="dictionary-search" placeholder="Search terms..." style="width: 95%;">
                    <div id="dictionary-results"></div>
                </div>
            </div>
        </div>
        <div id="player-profile-pic"></div>
        <div id="player-side">
            <div class="player-life-window" id="player-life-window">
                <div class="player-name" id="player-name"></div>
                <div class="life" id="player-life"></div>
                <div class="player-name" style="font-size: 80%;">Life</div>
            </div>
        </div>
        <div id="life-adjust-box" style="opacity: 0; transition: opacity 1s ease-in-out;">
            <div class="life-adjust-buttons">
                <button id="increase-life">Increase Life</button>
                <button id="decrease-life" class="active">Decrease Life</button>
            </div>
            <input id="life-amount" type="number" placeholder="Amount" />
            <button id="confirm-life-change">Confirm</button>
        </div>
        <div id="opponent-profile-pic"></div>
        <div id="opponent-zone-art" style="position: absolute; top: 0; left: 0; width: 100%; height: 50%; z-index: 0; overflow: hidden; pointer-events: none;"></div>
        <div id="opponent-side"style="pointer-events: none;">
            <div class="opponent-life-window" id="opponent-life-window">
                <div class="opponent-name" id="opponent-name"></div>
                <div class="life" id="opponent-life"></div>
                <div class="player-name" style="font-size: 80%;">Life</div>
            </div>
        </div>
        <div id="win-loss-banner">
            <div class="main" id="win-loss-main-text">You Lose</div>
            <div class="reason" id="win-loss-reason-text">Surrendered</div>
        </div>
        <div id="phase-tracker">
            <div class="phase-box" id="phase-Intermission">Intermission</div>
            <div class="phase-box" id="phase-Dummy"></div>
            <div class="phase-box" id="phase-Draw">Draw</div>
            <div class="phase-box" id="phase-Main 1">Main 1</div>
            <div class="phase-box" id="phase-Battle">Battle</div>
            <div class="phase-box" id="phase-Main 2">Main 2</div>
            <div class="phase-box" id="phase-End">End</div>
        </div>
        <div id="turn-indicator">Your Turn</div>
        <div id="turn-counter">Turn: 1</div>
        <div id="end-turn-button" style="
            display: none;
            position: fixed;
            top: 427.5px;
            left: 1350px;
            z-index: 100700;
            background-color: gold;
            color: black;
            font-size: 1.8em;
            font-weight: bold;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 2px 2px 6px black;
            text-shadow: 1px -1px 2px rgb(131, 122, 23), -1px 1px 2px rgb(131, 122, 23);
            ">
            End Turn
        </div>
        <div id="playerArsenalBox" class="card-zone"></div>
        <div id="playerChampionsBox" class="card-zone"></div>
        <div id="playerFaceDownBox" class="card-zone"></div>
        <div id="playerFaceDownArsenalBox" class="card-zone"></div>
        <div id="playerReserveBox" class="card-zone"></div>
        <div id="opponentArsenalBox" class="card-zone"></div>
        <div id="opponentChampionsBox" class="card-zone"></div>
        <div id="opponentFaceDownBox" class="card-zone"></div>
        <div id="opponentFaceDownArsenalBox" class="card-zone"></div>
        <div id="opponentReserveBox" class="card-zone"></div>
        <div id="path-response-modal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%);
            background:#222; color:white; padding:20px; border-radius:10px; z-index:200000; max-height:70vh; overflow:auto;">
            <h3>Respond to the Last Step?</h3>
            <div id="response-options" style="margin-top:10px; display:flex; flex-wrap:wrap; gap:10px;"></div>
            <button id="cancel-response" style="margin-top:10px;">Cancel</button>
        </div>
        <div id="tool-buttons" style="
            position: absolute;
            left: 1730px;
            top: 850px;
            z-index: 100500;
            display: flex;
            gap: 12px;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            ">
            <img id="token-btn" src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/token.png" style="width: 40px; cursor: pointer;" title="Create Token">
            <img id="dice-btn" src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/dice.png" style="width: 40px; cursor: pointer;" title="Roll 1d6">
            <img id="coin-btn" src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png" style="width: 40px; cursor: pointer;" title="Flip Coin">
        </div>

        <script type="module">
            import { cards } from "./data/cards.js";
            import { totems } from './data/totems.js';
            import { tokens } from "./data/tokens.js";
            import { renderCard } from "./utils/cardRenderer.js";
            import { addTooltipListeners, addTokenTooltipListeners } from "./utils/cardRenderer.js";
            import { keywords } from "./data/keywords.js";
            import { rules } from "./data/rules.js";

            const allCards = [...cards, ...tokens];

            if (!window.effectPath) {
                window.effectPath = [];
            }
            window.pathStepNumber = 1;

            let gameId = new URLSearchParams(window.location.search).get("gameId");
            if (gameId) {
                // Use the gameId from URL and update localStorage
                localStorage.setItem("gameId", gameId);
            } else {
                // Fallback: create a new one if not in URL or localStorage
                gameId = localStorage.getItem("gameId") || Math.random().toString(36).substr(2, 9);
                localStorage.setItem("gameId", gameId);
            }

            let username = null;
            let hasDrawnInitialHand = false;
            let hasRedrawn = false;
            let lastLoggedIntermissionTurn = null;

            let discardOngoing = false;
            let userSleeveURL = null;
            let discardSessionId = 0;
            let discardLock = false;
            let discardInstruction = null;

            let intervalId = null;
            let isFetchingGameState = false;
            let gameReady = false;

            let renderingHand = false;

            const params = new URLSearchParams(window.location.search);
            const gameType = params.get("gameType") || "single"; // "single" or "match"
            const isSinglePlayer = params.get("isSinglePlayer") === "true"; // true/false
            let gameNumber = 1; // You could increment this between games in Match mode
            const serverUrl = "https://geimon-app-833627ba44e0.herokuapp.com";

            //console.log("Gametype:", gameType, "SinglePlayer:", isSinglePlayer);

            const otherPlayerName = params.get("opponent") || "Unknown_Opponent"; // if multiplayer later

            let previousHandIds = [];
            let lastDrawTurn = null;
            let gameEnded = false;

            let opponentHandRevealed = false;

            let opponentName;

            function addGameLogEntry(message) {
                if (!username) {
                    console.warn("❌ addGameLogEntry called before username was set.");
                    return;
                }
                const gameLog = document.getElementById("game-log-placeholder");
                if (!gameLog) {
                    console.warn("No game log container found.");
                    return;
                }
                const time = new Date().toLocaleTimeString();
                const entry = document.createElement("div");
                entry.textContent = `[${time}] ${message}`;
                gameLog.appendChild(entry);
                gameLog.scrollTop = gameLog.scrollHeight;
            }

            function triggerPhaseWaveEffect() {
                const tracker = document.getElementById("phase-tracker");
                if (!tracker) return;

                const wave = document.createElement("div");
                wave.classList.add("phase-wave-effect");
                tracker.appendChild(wave);

                setTimeout(() => {
                    wave.remove();
                }, 1000); // match animation duration
            }

            function findCardByUidOrId(id) {
                const zones = [
                    ...(gameState[username]["Zone (Champion)"] || []),
                    ...(gameState[username]["FaceDownZone"] || []),
                ];
                return zones.find(c => String(c.id) === String(id) || String(c.id) === String(id));
            }

            function detachDrawBox() {
                const draw    = document.getElementById('phase-Draw');      // the Draw square
                const tracker = document.getElementById('phase-tracker');   // row of phase boxes
                if (!draw || !tracker || draw.dataset.detached) return;     // already done?

                    const gapPx   = parseFloat(getComputedStyle(tracker).gap) || 0;

                    /* remember Draw’s offset *inside* the tracker plus one-box shift */
                    draw.dataset.offsetX = draw.offsetLeft - draw.offsetWidth - gapPx;
                draw.dataset.offsetY = draw.offsetTop;    // px from tracker’s top edge

                /* 2. move it out of the tracker’s stacking context (z-index 100 600) */
                tracker.removeChild(draw);
                document.body.appendChild(draw);
                draw.dataset.detached = 'true';

                /* 3. give it root-level positioning & a higher stacking order */
                Object.assign(draw.style, {
                position: 'fixed',
                zIndex:   '100950',      // now above playerReserveBox (100 900)
                opacity: '0',
                transition: 'opacity 0.6s ease-in-out'
                });

                repositionDrawBox();      // place it once for the current size
                syncOpacityWithTracker();     // **immediately match the current opacity**
                observeTrackerOpacity();      // **start watching for future changes**
            }

            /** Put the box back over the tracker using stored offsets */
            function repositionDrawBox() {
                const draw    = document.getElementById('phase-Draw');
                const tracker = document.getElementById('phase-tracker');
                if (!draw || !tracker || !draw.dataset.detached) return;

                const rect = tracker.getBoundingClientRect();   // new screen coords
                const dx   = parseFloat(draw.dataset.offsetX);
                const dy   = parseFloat(draw.dataset.offsetY);

                draw.style.left = `${rect.left + dx}px`;
                draw.style.top  = `${rect.top  + dy}px`;
            }

            function syncOpacityWithTracker() {
                const draw    = document.getElementById('phase-Draw');
                const tracker = document.getElementById('phase-tracker');
                if (!draw || !tracker) return;
                draw.style.opacity = getComputedStyle(tracker).opacity;
            }


            function observeTrackerOpacity() {
                const tracker = document.getElementById('phase-tracker');
                if (!tracker) return;

                new MutationObserver(syncOpacityWithTracker)
                .observe(tracker, { attributes: true, attributeFilter: ['style'] });
            }

            window.addEventListener('DOMContentLoaded', detachDrawBox); // run once
            window.addEventListener('resize',      repositionDrawBox);  // realign on scale

        function handsAreEqual(currentHand) {
        return (
            currentHand.length === previousHandIds.length &&
            currentHand.every((card, index) => card.id === previousHandIds[index])
        );
        }

        function isMainPhase(phase) {
            return ["Main 1", "Main 2"].includes(gameState?.turn?.currentPhase);
        }

        function updateOpponentDeckCount() {
            const opponent = gameState[gameState.player1 === username ? gameState.player2 : gameState.player1];
            const opponentDeck = opponent?.Deck || [];
            const deckBox = document.getElementById("opponentDeckBox");

            if (deckBox) {
                deckBox.innerHTML = ""; // Clear old content

                const overlay = document.createElement("div");
                overlay.innerText = `${opponentDeck.length}`;
                overlay.style.color = "white";
                overlay.style.fontSize = "1em";
                overlay.style.textAlign = "center";
                overlay.style.textShadow = "2px 2px 4px black";
                deckBox.appendChild(overlay);
            }
        }

        async function updateLocalFromGameState() {

            function rehydrateZone(zone, cards) {
                return zone.map(card => {
                    const full = cards.find(c => String(c.id) === String(card.id));
                    if (!full) {
                    console.warn("⚠️ Failed to rehydrate card", card);
                    return card;
                    }
                    return {
                    ...full,
                    boardState: card.boardState,
                    lastBoardState: card.lastBoardState
                    };
                });
            }

            gameState[username].Hand = rehydrateZone(gameState[username].Hand, cards);
            gameState[username].Tomb = rehydrateZone(gameState[username].Tomb, cards);

            // ✅ Now get the hydrated player object
            const player = gameState[username];
            const currentHand = player.Hand;

            const prevLength = previousHandIds.length;
            const newLength = currentHand.length;

            //console.log("✅ Rehydrated Hand:", gameState[username].Hand);

            if (!handsAreEqual(currentHand)) {
                drawnCardsArray = currentHand;
                //console.log("✅ drawnCardsArray just before render:", drawnCardsArray);
                renderDrawnCards();

                if (!hasDrawnInitialHand && newLength >= 5) {
                    hasDrawnInitialHand = true;
                    previousHandIds = currentHand.map(card => card.id);
                    return;
                }

                if (hasDrawnInitialHand && newLength > prevLength) {
                    const prevIds = new Set(previousHandIds);
                    const newCards = currentHand.filter(c => !prevIds.has(c.id));

                    const drawnCards = newCards.filter(c =>
                        ["Deck", "Tomb", "Void", "Reserve"].includes(c.lastBoardState)
                    );

                    if (drawnCards.length > 0) {
                        animateCardDraw(false);
                    }
                }
                previousHandIds = currentHand.map(card => card.id);
            }
            opponentHandRevealed = gameState?.handsRevealed === true;

            remainingDeck = gameState[username].Deck;
            updateDeckText();

            // ✅ Add this:
            updateTurnDisplay(gameState.turn);
            updatePhaseDisplay(gameState.turn.currentPhase);
            renderLatestTombCard();
            renderLatestVoidCard();
            renderLatestOpponentTombCard();
            renderLatestOpponentVoidCard();
            //console.log("✅ drawnCardsArray just before render:", drawnCardsArray);
            renderDrawnCards();
            renderOpponentHand();
            updateOpponentDeckCount();

            if (gameState[username] && gameState[username].hasBasicRallied === undefined) {
                gameState[username].hasBasicRallied = false;
            }

            const zoneMappings = {
                "Zone (Champion)": "Champions",
                "Zone (Arsenal)": "Arsenal",
                "Reserve": "Reserve",
                "FaceDownZone": "FaceDown",
                "FaceDownArsenalZone": "FaceDownArsenal"
            };

            const opponent = gameState[ gameState.player1 === username ? gameState.player2 : gameState.player1 ];
            for (const [zoneKey, domSuffix] of Object.entries(zoneMappings)) {
                await renderCardZone( opponent[zoneKey], `opponent${domSuffix}Box` );
            }
        }

        async function getUsername() {
            const res = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/me', { credentials: 'include' });
            const data = await res.json();
            if (data.loggedIn) {
                username = data.username;
            }
        }

        async function initGameClient() {
            await getUsername();
            if (!username) {
                alert("Could not retrieve username.");
                return; // ✅ This is now valid
            }
        }

        async function drawCards(deck, numCards = 5, { log = true } = {}) {
            //console.log("🔍 drawCards() called, drawing", numCards, "card(s). Current deck:", deck.length);

            const drawnCards = deck.splice(0, numCards);
            drawnCards.forEach(card => {
                card.lastBoardState = card.boardState;
                card.boardState = "Hand";
            });
            gameState[username].Hand.push(...drawnCards);

            await sendZoneUpdate(["Deck", "Hand"]);
            renderDrawnCards();
            updateDeckText();

            if (log) {
                addGameLogEntry(
                `${username} drew ${numCards} card${numCards > 1 ? "s" : ""}.`
                );
            }

            return drawnCards;
        }

        async function showRedrawPrompt() {
            return new Promise((resolve) => {
                const overlay = document.createElement("div");
                overlay.style.position = "fixed";
                overlay.style.top = "50%";
                overlay.style.left = "50%";
                overlay.style.transform = "translate(-50%, -50%)";
                overlay.style.width = "450px";
                overlay.style.padding = "30px 20px";
                overlay.style.backgroundColor = "rgba(0, 0, 0)";
                overlay.style.zIndex = 200000;
                overlay.style.display = "flex";
                overlay.style.flexDirection = "column";
                overlay.style.justifyContent = "center";
                overlay.style.alignItems = "center";
                overlay.style.borderRadius = "12px";
                overlay.style.boxShadow = "0 0 20px black";
                overlay.style.opacity = "0";
                overlay.style.transition = "opacity 1s ease-in-out";

                setTimeout(() => {
                    overlay.style.opacity = "0.8";
                }, 1000);

                const prompt = document.createElement("div");
                prompt.innerHTML = "<h2 style='color:white'>Would you like to redraw your opening hand?</h2>";
                prompt.style.marginBottom = "20px";

                const yesBtn = document.createElement("button");
                yesBtn.textContent = "Yes";
                yesBtn.style.marginRight = "10px";
                yesBtn.onclick = async () => {
                    if (!hasRedrawn) {
                        hasRedrawn = true;
                        const player = gameState[username];

                        // 1️⃣ Move original hand to bottom and sync that first
                        const oldHand = player.Hand.splice(0);
                        gameState[username].Deck.push(...oldHand);
                        addGameLogEntry(`${username} elected to redraw their Starting Hand.`);
                        await sendZoneUpdate(["Deck", "Hand"]);

                        // 2️⃣ Draw five new cards, one at a time
                        for (let i = 0; i < oldHand.length; i++) {
                            await drawCards(gameState[username].Deck, 1, { log: false });
                            await sendZoneUpdate(["Deck", "Hand"]);
                        }

                        // 3️⃣ Refresh your UI from the now-correct server state
                        await updateLocalFromGameState();
                    }

                    document.body.removeChild(overlay);
                    resolve();
                };

                const noBtn = document.createElement("button");
                noBtn.textContent = "No";
                noBtn.onclick = () => {
                document.body.removeChild(overlay);
                addGameLogEntry(`${username} elected not to redraw their Starting Hand.`);
                resolve();
                };

                const btnContainer = document.createElement("div");
                btnContainer.appendChild(yesBtn);
                btnContainer.appendChild(noBtn);
                overlay.appendChild(prompt);
                overlay.appendChild(btnContainer);

                document.body.appendChild(overlay);


            });
        }

        window.onload = () => {
            (async () => {
                await initGameClient();
                window.socket.emit("join_game_room", { gameId });
                //console.log("Joined game room", gameId);

                window.socket.on("game_log", ({ username, message }) => {
                    //console.log("Username:", username);
                    if (username === "Bot") {
                        addGameLogEntry(message);
                        //console.log("Bot log received:", message);
                    }
                });

                socket.on('card_targeted', ({ cardId }) => flashTargetRing(cardId));

                socket.on("phase_change", ({ phase, username: actingUser }) => {
                    // Update which phase is marked as active
                    updatePhaseDisplay(phase);

                    // Trigger green wave animation for both player and bot
                    triggerPhaseWaveEffect();
                });

                socket.on("opponent_draw_card", ({ player, count }) => {
                    if (!username || player === username) return; // ignore self
                    for (let i = 0; i < count; i++) {
                        animateCardDraw(true); // animate for opponent
                    }
                });
                socket.on("opponent_discard_card", ({ player, count }) => {
                    if (!username || player === username) return;
                    for (let i = 0; i < count; i++) {
                        animateCardDiscard("opponent-hand", "opponentTombBox", true);
                    }
                });


                socket.on("game_over", ({ winner, loser, reason }) => {
                    const mainText = (winner === username) ? "You Win" : "You Lose";
                    showBanner(mainText, reason);
                });

                if (!username) {
                    console.warn("Username not set after init.");
                    return;
                }

            const params = new URLSearchParams(window.location.search);
            const turnOrder = params.get("turnOrder");

            if (turnOrder === "coinflip") {
                const container = document.getElementById("coin-flip-container");
                const coin = document.getElementById("coin");
                const resultText = document.getElementById("flip-result");
                container.style.display = "block";
                resultText.textContent = "";

                // Image paths
                const headsImg = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png";
                const tailsImg = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/tails.png";

                let positionY = window.innerHeight / 2;
                let velocity = -25;
                let gravity = 1;
                let flips = 0;

                function animateFlip() {
                    coin.src = Math.random() > 0.5 ? headsImg : tailsImg;

                    positionY += velocity;
                    velocity += gravity;

                    coin.style.top = `${positionY}px`;

                    if (velocity > 0 && positionY >= window.innerHeight / 2) {
                        clearInterval(interval);

                        const finalResult = Math.random() > 0.5 ? "Heads" : "Tails";
                        coin.src = finalResult === "Heads" ? headsImg : tailsImg;

                        if (finalResult === "Tails") {
                            resultText.textContent = "You are going second.";
                            resultText.style.display = "block";
                            resultText.style.fontSize = "2em";
                            resultText.style.marginTop = "10%";
                            resultText.style.textShadow ="2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black";
                            setTimeout(() => transitionToNextScreen("second"), 2000);
                        } else {
                            resultText.textContent = "You won the coin flip! Choose:";
                            resultText.style.display = "block";
                            resultText.style.fontSize = "2em";
                            resultText.style.marginTop = "10%";
                            resultText.style.textShadow = "2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black";

                            const buttonContainer = document.createElement("div");
                            buttonContainer.style.marginTop = "20px";

                            const goFirstButton = document.createElement("button");
                            goFirstButton.textContent = "Go First";
                            goFirstButton.style.marginRight = "10px";
                            goFirstButton.className = "button button";
                            goFirstButton.style.zIndex = "150000";
                            goFirstButton.onclick = () => {
                                goFirstButton.style.zIndex = "1";
                                goFirstButton.style.opacity = "0";
                                clearTimeout(autoSelectTimer); // Cancel timer if selected manually
                                transitionToNextScreen("first");
                            };

                            const goSecondButton = document.createElement("button");
                            goSecondButton.textContent = "Go Second";
                            goSecondButton.className = "button button";
                            goSecondButton.style.zIndex = "150000";
                            goSecondButton.onclick = () => {
                                goSecondButton.style.zIndex = "1";
                                goSecondButton.style.opacity = "0";
                                clearTimeout(autoSelectTimer); // Cancel timer if selected manually
                                transitionToNextScreen("second");
                            };

                            buttonContainer.appendChild(goFirstButton);
                            buttonContainer.appendChild(goSecondButton);
                            container.appendChild(buttonContainer);

                            // Start 3-second timer for automatic selection
                            const autoSelectTimer = setTimeout(() => {
                                goFirstButton.style.opacity = "0";
                                goSecondButton.style.opacity = "0";
                                goFirstButton.style.zIndex = "1";
                                goSecondButton.style.zIndex = "1";
                                const randomChoice = Math.random() < 0.5 ? "first" : "second"; // 50/50 chance
                                console.log(`Time expired! Automatically choosing: ${randomChoice}`);
                                transitionToNextScreen(randomChoice);
                            }, 3000); // 3 seconds
                        }

                    }
                }
                const interval = setInterval(animateFlip, 50);
            }
            else if (turnOrder === "first" || turnOrder === "second") {
                // Directly proceed to game setup
                transitionToNextScreen(turnOrder);
            }
            else {
                document.body.innerHTML = `
                    <h1>Game Configuration</h1>
                    <p>Player Deck: ${params.get("playerDeck")}</p>
                    <p>Opponent Deck: ${params.get("opponentDeck")}</p>
                    <p>Game Type: ${params.get("gameType")}</p>
                    <p>Totem: ${params.get("totem")}</p>
                    <p>Turn Order: ${turnOrder}</p>
                `;
            }
        })();
    };

        async function fetchLatestTurnState() {
            console.log("🔍 fetchLatestTurnState ▶ GET /getGameState/" + gameId);
            const res = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`, {
                credentials: "include"
            });
            if (!res.ok) {
                console.warn("❌ fetchLatestTurnState failed:", res.status);
                return null;
            }
            const state = await res.json();
            console.log("📥 fetchLatestTurnState ◀ state:", state);
            return state;
        }

        async function waitForGameState(retries = 10, delayMs = 500) {
            for (let i = 0; i < retries; i++) {
                const res = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`, {
                credentials: "include"
                });

                if (res.ok) {
                const gameState = await res.json();
                if (gameState && gameState.turn) return gameState;
                }

                console.warn(`Retry ${i + 1} of ${retries}... waiting for game state...`);
                await new Promise(resolve => setTimeout(resolve, delayMs));
            }

            throw new Error("Game state failed to initialize in time.");
        }

        async function fetchGameStateFromServer() {
            try {
                const response = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`, {
                    credentials: "include"
                });

                if (!response.ok) {
                console.warn("⚠️ Failed to fetch game state:", response.status);
                return; // Don't continue if response is bad
                }

                const newGameState = await response.json();
                if (!newGameState || !newGameState.turn) {
                    console.warn("⚠️ Game state or turn missing from server");
                    return;
                }

                gameState = newGameState;
                const currentTurn = gameState.turn.count;

                updateLocalFromGameState();
                const playerState = gameState[username];
            } catch (err) {
                console.error("💥 Error fetching game state:", err);
            }
        }
        window.fetchGameStateFromServer = fetchGameStateFromServer;
        window.toggleOpponentReveal = () => {
            opponentHandRevealed = !opponentHandRevealed;
            renderOpponentHand();
        };

        function showBanner(mainText, reasonText) {
            const banner = document.getElementById("win-loss-banner");
            document.getElementById("win-loss-main-text").textContent = mainText;
            document.getElementById("win-loss-reason-text").textContent = reasonText;
            banner.style.display = "block";

            // ✅ Add game log entry
            const result = `${mainText.toUpperCase()}`;
            addGameLogEntry(`Game Ended: ${result} – ${reasonText}`);

            // ✅ Block all game interactions
            const blocker = document.createElement("div");
            blocker.id = "game-interaction-blocker";
            Object.assign(blocker.style, {
                position: "fixed",
                top: 0,
                left: 0,
                width: "100vw",
                height: "100vh",
                backgroundColor: "rgba(0, 0, 0, 0.1)",
                zIndex: 130000,
                pointerEvents: "all"
            });
            document.body.appendChild(blocker);

            if (gameType === "match") {
                setTimeout(() => {
                    prepareTotemSelectionForNextGame(); // Remove winner check
                }, 3000);
            }
        }

        function prepareTotemSelectionForNextGame() {
            const allTotems = Object.assign({}, ...totems); // Assuming `totems` is an array of objects
            const usedTotem = params.get("totem");
            const unusedTotems = Object.keys(allTotems).filter(name => name !== usedTotem);
            const randomChoices = unusedTotems.sort(() => 0.5 - Math.random()).slice(0, 3);

            const overlay = document.createElement("div");
            Object.assign(overlay.style, {
                position: "fixed",
                top: "50%",
                left: "50%",
                transform: "translate(-50%, -50%)",
                padding: "30px",
                backgroundColor: "#333",
                color: "white",
                border: "2px solid white",
                borderRadius: "10px",
                zIndex: 130001,
                textAlign: "center",
                boxShadow: "0 0 10px black"
            });

            overlay.innerHTML = `<p style="font-size: 1.2em;">You lost the last game.<br><strong>First, choose who goes first:</strong></p>`;

            const goFirstBtn = document.createElement("button");
            goFirstBtn.textContent = "Go First";
            goFirstBtn.style.margin = "10px";
            goFirstBtn.onclick = () => showTotemOptions("first");

            const goSecondBtn = document.createElement("button");
            goSecondBtn.textContent = "Go Second";
            goSecondBtn.style.margin = "10px";
            goSecondBtn.onclick = () => showTotemOptions("second");

            overlay.appendChild(goFirstBtn);
            overlay.appendChild(goSecondBtn);

            function showTotemOptions(turnOrder) {
                overlay.innerHTML = `<p style="font-size: 1.2em;">Now choose a Totem for Game ${gameNumber + 1}:</p>`;

                randomChoices.forEach(totem => {
                    const button = document.createElement("button");
                    button.textContent = totem;
                    button.style.margin = "10px";
                    button.onclick = async () => {
                        const newGameId = Math.random().toString(36).substr(2, 9);
                        const settings = {
                            gameId: newGameId,
                            playerDeck: params.get("playerDeck"),
                            opponentDeck: params.get("opponentDeck"),
                            gameType: "match",
                            totem,
                            totemText: allTotems[totem],
                            turnOrder,
                            isSinglePlayer: params.get("isSinglePlayer") === "true",
                            playerUsername: username,
                            opponentUsername: "Bot",
                            goesFirst: turnOrder
                        };

                        await fetch("https://geimon-app-833627ba44e0.herokuapp.com/startGame", {
                            method: "POST",
                            credentials: "include",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(settings)
                        });

                        const urlParams = new URLSearchParams(settings).toString();
                        window.location.href = `game.html?${urlParams}`;
                    };
                    overlay.appendChild(button);
                });
            }

            document.body.appendChild(overlay);
        }

        function updateTurnDisplay(turnData) {
        if (turnData && turnData.count) {
            document.getElementById("turn-counter").textContent = `Turn: ${turnData.count}`;

            const indicator = document.getElementById("turn-indicator");
            if (turnData.currentPlayer === username) {
                indicator.textContent = "Your Turn";
            } else {
                indicator.textContent = "Opponent's Turn";
            }
                indicator.style.opacity = "1";

            const colorBox = document.getElementById("turn-color-box");
            if (colorBox) {
                if (turnData.currentPlayer === username) {
                    colorBox.style.backgroundColor = "blue";
                } else {
                    colorBox.style.backgroundColor = "red";
                }
            }
        }
        }
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        document.querySelectorAll(".phase-box").forEach(box => {
            box.style.cursor = "pointer";
            box.addEventListener("click", async () => {
                const phase = box.textContent.trim();
                const turnCount = gameState.turn.count;
                const currentPhase = gameState.turn.currentPhase;
                const player = gameState.turn.currentPlayer;

                if (player !== username) return;

                // Turn 1: restrict Battle and Main 2
                if (turnCount === 1 && (phase === "Battle" || phase === "Main 2")) return;

                // Enforce phase flow:
                const allowedTransitions = {
                    "Intermission": ["Draw"],
                    "Draw": ["Main 1"],
                    "Main 1": ["Battle", "End"],
                    "Battle": ["Main 2"],
                    "Main 2": ["End"]
                };

                const validNextPhases = allowedTransitions[currentPhase] || [];
                if (!validNextPhases.includes(phase)) {
                    // Special case: allow re-entering End to complete post-discard retry
                    if (!(currentPhase === "End" && phase === "End")) {
                        console.error("❌ Invalid phase transition from", currentPhase, "to", phase);
                        return;
                    }
                }

                if (phase === "End" && gameState.turn.currentPlayer === username) {
                    updatePhaseDisplay(phase);
                    triggerPhaseWaveEffect();
                    showEndTurnButton();

                    const selectedTotem = params.get("totem");
                    const player1 = gameState.player1;
                    const player2 = gameState.player2;

                    const phaseBefore = gameState.turn.currentPhase;
                    const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/setPhase", {
                        method: "POST",
                        credentials: "include",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ gameId, username, phase })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        updatePhaseDisplay(data.currentPhase);
                        triggerPhaseWaveEffect();

                        if (!(data.currentPhase === "End" && phaseBefore === "End")) {
                            if (data.currentPhase !== phaseBefore) {
                                addGameLogEntry(`${username} changed phase to ${data.currentPhase}`);
                            }
                        }

                        await updateLocalFromGameState();

                        if (data.draw) {
                            alert("The game ended in a draw.");
                        } else if (data.loser) {
                            showBanner(data.loser === username ? "You Lose" : "You Win", data.reason);
                        }
                    } else {
                        console.error("Failed to change phase:", await response.text());
                    }

                    return;
                }

                // 🧠 For all other valid phases
                const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/setPhase", {
                    method: "POST",
                    credentials: "include",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ gameId, username, phase })
                });

                if (response.ok) {
                    const data = await response.json();

                    updatePhaseDisplay(data.currentPhase);
                    triggerPhaseWaveEffect();
                    const phaseBefore = gameState.turn.currentPhase;
                    await updateLocalFromGameState();
                    if (data.currentPhase !== phaseBefore) {
                        addGameLogEntry(`${username} changed phase to ${data.currentPhase}`);
                    }

                    // ✅ Game end conditions
                    if (data.draw) {
                        alert("The game ended in a draw.");
                    } else if (data.loser) {
                        if (data.loser === username) {
                            showBanner("You Lose", data.reason);
                        } else {
                            showBanner("You Win", data.reason);
                        }
                    }
                } else {
                    console.error("Failed to change phase:", await response.text());
                }
            });
        });

        // COIN FLIP
        document.getElementById("coin-btn").onclick = () => {
        const result = Math.random() < 0.5 ? "Heads" : "Tails";
        addGameLogEntry(`${username} flipped a coin: ${result}`);
        };

        // DICE ROLL
        document.getElementById("dice-btn").onclick = () => {
        const roll = Math.floor(Math.random() * 6) + 1;
        addGameLogEntry(`${username} rolled a d6: ${roll}`);
        };

        // TOKEN CREATION
        document.getElementById("token-btn").onclick = () => {
            const popup = document.createElement("div");
            Object.assign(popup.style, {
                position: "fixed",
                top: "50%",
                left: "50%",
                transform: "translate(-50%, -50%)",
                background: "#222",
                color: "white",
                padding: "20px",
                borderRadius: "10px",
                zIndex: 200000,
                textAlign: "center"
            });

            popup.innerHTML = `
                <label style="display:block; margin-bottom:5px;">Select Token Type:</label>
                <select id="token-select" style="width: 200px; margin-bottom: 10px;">
                    ${tokens
                        .slice()
                        .sort((a, b) => a.name.localeCompare(b.name))
                        .map(t => `<option value="${t.id}">${t.name}</option>`)
                        .join("")}
                </select>
                <br>
                <label>Quantity: <input id="token-qty" type="number" value="1" min="1" style="width: 60px;"></label>
                <br><br>
                <button id="confirm-token" style="margin-right:10px;">Confirm</button>
                <button id="cancel-token">Cancel</button>
            `;

            document.body.appendChild(popup);
            document.getElementById("cancel-token").onclick = () => popup.remove();

            document.getElementById("confirm-token").onclick = async () => {
                const tokenId = document.getElementById("token-select").value;
                const quantity = parseInt(document.getElementById("token-qty").value);
                const tokenCard = tokens.find(t => String(t.id) === String(tokenId));
                if (!tokenCard || isNaN(quantity) || quantity <= 0) return;

                const zoneKey = "Zone (Champion)";
                const renderTargetId = "playerChampionsBox";

                if (!gameState[username][zoneKey]) {
                    gameState[username][zoneKey] = [];
                }

                for (let i = 0; i < quantity; i++) {
                    const tokenCopy = {
                        ...tokenCard,
                        id: `${tokenCard.id}`, // 👈 predictable and parseable
                        boardState: "Zone (Champion)",
                        lastBoardState: "TokenCreate",
                        type: "Champion"
                    };
                    gameState[username]["Zone (Champion)"].push(tokenCopy);
                }

                await sendZoneUpdate(["Zone (Champion)"]);
                renderCardZone(gameState[username][zoneKey], renderTargetId);
                addGameLogEntry(`${username} created ${quantity} ${tokenCard.name} token${quantity > 1 ? "s" : ""} on their side.`);
                popup.remove();
            };
        };

        function animateDeckShuffle(isOpponent = false) {
            // Determine which deck box to animate
            const deckBox = isOpponent ? opponentDeckBox : playerDeckBox;
            // Add the shuffle-animation class to trigger the CSS keyframes
            deckBox.classList.add('shuffle-animation');
            // Remove the class once the animation completes
            deckBox.addEventListener('animationend', () => {
                deckBox.classList.remove('shuffle-animation');
            }, { once: true });
        }

        function animateCardDraw(isOpponent = false) {
            const cardImg = document.createElement("img");
            const sleeveUrl = isOpponent
                ? opponentDeckBox?.style.backgroundImage?.slice(5, -2)
                : userSleeveURL;

            cardImg.src = sleeveUrl || "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site%20Assets/DefaultSleeve.png";
                cardImg.style.position = "fixed";
                cardImg.style.width = "173px";
                cardImg.style.height = "267px";
                cardImg.style.zIndex = "99999";
                cardImg.style.transition = "all 0.5s ease-in-out";
                cardImg.style.transform = "scale(0.8)";
                cardImg.style.outline = "2px solid white";

            // Determine start and end locations
            const startBox = isOpponent ? opponentDeckBox : playerDeckBox;
            const endBox = isOpponent ? document.getElementById("opponent-hand") : document.getElementById("drawn-cards");

            const startRect = startBox.getBoundingClientRect();
            const endRect = endBox.getBoundingClientRect();

            cardImg.style.left = `${startRect.left + startRect.width / 2 - 60}px`;
            cardImg.style.top = `${startRect.top + startRect.height / 2 - 105}px`;

            document.body.appendChild(cardImg);

            requestAnimationFrame(() => {
                if(!isOpponent) {
                    cardImg.style.left = `${endRect.left + endRect.width / 2 - 900}px`;
                    cardImg.style.top = `${endRect.top + endRect.height / 2 - 60}px`;
                } else {
                    cardImg.style.left = `${endRect.left + endRect.width / 2 - 0}px`;
                    cardImg.style.top = `${endRect.top + endRect.height / 2 - 120}px`;
                }
                cardImg.style.opacity = "0";
                cardImg.style.transform = "scale(0.5)";
            });

            setTimeout(() => cardImg.remove(), 1000);
        }

        function showEndTurnButton() {
            const button = document.getElementById("end-turn-button");
            button.style.display = "block";
            button.onclick = async () => {
                const res = await fetch(`${serverUrl}/endTurn`, {
                method: "POST",
                credentials: "include",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ gameId, username })
                });

                if (res.ok) {
                const data = await res.json();
                button.style.display = "none";
                await fetchGameStateFromServer();
                } else {
                alert("Failed to end turn.");
                }
            };
        }

        function animateCardDiscard(fromHandBoxId, toTombBoxId, isOpponent = false) {
            const handBox = document.getElementById(fromHandBoxId);
            const tombBox = document.getElementById(toTombBoxId);

            if (!handBox || !tombBox) return;

            const startRect = handBox.getBoundingClientRect();
            const endRect = tombBox.getBoundingClientRect();

            const sleeveUrl = isOpponent
                ? opponentDeckBox?.style.backgroundImage?.slice(5, -2)
                : userSleeveURL;

            const cardImg = document.createElement("img");
            cardImg.src = sleeveUrl || "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site%20Assets/DefaultSleeve.png";
                cardImg.style.position = "fixed";
                cardImg.style.width = "260px";
                cardImg.style.height = "400px";
                cardImg.style.left = `${startRect.left + startRect.width / 2 - 500}px`;
                cardImg.style.top = `${startRect.top + startRect.height / 2 - 35}px`;
                cardImg.style.transition = "all 0.5s ease-in-out";
                cardImg.style.zIndex = 99999;
                cardImg.style.opacity = "1";
                cardImg.style.outline = "2px solid white";

            document.body.appendChild(cardImg);

            requestAnimationFrame(() => {
                cardImg.style.left = `${endRect.left + endRect.width / 2 - 60}px`;
                cardImg.style.top = `${endRect.top + endRect.height / 2 - 220}px`;
                cardImg.style.opacity = "0.05";
                cardImg.style.transform = "scale(0.3)";
            });

            setTimeout(() => cardImg.remove(), 1000);
        }

        async function fetchOpponentData(opName) {
            try {
                const res = await fetch(`${serverUrl}/user-cosmetics/${opName}`, { credentials:'include' });
                if (!res.ok) throw new Error('bad response');
                return await res.json();     // { profilePic, deckSleeve, zoneArt }
            } catch (err) {
                console.warn('Failed to get opponent cosmetics:', err);
                return null;
            }
        }

        // 🔴 show the red ring for N ms (default 5000)
        const targetTimers = {};                 // cardId ➜ timeout handle

        function flashTargetRing(cardId, duration = 2500){
        // 1️⃣  add / refresh the visual
        document.querySelectorAll(`[data-card-id="${cardId}"]`)
                .forEach(el => el.classList.add('target-highlight'));

        // 2️⃣  clear any existing timer for this card
        clearTimeout(targetTimers[cardId]);

        // 3️⃣  schedule automatic removal
        targetTimers[cardId] = setTimeout(() => {
            document.querySelectorAll(`[data-card-id="${cardId}"]`)
                    .forEach(el => el.classList.remove('target-highlight'));
            delete targetTimers[cardId];
        }, duration);
        }

        function wrapCardButton(btn){
            if (btn.dataset.targetWrapperAttached) return; // already done
            btn.dataset.targetWrapperAttached = "true";

            const original = btn._originalHandler || btn.onclick;   // keep whatever was there
            btn._originalHandler = original;                       // (defensive)

            btn.onclick = function(e){
            if (typeof original === "function") original.call(this, e); // old behaviour first

            const cardId = this.closest(".card")?.dataset.cardId;
            if (!cardId) return;

            flashTargetRing(cardId);               // instant local feedback
            socket.emit("toggle_target", { gameId, cardId }); // sync to server
            };
        }

        document.querySelectorAll(".card-button").forEach(wrapCardButton);

        const observer = new MutationObserver(muts => {
            muts.forEach(m => {
            m.addedNodes.forEach(node => {
                if (node.nodeType !== 1) return;
                if (node.classList.contains("card-button")) {
                wrapCardButton(node);
                } else {
                node.querySelectorAll?.(".card-button").forEach(wrapCardButton);
                }
            });
            });
        });
        observer.observe(document.body, { childList: true, subtree: true });

        function renderOpponentHand() {
            const container = document.getElementById("opponent-hand");
            if (!container || !gameState) return;

            const opponent = gameState[gameState.player1 === username ? gameState.player2 : gameState.player1];
            let opponentHand = opponent?.Hand || [];

            // Sort hand by type priority
            const typePriority = {
                "Champion": 6,
                "Action": 5,
                "Equipment": 4,
                "Obelisk": 3,
                "Rush": 2,
                "Reflex": 1
            };
            opponentHand = opponentHand.slice().sort((a, b) => {
                const fullA = cards.find(c => String(c.id) === String(a.id));
                const fullB = cards.find(c => String(c.id) === String(b.id));

                const typeA = typePriority[fullA?.type] || 99;
                const typeB = typePriority[fullB?.type] || 99;

                if (typeA !== typeB) {
                    return typeA - typeB;
                }

                // Reverse alphabetical comparison within type
                const nameA = fullA?.name?.toLowerCase() || "";
                const nameB = fullB?.name?.toLowerCase() || "";
                return nameB.localeCompare(nameA);
            });

            container.innerHTML = "";
            container.style.overflowX = "visible";
            container.style.flexWrap = "nowrap";

            opponentHand.forEach(cardData => {
                const cardEl = document.createElement("div");
                cardEl.classList.add("card");
                cardEl.style.width = "260px";
                cardEl.style.height = "400px";
                cardEl.style.transform = "scale(0.48)";
                cardEl.style.marginLeft = "-200px";
                cardEl.style.top = "10px";
                cardEl.style.position = "relative";
                cardEl.style.overflow = "visible";
                cardEl.style.boxSizing = "border-box";
                cardEl.style.border = "none";
                cardEl.style.outline = "none";
                cardEl.style.boxShadow = "0 30px 40px rgba(0, 0, 0, 0.5)";

                if (opponentHandRevealed) {
                    const fullCard = cards.find(c => String(c.id) === String(cardData.id));
                    if (fullCard) {
                        const renderedCard = renderCard(fullCard);
                        renderedCard.style.transformOrigin = "center center";
                        renderedCard.style.transform = "rotate(180deg)";
                        renderedCard.style.marginLeft = "25px";
                        renderedCard.style.marginTop = "100px";
                        cardEl.appendChild(renderedCard);

                        addTooltipListeners(cardEl);
                        addTokenTooltipListeners(cardEl);
                    }
                } else {
                    const sleeveUrl = opponentDeckBox?.style.backgroundImage?.slice(5, -2) || "";
                    const sleeveImg = document.createElement("img");
                    sleeveImg.src = sleeveUrl;
                    sleeveImg.style.display = "block";
                    sleeveImg.style.width = "100%";
                    sleeveImg.style.height = "100%";
                    sleeveImg.style.objectFit = "cover";
                    sleeveImg.style.border = "4px solid white";
                    sleeveImg.style.outline = "none";
                    sleeveImg.style.boxShadow = "none";
                    sleeveImg.style.transform = "rotate(180deg)";
                    cardEl.appendChild(sleeveImg);

                    cardEl.onmouseenter = null;
                    cardEl.onmousemove = null;
                    cardEl.onmouseleave = null;
                }

                /* 🔴 1 – tag the DIV with its real ID so toggleTargetRing/flashTargetRing can find it */
                cardEl.dataset.cardId = String(cardData.id);

                /* 🔴 2 – drop an invisible click-catching overlay identical to your own-hand cards */
                const btn = document.createElement("button");
                btn.className = "card-button";
                Object.assign(btn.style, {
                position: "absolute",
                top:      "0",
                left:     "0",
                width:    "100%",
                height:   "100%",
                border:   "none",
                background:"transparent",
                opacity:  "0",
                cursor:   "pointer",
                pointerEvents: "auto",
                zIndex:   100100
                });
                cardEl.appendChild(btn);

                /* 🔴 3 – (optionally) wrap it right away so the ring appears instantly;  
                        otherwise the existing MutationObserver will pick it up next tick. */
                if (typeof wrapCardButton === "function") wrapCardButton(btn);

                container.appendChild(cardEl);
            });
        }

        function renderLatestTombCard() {
            const tombCards = gameState?.[username]?.Tomb || [];
            const tombTop = tombCards[tombCards.length - 1];
            playerTombBox.innerHTML = ""; // Always clear

            // Tomb hover label (always "Tomb")
            const tombTextOverlay = document.createElement("div");
            tombTextOverlay.innerText = "Tomb";
            Object.assign(tombTextOverlay.style, {
                position: "absolute",
                zIndex: "110000",
                left: "45%",
                top: "3%",
                transform: "translate(-50%, -50%)",
                fontSize: "1em",
                color: "white",
                textShadow: `
                    -2px -2px 4px black,  
                    2px -2px 4px black,  
                    -2px  2px 4px black,  
                    2px  2px 4px black`
            });
            playerTombBox.appendChild(tombTextOverlay);

            playerTombBox.onmouseenter = () => {
                tombTextOverlay.innerText = `${tombCards.length}`;
            };
            playerTombBox.onmouseleave = () => {
                tombTextOverlay.innerText = "Tomb";
            };

            if (!tombTop) return;

            const card = cards.find(c => String(c.id) === String(tombTop.id));
            if (!card) return;

            const miniCard = renderCard(card);
            Object.assign(miniCard.style, {
                transform: "scale(0.3)",
                transformOrigin: "top left",
                marginTop: "-8%",
                marginLeft: "0%",
                pointerEvents: "none"
            });

            playerTombBox.appendChild(miniCard);
        }

        function renderLatestVoidCard() {
            const voidCards = gameState?.[username]?.Void || [];
            const voidTop = voidCards[voidCards.length - 1];
            playerVoidBox.innerHTML = ""; // Always clear

            // Void hover label (always "Void")
            const voidTextOverlay = document.createElement("div");
            voidTextOverlay.innerText = "Void";
            Object.assign(voidTextOverlay.style, {
                position: "absolute",
                zIndex: "110000",
                left: "45%",
                top: "3%",
                transform: "translate(-50%, -50%)",
                fontSize: "1em",
                color: "white",
                textShadow: `
                    -2px -2px 4px black,  
                    2px -2px 4px black,  
                    -2px  2px 4px black,  
                    2px  2px 4px black`
            });
            playerVoidBox.appendChild(voidTextOverlay);

            playerVoidBox.onmouseenter = () => {
                voidTextOverlay.innerText = `${voidCards.length}`;
            };
            playerVoidBox.onmouseleave = () => {
                voidTextOverlay.innerText = "Void";
            };

            if (!voidTop) return;

            const card = cards.find(c => String(c.id) === String(voidTop.id));
            if (!card) return;

            const miniCard = renderCard(card);
            Object.assign(miniCard.style, {
                transform: "rotate(270deg) scale(0.3)",
                transformOrigin: "top left",
                marginTop: "85px",
                marginLeft: "9px",
                pointerEvents: "none"
            });

            playerVoidBox.appendChild(miniCard);
        }

        function renderLatestOpponentTombCard() {
            const tombCards = gameState?.[opponentName]?.Tomb || [];
            const tombTop = tombCards[tombCards.length - 1];
            opponentTombBox.innerHTML = ""; // Always clear

            // Tomb hover label (always "Tomb")
            const tombTextOverlay = document.createElement("div");
            tombTextOverlay.innerText = "Tomb";
            Object.assign(tombTextOverlay.style, {
                position: "absolute",
                zIndex: "110000",
                left: "45%",
                top: "3%",
                transform: "translate(-50%, -50%)",
                fontSize: "1em",
                color: "white",
                textShadow: `
                    -2px -2px 4px black,  
                    2px -2px 4px black,  
                    -2px  2px 4px black,  
                    2px  2px 4px black`
            });
            opponentTombBox.appendChild(tombTextOverlay);

            opponentTombBox.onmouseenter = () => {
                tombTextOverlay.innerText = `${tombCards.length}`;
            };
            opponentTombBox.onmouseleave = () => {
                tombTextOverlay.innerText = "Tomb";
            };

            if (!tombTop) return;

            const card = cards.find(c => String(c.id) === String(tombTop.id));
            if (!card) return;

            const miniCard = renderCard(card);
            Object.assign(miniCard.style, {
                transform: "scale(0.3) rotate(180deg)",
                transformOrigin: "top left",
                marginTop: "140%",
                marginLeft: "95.5%",
                pointerEvents: "none"
            });

            opponentTombBox.appendChild(miniCard);
        }

        function renderLatestOpponentVoidCard() {
            const voidCards = gameState?.[opponentName]?.Void || [];
            const voidTop = voidCards[voidCards.length - 1];
            opponentVoidBox.innerHTML = ""; // Always clear

            // Void hover label (always "Void")
            const voidTextOverlay = document.createElement("div");
            voidTextOverlay.innerText = "Void";
            Object.assign(voidTextOverlay.style, {
                position: "absolute",
                zIndex: "110000",
                left: "45%",
                top: "3%",
                transform: "translate(-50%, -50%)",
                fontSize: "1em",
                color: "white",
                textShadow: `
                    -2px -2px 4px black,  
                    2px -2px 4px black,  
                    -2px  2px 4px black,  
                    2px  2px 4px black`
            });
            opponentVoidBox.appendChild(voidTextOverlay);

            opponentVoidBox.onmouseenter = () => {
                voidTextOverlay.innerText = `${voidCards.length}`;
            };
            opponentVoidBox.onmouseleave = () => {
                voidTextOverlay.innerText = "Void";
            };

            if (!voidTop) return;

            const card = cards.find(c => String(c.id) === String(voidTop.id));
            if (!card) return;

            const miniCard = renderCard(card);
            Object.assign(miniCard.style, {
                transform: "rotate(90deg) scale(0.3)",
                transformOrigin: "top left",
                marginTop: "140%",
                marginLeft: "95.5%",
                pointerEvents: "none"
            });

            opponentVoidBox.appendChild(miniCard);
        }

        function getRandomBotSleeve() {
            return fetch("https://geimon-app-833627ba44e0.herokuapp.com/sleeve-images")
            .then(res => res.json())
            .then(sleeves => {
            if (Array.isArray(sleeves) && sleeves.length > 0) {
                const randomIndex = Math.floor(Math.random() * sleeves.length);
                return sleeves[randomIndex];
            } else {
                console.warn("No sleeves returned");
                return "DefaultSleeve.png";
            }
            })
            .catch(err => {
            console.error("Failed to fetch sleeves:", err);
            return "DefaultSleeve.png";
            });
        }

        function getRandomBotProfilePic() {
            return fetch("https://geimon-app-833627ba44e0.herokuapp.com/profile-images")
            .then(res => res.json())
            .then(images => {
            if (Array.isArray(images) && images.length > 0) {
                const randomIndex = Math.floor(Math.random() * images.length);
                return images[randomIndex];
            } else {
                console.warn("No profile images found.");
                return "Sharpshooter-Square.png";
            }
            })
            .catch(err => {
            console.error("Failed to fetch profile images:", err);
            return "Sharpshooter-Square.png";
            });
        }
        function getRandomBotZoneArt() {
            return fetch("https://geimon-app-833627ba44e0.herokuapp.com/zone-images")
                .then(res => res.json())
                .then(images => {
                    if (Array.isArray(images) && images.length > 0) {
                        const randomIndex = Math.floor(Math.random() * images.length);
                        return images[randomIndex];
                    } else {
                        console.warn("No zone images found.");
                        return "DefaultZone.png";
                    }
                })
                .catch(err => {
                    console.error("Failed to fetch zone images:", err);
                    return "DefaultZone.png";
                });
        }

        async function transitionToNextScreen(choice) {
            // Keep the background image visible
            const bgImage = document.querySelector(".bg-image");

            // Create a semi-transparent overlay
            const overlay = document.createElement("div");
                overlay.style.position = "absolute";
                overlay.style.top = "0";
                overlay.style.left = "0";
                overlay.style.width = "100%";
                overlay.style.height = "100%";
                overlay.style.backgroundColor = "rgba(0, 0, 0, 0.4)"; // Dark transparency
                overlay.style.zIndex = "10";

            // Main container for the structured design
            const mainContainer = document.createElement("div");
                mainContainer.style.position = "absolute";
                mainContainer.style.top = "24px";
                mainContainer.style.left = "45px";
                mainContainer.style.width = "1920px";
                mainContainer.style.height = "903px";
                mainContainer.style.display = "flex";
                mainContainer.style.flexDirection = "column";
                mainContainer.style.justifyContent = "center";
                mainContainer.style.alignItems = "center";
                mainContainer.style.gap = "10px";
                mainContainer.style.padding = "20px";
                mainContainer.style.backgroundColor = "rgba(0, 0, 0)";
                mainContainer.style.borderRadius = "20px";
                mainContainer.style.zIndex = "20";
                mainContainer.style.opacity = "0"; // Start fully invisible
                mainContainer.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
                mainContainer.style.transform = "scale(0.8)  translate(100px,-50px)";

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                mainContainer.style.opacity = "1";
            }, 50);

            // Central result box
            const resultBox = document.createElement("div");
                resultBox.style.position = "absolute";
                resultBox.style.top = "50%";
                resultBox.style.left = "50%";
                resultBox.style.transform = "translate(-50%, -50%)";
                resultBox.style.padding = "20px 40px";
                resultBox.style.color = "white";
                resultBox.style.fontSize = "2em";
                resultBox.style.borderRadius = "10px";
                resultBox.style.textAlign = "center";
                resultBox.style.opacity = "0"; // Start fully invisible
                resultBox.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
                resultBox.style.zIndex = "100700"; // On top of everything
                resultBox.style.boxShadow = "0 0 20px black";

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                resultBox.style.opacity = "1";
            }, 50);

            // Set background color based on choice
            resultBox.style.backgroundColor = choice === "first" ? "blue" : "red";
            resultBox.textContent = choice === "first" ? "Your Turn" : "Opponent's Turn";

            // Main board container
            const board = document.createElement("div");
                board.style.position = "absolute";
                board.style.top = "2%";
                board.style.left = "2%";
                board.style.width = "96%";
                board.style.height = "94%";
                board.style.backgroundColor = "black";
                board.style.zIndex = "20";
                board.style.borderRadius = "20px";
                board.style.opacity = "0"; // Start fully invisible
                board.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                board.style.opacity = "1";
            }, 50);

            const turnBox = document.createElement("div");
                turnBox.id = "turn-color-box";
                turnBox.style.position = "absolute";
                turnBox.style.left = "1343px";
                turnBox.style.top = "435px";
                turnBox.style.width = "305px";
                turnBox.style.height = "40px";
                turnBox.style.zIndex = "30";
                turnBox.style.border = "0px solid white";
                turnBox.style.borderRadius = "4px";
                turnBox.style.transition = "background-color 1s ease";
                turnBox.style.opacity = "0";
            document.body.appendChild(turnBox);

            setTimeout(() => {
                turnBox.style.opacity = "1"; // Fades out smoothly
            }, 2700);

            const championBox = document.getElementById("playerChampionsBox");
                championBox.style.position = "fixed";
                championBox.style.left = "695px";
                championBox.style.top = "525px";
                championBox.style.width = "525px";
                championBox.style.height = "128px";
                championBox.style.zIndex = "110000"; // ensure it's above the board
                championBox.style.pointerEvents = "auto";
                championBox.style.backgroundColor = "rgba(255, 0, 0, 0)"; // debug transparent background
                championBox.style.display        = "flex";
                championBox.style.justifyContent = "flex-start";
                championBox.style.alignItems     = "center";
                championBox.style.gap            = "0px";
                championBox.style.flexWrap       = "nowrap";

            const facedownBox = document.getElementById("playerFaceDownBox");
                facedownBox.style.position = "fixed";
                facedownBox.style.left = "1225px";
                facedownBox.style.top = "675px";
                facedownBox.style.width = "492px";
                facedownBox.style.height = "128px";
                facedownBox.style.zIndex = "110000";
                facedownBox.style.pointerEvents = "auto";
                facedownBox.style.backgroundColor = "rgba(0, 255, 0, 0)";
                facedownBox.style.display        = "flex";
                facedownBox.style.justifyContent = "flex-end";
                facedownBox.style.alignItems     = "center";
                facedownBox.style.gap            = "0px";
                facedownBox.style.flexWrap       = "nowrap";

            const arsenalBox = document.getElementById("playerArsenalBox");
                arsenalBox.style.position = "fixed";
                arsenalBox.style.left = "695px";
                arsenalBox.style.top = "674.5px";
                arsenalBox.style.width = "525px";
                arsenalBox.style.height = "128px";
                arsenalBox.style.zIndex = "110010"; // ensure it's above the board
                arsenalBox.style.pointerEvents = "auto";
                arsenalBox.style.backgroundColor = "rgba(255, 0, 0, 0)"; // debug transparent background
                arsenalBox.style.display        = "flex";
                arsenalBox.style.justifyContent = "flex-start";
                arsenalBox.style.alignItems     = "center";
                arsenalBox.style.gap            = "0px";
                arsenalBox.style.flexWrap       = "nowrap";

            const facedownArsenalBox = document.getElementById("playerFaceDownArsenalBox");
                facedownArsenalBox.style.position = "fixed";
                facedownArsenalBox.style.left = "1320px";
                facedownArsenalBox.style.top = "821.5px";
                facedownArsenalBox.style.width = "492px";
                facedownArsenalBox.style.height = "128px";
                facedownArsenalBox.style.zIndex = "110010";
                facedownArsenalBox.style.pointerEvents = "auto";
                facedownArsenalBox.style.backgroundColor = "rgba(0, 255, 0, 0)";
                facedownArsenalBox.style.display        = "flex";
                facedownArsenalBox.style.justifyContent = "flex-end";
                facedownArsenalBox.style.alignItems     = "center";
                facedownArsenalBox.style.gap            = "0px";
                facedownArsenalBox.style.flexWrap       = "nowrap";

            const reserveBox = document.getElementById("playerReserveBox");
                reserveBox.className = "card-zone";
                reserveBox.style.position = "absolute";
                reserveBox.style.left = "523.5px";
                reserveBox.style.top = "900px";
                reserveBox.style.width = "310px";
                reserveBox.style.height = "275px";
                reserveBox.style.zIndex = "100900";
                reserveBox.style.pointerEvents = "auto";
                reserveBox.style.backgroundColor = "rgba(255, 0, 0, 0)";
                reserveBox.style.display        = "flex";
                reserveBox.style.justifyContent = "flex-start";
                reserveBox.style.alignItems     = "center";
                reserveBox.style.gap            = "0px";

            fetchUserData().then(async userData => {
                if (userData && userData.zoneArt) {
                    const zoneArtContainer = document.createElement("div");
                        zoneArtContainer.style.position = "absolute";
                        zoneArtContainer.style.left = "0";
                        zoneArtContainer.style.bottom = "-18px";
                        zoneArtContainer.style.width = "100%";
                        zoneArtContainer.style.height = "51%";
                        zoneArtContainer.style.overflow = "hidden";

                    const zoneArtImage = document.createElement("img");
                        zoneArtImage.src = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Zones/${userData.zoneArt}`;
                        zoneArtImage.style.position = "absolute";
                        zoneArtImage.style.width = "100%";
                        zoneArtImage.style.height = "200%"; // Double height so top half is offscreen
                        zoneArtImage.style.top = "0%"; // Shift to crop top, show only bottom half
                        zoneArtImage.style.left = "0";
                        zoneArtImage.style.zIndex = "10";
                        zoneArtImage.style.border = "6px solid black";
                        zoneArtImage.style.objectFit = "cover";
                        zoneArtImage.style.opacity = "0.65";
                    zoneArtContainer.appendChild(zoneArtImage);
                    board.appendChild(zoneArtContainer);
                }
                // Opponent side zone art
                const opponentZoneArtContainer = document.createElement("div");
                    opponentZoneArtContainer.style.position = "absolute";
                    opponentZoneArtContainer.style.left = "0";
                    opponentZoneArtContainer.style.top = "0";
                    opponentZoneArtContainer.style.width = "100%";
                    opponentZoneArtContainer.style.height = "51%";
                    opponentZoneArtContainer.style.overflow = "hidden";
                    opponentZoneArtContainer.style.zIndex = "9"; // Slightly behind player’s zone art

                const opponentZoneArtImage = document.createElement("img");
                    opponentZoneArtImage.style.position = "absolute";
                    opponentZoneArtImage.style.width = "100%";
                    opponentZoneArtImage.style.height = "200%"; // Still double height
                    opponentZoneArtImage.style.bottom = "0"; // To keep bottom half showing
                    opponentZoneArtImage.style.left = "0";
                    opponentZoneArtImage.style.objectFit = "cover";
                    opponentZoneArtImage.style.border = "6px solid black";
                    opponentZoneArtImage.style.transform = "rotate(180deg)"; // Flip for opponent perspective
                    opponentZoneArtImage.style.opacity = "0.65";

                if (isSinglePlayer) {
                    getRandomBotZoneArt().then(zoneArtFile => {
                        opponentZoneArtImage.src = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Zones/${zoneArtFile}`;
                        opponentZoneArtContainer.appendChild(opponentZoneArtImage);
                        board.appendChild(opponentZoneArtContainer);
                    });
                } else {
                    const opponentData = isSinglePlayer ? null : await fetchOpponentData(otherPlayerName);
                    if (opponentData?.zoneArt) {
                        opponentZoneArtImage.src =
                            `${serverUrl}/Public/Images/Zones/${opponentData.zoneArt}`;
                        opponentZoneArtContainer.appendChild(opponentZoneArtImage);
                        board.appendChild(opponentZoneArtContainer);
                    }
                }
                const scale = window.innerWidth / 1920;
                if (userData && userData.profilePic) {
                    const playerProfilePic = document.createElement("div");
                    playerProfilePic.style.position = "absolute";
                    playerProfilePic.style.left = `1965px`;
                    playerProfilePic.style.top = `750px`;
                    playerProfilePic.style.width = `100px`;
                    playerProfilePic.style.height = `100px`;
                    playerProfilePic.style.zIndex = "100";
                    playerProfilePic.style.overflow = "hidden";

                    const profilePicImage = document.createElement("img");
                    profilePicImage.src = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Profile Pictures/${userData.profilePic}`;
                    profilePicImage.style.width = "100%";
                    profilePicImage.style.height = "100%";
                    profilePicImage.style.zIndex = "1100";
                    profilePicImage.style.border = "6px solid black";
                    profilePicImage.style.boxSizing = "border-box";
                    profilePicImage.style.objectFit = "cover";

                    playerProfilePic.appendChild(profilePicImage);
                    board.appendChild(playerProfilePic);
                }
                if (isSinglePlayer) {
                    getRandomBotProfilePic().then(profilePic => {
                        const scale = window.innerWidth / 1920;

                        const opponentProfilePic = document.createElement("div");
                        opponentProfilePic.style.position = "absolute";
                        opponentProfilePic.style.left = `1960px`;
                        opponentProfilePic.style.top = `70px`;  // Opponent zone
                        opponentProfilePic.style.width = `100px`;
                        opponentProfilePic.style.height = `100px`;
                        opponentProfilePic.style.zIndex = "100";
                        opponentProfilePic.style.overflow = "hidden";

                        const profilePicImage = document.createElement("img");
                        profilePicImage.src = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Profile Pictures/${profilePic}`;
                        profilePicImage.style.width = "100%";
                        profilePicImage.style.height = "100%";
                        profilePicImage.style.zIndex = "1100";
                        profilePicImage.style.border = "6px solid black";
                        profilePicImage.style.boxSizing = "border-box";
                        profilePicImage.style.objectFit = "cover";

                        opponentProfilePic.appendChild(profilePicImage);
                        board.appendChild(opponentProfilePic);
                    });
                } else {
                    const opponentProfilePic = document.createElement("div");
                    Object.assign(opponentProfilePic.style, {
                        position:"absolute", left:"1960px", top:"70px",
                        width:"100px", height:"100px", zIndex:"100", overflow:"hidden"
                    });
                    const img = document.createElement("img");
                    img.src = `${serverUrl}/Public/Images/Profile Pictures/${opponentData.profilePic}`;
                    Object.assign(img.style, {
                        width:"100%", height:"100%", border:"6px solid black",
                        boxSizing:"border-box", objectFit:"cover"
                    });
                    opponentProfilePic.appendChild(img);
                    board.appendChild(opponentProfilePic);
                }
            });

            // After all elements like playerDeckBox and deckText are added
            fetchUserData().then(async userData => {
                if (userData && userData.deckSleeve) {
                    playerDeckBox.style.backgroundImage = `url(https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Sleeves/${userData.deckSleeve})`;
                    playerDeckBox.style.backgroundSize = "cover";
                    playerDeckBox.style.backgroundPosition = "center";
                    playerDeckBox.style.backgroundRepeat = "no-repeat";
                }
                if (isSinglePlayer) {
                    getRandomBotSleeve().then(sleeve => {
                        opponentDeckBox.style.backgroundImage = `url(https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Sleeves/${sleeve})`;
                        opponentDeckBox.style.backgroundSize = "cover";
                        opponentDeckBox.style.backgroundPosition = "center";
                        opponentDeckBox.style.backgroundRepeat = "no-repeat";
                    });
                } else {
                    const opponentData = await fetchOpponentData(otherPlayerName);
                    if (opponentData?.deckSleeve) {
                        opponentDeckBox.style.backgroundImage =
                        `url(${serverUrl}/Public/Images/Sleeves/${opponentData.deckSleeve})`;
                        opponentDeckBox.style.backgroundSize = "cover";
                        opponentDeckBox.style.backgroundPosition = "center";
                        opponentDeckBox.style.backgroundRepeat = "no-repeat";
                    }
                }
            });

            // Function to add a box
            function addBox(x, y, w, h, color="green", backColor="black", opa="0.5") {
                const box = document.createElement("div");
                    box.style.position = "absolute";
                    box.style.left = x;
                    box.style.top = y;
                    box.style.width = w;
                    box.style.height = h;
                    box.style.border = `4px solid ${color}`;
                    box.style.backgroundColor = `${backColor}`;
                    box.style.opacity = `${opa}`;
                    box.style.zIndex = "30";
                board.appendChild(box);
            }

            // Reproduce visual layout from image (values are approximate %)
            addBox("1%", "1%", "6%", "19%", "lightsalmon");     // Opponent Deck
            addBox("9%", "1%", "68%", "19%", "lightsalmon");    // Opponent Arsenal

            addBox("79%", "1%", "20%", "40%", "lightsalmon");   // Opponent Reserve

            addBox("1%", "22%", "6%", "19%", "lightsalmon");    // Opponent Tomb
            addBox("9%", "22%", "68%", "19%", "lightsalmon");   // Opponent Champions

            addBox("1%", "44%", "10%", "14%", "lightsalmon");    // Opponent Void

            addBox("14%", "47%", "72%", "7%", "lightgreen");    // Path
            //addBox("65.8%", "48%", "19.75%", "5%", "white","","1"); // Back of turn count, player turn

            addBox("89%", "44%", "10%", "14%", "lightblue");   // Player Void

            addBox("1%", "60%", "20%", "40%", "lightblue");   // Player Reserve

            addBox("23%", "60%", "68%", "19%", "lightblue");  // Player Champions
            addBox("93%", "60%", "6%", "19%", "lightblue");  // Player Tomb

            addBox("23%", "81%", "68%", "19%", "lightblue");  // Player Arsenal
            addBox("93%", "81%", "6%", "19%", "lightblue");  // Player Deck

            document.body.appendChild(overlay);
            document.body.appendChild(mainContainer);
            mainContainer.appendChild(board);
            mainContainer.appendChild(resultBox);

            // Fade out the result box after 3 seconds
            setTimeout(() => {
                resultBox.style.opacity = "0"; // Fades out smoothly
            }, 2000);

            const params = new URLSearchParams(window.location.search);

            // Function to fetch user data from the session
            async function fetchUserData() {
                try {
                    const res = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/me', {
                        credentials: 'include'
                    });
                    if (!res.ok) throw new Error('Response error');

                    const data = await res.json();
                    if (!data.loggedIn) return null;

                    if (data && data.deckSleeve) {
                        userSleeveURL = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Sleeves/${data.deckSleeve}`;
                    }

                    return data;
                } catch (err) {
                    console.error('Failed to fetch user data:', err);
                    return null;
                }
            }

            const playerUsernameParam   = params.get("playerUsername")     || "You";
            const opponentUsernameParam = params.get("opponent")           || (params.get("isSinglePlayer")==="true" ? "Bot" : "Opponent");
            const gameTypeParam         = params.get("gameType")           || "single";
            const isSinglePlayerParam   = params.get("isSinglePlayer")==="true";
            const turnOrderParam        = params.get("turnOrder")          || "first";
            const opponentOwner         = opponentUsernameParam;
            // Fetch deck and start game
            const playerDeckName = new URLSearchParams(window.location.search).get("playerDeck");
            const opponentDeckName = new URLSearchParams(window.location.search).get("opponentDeck");

            const playerDeckResult = await fetchDeckCards(playerDeckName);
            const opponentDeckResult = await fetchDeckCards(opponentDeckName, opponentOwner);

            if (!playerDeckResult.success || !opponentDeckResult.success) {
                console.error("Deck fetch failed");
                return;
            }

            const playerDeck = playerDeckResult.card_ids;
            shuffleDeck(playerDeck);

            const opponentDeck = opponentDeckResult.card_ids;
            shuffleDeck(opponentDeck);

            const selectedTotem = params.get("totem");
            const selectedTotemText = params.get("totemText");

            const totemElement = document.createElement("p");
                totemElement.innerHTML = `${selectedTotem}`;
                totemElement.style.color = "goldenrod";
            const totemTextElement = document.createElement("p");
                totemTextElement.innerHTML = `<strong>Description:</strong> ${selectedTotemText}`;
            document.getElementById("game-log-placeholder").appendChild(totemElement);
            document.getElementById("game-log-placeholder").appendChild(totemTextElement);

            await getUsername();
            document.getElementById("player-name")  .textContent = playerUsernameParam;
            document.getElementById("opponent-name").textContent = opponentUsernameParam;
            //const totemSpan = document.getElementById("totem");
            //if (totemSpan) {
                //totemSpan.textContent = `${selectedTotem}: ${selectedTotemText}`;
            //}

            opponentName = opponentUsernameParam;

            if (playerDeckResult.success && opponentDeckResult.success) {
                await fetch('https://geimon-app-833627ba44e0.herokuapp.com/startGame', {
                    method: 'POST',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        gameId,
                        playerUsername: username,
                        opponentUsername: isSinglePlayerParam ? "Bot" : opponentUsernameParam,
                        playerDeck,
                        opponentDeck,
                        isSinglePlayer: isSinglePlayerParam,
                        goesFirst: choice === "first" ? username : (isSinglePlayerParam ? "Bot" : opponentUsernameParam),
                        totem: selectedTotem
                    })
                });

                gameState = await waitForGameState();

                if (gameState[username].Hand.length === 0) {
                    for (let i = 0; i < 5; i++) {
                        await drawCards(gameState[username].Deck, 1);
                    }
                    await sendZoneUpdate(["Deck", "Hand"]);
                }
                drawnCardsArray = gameState[username].Hand; // ✅ Set the global array
                previousHandIds = drawnCardsArray.map(card => card.id); // ✅ Track previous IDs
                await renderDrawnCards();
                await showRedrawPrompt(); // Pause here and show redraw
                hasDrawnInitialHand = true;

                updateDeckText();
                await updateLocalFromGameState();

                if (!intervalId) {
                intervalId = setInterval(async () => {
                    isFetchingGameState = true;
                    try {
                        await fetchGameStateFromServer();
                    } catch (error) {
                        console.error("Error fetching game state:", error);
                    } finally {
                        isFetchingGameState = false;
                    }
                }, 1500);
            }

            const totemBox = document.createElement("div");
                totemBox.style.position = "absolute";
                totemBox.style.top = "46%";
                totemBox.style.left = "53%";
                totemBox.style.transform = "translate(-50%, -50%)";
                totemBox.style.padding = "16px 32px";
                totemBox.style.backgroundColor = "goldenrod";
                totemBox.style.color = "white";
                totemBox.style.fontSize = "1.5em";
                totemBox.style.borderRadius = "10px";
                totemBox.style.textAlign = "center";
                totemBox.style.opacity = "0"; // Start invisible
                totemBox.style.transition = "opacity 1s ease-in-out";
                totemBox.style.zIndex = "100900";
                totemBox.style.boxShadow = "0 0 20px black";
                totemBox.textContent = `Selected Totem: ${selectedTotem} - ${selectedTotemText}`;

                // Add to document
                document.body.appendChild(totemBox);

                // Trigger fade-in
                setTimeout(() => {
                    totemBox.style.opacity = "1";
                }, 1000); // Slight delay after result box

                setTimeout(() => {
                    totemBox.style.opacity = "0";
                    totemBox.style.zIndex = "10";
                    window.totemFullyFaded = true;
                }, 4000);

                document.getElementById("player-name").textContent = username;
                document.getElementById("player-life").textContent = gameState[username].life;

                opponentName = isSinglePlayer ? "Bot" : opponentUsernameParam;
                //console.log("Creating game for", username, "vs", isSinglePlayer ? "Bot" : opponentUsernameParam);
                document.getElementById("opponent-name").textContent = opponentUsernameParam;
                //console.log("Opponent Name: ", opponentUsernameParam);
                document.getElementById("opponent-life").textContent = gameState[opponentUsernameParam].life;
                //console.log("Opponent Life: ", gameState[opponentUsernameParam].life);

                if (!gameReady) {
                    await fetchGameStateFromServer();
                    gameReady = true;
                }
                if (!gameState || !gameState[username]) {
                    alert("Game could not be started.");
                    return;
                }
            } else {
                console.error("Deck loading failed:", playerDeckResult.message);
            }
        }

        async function fetchDeckCards(deckName, ownerUsername) {
            if (deckName === "Random") {
                // Generate a random deck locally
                const cardPool = cards.map(card => card.id); // Extract all IDs
                const deckSize = Math.floor(Math.random() * 41) + 60; // Random between 60–100
                const shuffled = cardPool.sort(() => 0.5 - Math.random());
                const card_ids = shuffled.slice(0, deckSize);

                deckCount = `${card_ids.length}`;
                if (playerDeckBox) {
                    //playerDeckBox.innerText = "Deck";
                }

                return { success: true, card_ids };
            }

            // Fallback to real server call for named decks
            try {
                const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                    method: "POST",
                    credentials: 'include',
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ deck_name: deckName, owner: ownerUsername })
                });

                const data = await response.json();

                if (data.success) {
                    deckCount = `${data.card_ids.length}`;
                    if (playerDeckBox) {
                        //playerDeckBox.innerText = "Deck";
                    }
                } else {
                    deckCount = data.message;
                }

                return data;
            } catch (error) {
                console.error("Error fetching deck cards:", error);
                return { success: false, message: 'Fetch error' };
            }
        }

    // Select the existing Player Deck box after it's created
    const playerDeckBox = document.createElement("div");
        playerDeckBox.id = "playerDeckBox";
        playerDeckBox.style.position = "absolute";
        playerDeckBox.style.left = "1751px";
        playerDeckBox.style.top = "649px";
        playerDeckBox.style.width = "82px";
        playerDeckBox.style.height = "126px";
        //playerDeckBox.style.backgroundColor = "lightblue";
        playerDeckBox.style.outline = "1px solid white"; // Bright white outline for debugging
        playerDeckBox.style.display = "block"; // Ensure it's always visible
        //playerDeckBox.style.zIndex = "1000"; // Bring it to the front layer
        playerDeckBox.style.opacity = "0"; // Start fully invisible
        playerDeckBox.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
        playerDeckBox.style.textAlign = "center"; // Ensures proper alignment
        playerDeckBox.style.fontWeight = "bold";
        playerDeckBox.style.fontSize = "1.2em";
        playerDeckBox.style.color = "white";
        playerDeckBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;
    document.body.appendChild(playerDeckBox); // Add to the document

    // Create the text span element separately
    const deckText = document.createElement("span");
        deckText.id = "deckText";
        deckText.textContent = "Deck";
        Object.assign(deckText.style, {
            position:      "absolute",
            left:          "50%",
            top:           "10%",
            transform:     "translate(-50%, -50%)",
            pointerEvents: "none",
        });
    playerDeckBox.appendChild(deckText);

    const opponentDeckBox = document.createElement("div");
        opponentDeckBox.id = "opponentDeckBox";
        opponentDeckBox.style.position = "absolute";
        opponentDeckBox.style.left = "375px";
        opponentDeckBox.style.top = "108px";
        opponentDeckBox.style.width = "82px";
        opponentDeckBox.style.height = "126px";
        opponentDeckBox.style.outline = "0px solid white";
        opponentDeckBox.style.display = "block";
        opponentDeckBox.style.zIndex = "1000";
        opponentDeckBox.style.opacity = "0";
        opponentDeckBox.style.outline = "1px solid white";
        opponentDeckBox.style.transition = "opacity 1s ease-in-out";
        opponentDeckBox.style.textAlign = "center";
        opponentDeckBox.style.fontWeight = "bold";
        opponentDeckBox.style.fontSize = "1.2em";
        opponentDeckBox.style.color = "white";
        opponentDeckBox.style.transform = "rotate(180deg)";
        opponentDeckBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

    const opponentDeckText = document.createElement("span");
        opponentDeckText.innerText = "Deck";
        opponentDeckText.style.position = "absolute";
        opponentDeckText.style.left = "50%";
        opponentDeckText.style.top = "92%";
        opponentDeckText.style.transform = "translate(-50%, -50%) rotate(180deg)";
    opponentDeckBox.appendChild(opponentDeckText);
    document.body.appendChild(opponentDeckBox);

    setTimeout(() => {
        opponentDeckBox.style.opacity = "1";
    }, 6500);

    //Start of Tomb Box Stuff
    const playerTombBox = document.createElement("div");
        playerTombBox.id = "playerTombBox";
        playerTombBox.style.position = "absolute";
        playerTombBox.style.left = "1762px";  // Same X as Deck
        playerTombBox.style.top = "532px";   // Directly above the Deck
        playerTombBox.style.width = "88px";
        playerTombBox.style.height = "126px";
        playerTombBox.style.outline = "none";//"4px solid white";
        playerTombBox.style.zIndex = "1000";
        //playerTombBox.style.backgroundColor = "rgba(255, 0, 0)";
        playerTombBox.style.opacity = "0";
        playerTombBox.style.transition = "opacity 1s ease-in-out";
        playerTombBox.style.textAlign = "center";
        playerTombBox.style.fontWeight = "bold";
        playerTombBox.style.fontSize = "1.2em";
        playerTombBox.style.color = "white";
        playerTombBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

        const tombText = document.createElement("span");
            tombText.innerText = "Tomb";
            tombText.style.position = "absolute";
            tombText.style.left = "43%";
            tombText.style.top = "2%";
            tombText.style.transform = "translate(-50%, -50%)";
        playerTombBox.appendChild(tombText);
        document.body.appendChild(playerTombBox);

        setTimeout(() => {
            playerTombBox.style.opacity = "1";
        }, 6500);

        function updateTombText() {
            if (gameState && gameState[username]) {
                const count = gameState[username].Tomb.length;
                tombText.innerText = `${count}`;
                tombText.style.position = "absolute";
                tombText.style.left = "43%";
                tombText.style.top = "2%";
                tombText.style.transform = "translate(-50%, -50%)";
            }
        }

        playerTombBox.addEventListener("mouseenter", updateTombText);
        playerTombBox.addEventListener("mouseleave", () => {
            tombText.innerText = "Tomb";
            tombText.style.position = "absolute";
            tombText.style.left = "45%";
            tombText.style.top = "2%";
            tombText.style.transform = "translate(-50%, -50%)";
        });

    // Create Tomb Button Overlay
    const tombButton = document.createElement("button");
        tombButton.style.position = "absolute";
        tombButton.style.left = "1758px";
        tombButton.style.top = "540px";
        tombButton.style.width = "85px";
        tombButton.style.height = "113px"; //addBox("93%", "60%", "6%", "19%", "lightblue");  // Player Tomb
        tombButton.style.backgroundColor = "rgba(0, 255, 0)";
        tombButton.style.opacity = "0";
        tombButton.style.border = "none";
        tombButton.style.zIndex = "100800";
        tombButton.style.cursor = "pointer";
        tombButton.title = "Tomb";

        // Add event listener for click
        tombButton.addEventListener("click", () => {
            const popup = document.createElement("div");
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.maxWidth = "min(90%, 800px)";
                popup.style.overflowY = "auto";
                popup.style.maxHeight = "unset";
                popup.style.height = "auto";
                popup.style.overflow = "visible";
                popup.style.padding = "10px 20px";
                popup.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
                popup.style.border = "3px solid white";
                popup.style.borderRadius = "12px";
                popup.style.zIndex = "120900";
                popup.style.display = "flex";
                popup.style.flexDirection = "column";
                popup.style.alignItems = "center";
                popup.style.gap = "20px";

            const title = document.createElement("div");
                title.textContent = "Tomb";
                title.style.color = "white";
                title.style.fontSize = "2em";
                title.style.textAlign = "center";
            popup.appendChild(title);

            const tombCards = gameState?.[username]?.Tomb || [];

            if (tombCards.length === 0) {
                const none = document.createElement("div");
                none.textContent = "Tomb is empty.";
                none.style.color = "white";
                popup.appendChild(none);
            } else {
                const cardContainer = document.createElement("div");
                    cardContainer.style.display = "flex";
                    cardContainer.style.flexWrap = "wrap";
                    cardContainer.style.justifyContent = "center";
                    cardContainer.style.gap = "10px";
                    cardContainer.style.marginRight = "10px";
                    cardContainer.style.maxWidth = "100%";
                    cardContainer.style.overflow = "visible";

                const scale = 0.3;
                const cardWidth = 240;
                const cardHeight = 420;

                tombCards.forEach(cardData => {
                    const card = cards.find(c => String(c.id) === String(cardData.id));
                    if (!card) return;

                    const scale = 0.3;
                    const scaledCard = renderCard(card);
                        scaledCard.style.transform = `scale(${scale})`;
                        scaledCard.style.transformOrigin = "top left";
                        scaledCard.style.margin = "5px";
                        scaledCard.style.position = "relative";
                    scaledCard.dataset.zone = "Tomb";
                    attachHoverMenu(scaledCard, cardData);

                    const wrapper = document.createElement("div");
                        wrapper.style.width = `${260 * scale}px`;
                        wrapper.style.height = `${400 * scale}px`;
                        wrapper.style.overflow = "visible";
                        wrapper.style.position = "relative";

                    // Tomb card click overlay
                    const overlay = document.createElement("button");
                        overlay.style.position = "absolute";
                        overlay.style.top = "0";
                        overlay.style.left = "0";
                        overlay.style.width = "100%";
                        overlay.style.height = "100%";
                        overlay.style.opacity = "0";
                        overlay.style.border = "none";
                        overlay.style.background = "transparent";
                        overlay.style.cursor = "pointer";
                    overlay.onclick = () => alert(`Card in Tomb Clicked: ${card.name}`);

                    wrapper.appendChild(scaledCard);
                    wrapper.appendChild(overlay);

                    // Hover preview
                    wrapper.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                            scaled.innerHTML = "";
                        const preview = renderCard(card);
                            preview.style.width = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop = "7%";
                        scaled.appendChild(preview);
                    });

                    cardContainer.appendChild(wrapper);
                });
                popup.appendChild(cardContainer);
            }

            const closeBtn = document.createElement("button");
                closeBtn.textContent = "Close";
                closeBtn.style.marginTop = "10px";
                closeBtn.style.padding = "10px 20px";
                closeBtn.style.fontSize = "1.2em";
                closeBtn.style.cursor = "pointer";
                closeBtn.style.zIndex = "120000";
            closeBtn.onclick = () => popup.remove();
            popup.appendChild(closeBtn);

            document.body.appendChild(popup);
    });

    document.body.appendChild(tombButton);
    //End of Tomb Creation Stuff

    //Start of Void Box Stuff
    const playerVoidBox = document.createElement("div");
        playerVoidBox.id = "playerVoidBox";
        playerVoidBox.style.position = "absolute";
        playerVoidBox.style.left = "1697px";  // Same X as Deck
        playerVoidBox.style.top = "415px";   // Directly above the Deck
        playerVoidBox.style.width = "147px";
        playerVoidBox.style.height = "90px";
        playerVoidBox.style.outline = "none";//"4px solid white";
        playerVoidBox.style.zIndex = "1000";
        //playerVoidBox.style.backgroundColor = "rgba(255, 0, 0)";
        playerVoidBox.style.opacity = "0";
        playerVoidBox.style.transition = "opacity 1s ease-in-out";
        playerVoidBox.style.textAlign = "center";
        playerVoidBox.style.fontWeight = "bold";
        playerVoidBox.style.fontSize = "1.2em";
        playerVoidBox.style.color = "white";
        playerVoidBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

        const voidText = document.createElement("span");
            voidText.innerText = "Void";
            voidText.style.position = "absolute";
            voidText.style.left = "50%";
            voidText.style.top = "5%";
            voidText.style.transform = "translate(-50%, -50%)";

        playerVoidBox.appendChild(voidText);
        document.body.appendChild(playerVoidBox);

        setTimeout(() => {
            playerVoidBox.style.opacity = "1";
        }, 6500);

        function updateVoidText() {
            if (gameState && gameState[username]) {
                const count = gameState[username].Void.length;
                voidText.innerText = `${count}`;
            }
        }

        playerVoidBox.addEventListener("mouseenter", updateVoidText);
        playerVoidBox.addEventListener("mouseleave", () => {
            voidText.innerText = "Void";
        });

    // Create Void Button Overlay
    const voidButton = document.createElement("button");
        voidButton.style.position = "absolute";
        voidButton.style.left = "1697px";
        voidButton.style.top = "425px";
        voidButton.style.width = "149px";
        voidButton.style.height = "80px"; //addBox("89%", "44%", "10%", "14%", "lightblue");   // Player Void
        voidButton.style.backgroundColor = "rgba(255, 0, 0)";
        voidButton.style.opacity = "0";
        voidButton.style.border = "none";
        voidButton.style.zIndex = "100800";
        voidButton.style.cursor = "pointer";
        voidButton.title = "Void";

        // Add event listener for click
        voidButton.addEventListener("click", () => {
            const popup = document.createElement("div");
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.maxWidth = "min(90%, 800px)";
                popup.style.overflowY = "auto";
                popup.style.maxHeight = "unset";
                popup.style.height = "auto";
                popup.style.overflow = "visible";
                popup.style.padding = "10px 20px";
                popup.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
                popup.style.border = "3px solid white";
                popup.style.borderRadius = "12px";
                popup.style.zIndex = "120900";
                popup.style.display = "flex";
                popup.style.flexDirection = "column";
                popup.style.alignItems = "center";
                popup.style.gap = "20px";

            const title = document.createElement("div");
                title.textContent = "Void";
                title.style.color = "white";
                title.style.fontSize = "2em";
                title.style.textAlign = "center";
            popup.appendChild(title);

            const voidCards = gameState?.[username]?.Void || [];

            if (voidCards.length === 0) {
                const none = document.createElement("div");
                none.textContent = "Void is empty.";
                none.style.color = "white";
                popup.appendChild(none);
            } else {
                const cardContainer = document.createElement("div");
                    cardContainer.style.display = "flex";
                    cardContainer.style.flexWrap = "wrap";
                    cardContainer.style.justifyContent = "center";
                    cardContainer.style.gap = "10px";
                    cardContainer.style.marginRight = "19px";
                    cardContainer.style.maxWidth = "100%";
                    cardContainer.style.overflow = "visible";

                const scale = 0.3;
                const cardWidth = 240;
                const cardHeight = 420;

                voidCards.forEach(cardData => {
                    const card = cards.find(c => String(c.id) === String(cardData.id));
                    if (!card) return;

                    const scale = 0.3;
                    const scaledCard = renderCard(card);
                        scaledCard.style.transform = `scale(${scale})`;
                        scaledCard.style.transformOrigin = "top left";
                        scaledCard.style.margin = "5px";
                        scaledCard.style.position = "relative";
                    scaledCard.dataset.zone = "Void";
                    attachHoverMenu(scaledCard, cardData);

                    const wrapper = document.createElement("div");
                        wrapper.style.width = `${240 * scale}px`;
                        wrapper.style.height = `${420 * scale}px`;
                        wrapper.style.overflow = "visible";
                        wrapper.style.position = "relative";

                    // Void card click overlay
                    const overlay = document.createElement("button");
                        overlay.style.position = "absolute";
                        overlay.style.top = "0";
                        overlay.style.left = "0";
                        overlay.style.width = "100%";
                        overlay.style.height = "100%";
                        overlay.style.opacity = "0";
                        overlay.style.border = "none";
                        overlay.style.background = "transparent";
                        overlay.style.cursor = "pointer";
                    overlay.onclick = () => alert(`Card in Void Clicked: ${card.name}`);

                    wrapper.appendChild(scaledCard);
                    wrapper.appendChild(overlay);

                    // Hover preview
                    wrapper.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                            scaled.innerHTML = "";
                        const preview = renderCard(card);
                            preview.style.width = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop = "7%";
                        scaled.appendChild(preview);
                    });

                    cardContainer.appendChild(wrapper);
                });
                popup.appendChild(cardContainer);
            }

            const closeBtn = document.createElement("button");
                closeBtn.textContent = "Close";
                closeBtn.style.marginTop = "10px";
                closeBtn.style.padding = "10px 20px";
                closeBtn.style.fontSize = "1.2em";
                closeBtn.style.cursor = "pointer";
                closeBtn.style.zIndex = "120000";
            closeBtn.onclick = () => popup.remove();
            popup.appendChild(closeBtn);

            document.body.appendChild(popup);
    });

    document.body.appendChild(voidButton);
    //End of Void Stack Creation

    //Start of Opponent Tomb Box Stuff
    const opponentTombBox = document.createElement("div");
        opponentTombBox.id = "opponentTombBox";
        opponentTombBox.style.position = "absolute";
        opponentTombBox.style.left = "372px";  // Same X as Deck
        opponentTombBox.style.top = "260px";   // Directly above the Deck
        opponentTombBox.style.width = "88px";
        opponentTombBox.style.height = "126px";
        opponentTombBox.style.outline = "none";//"4px solid white";
        opponentTombBox.style.zIndex = "1000";
        //opponentTombBox.style.backgroundColor = "rgba(255, 0, 0)";
        opponentTombBox.style.opacity = "0";
        opponentTombBox.style.transition = "opacity 1s ease-in-out";
        opponentTombBox.style.textAlign = "center";
        opponentTombBox.style.fontWeight = "bold";
        opponentTombBox.style.fontSize = "1.2em";
        opponentTombBox.style.color = "white";
        opponentTombBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

        const opponentTombText = document.createElement("span");
            opponentTombText.innerText = "Tomb";
            opponentTombText.style.position = "absolute";
            opponentTombText.style.zIndex = "110000";
            opponentTombText.style.left = "50%";
            opponentTombText.style.top = "2%";
            opponentTombText.style.transform = "translate(-50%, -50%)";
        opponentTombBox.appendChild(opponentTombText);
        document.body.appendChild(opponentTombBox);

        setTimeout(() => {
            opponentTombBox.style.opacity = "1";
        }, 6500);

        function updateOpponentTombText() {
            if (gameState && gameState[opponentName]) {
                const count = gameState[opponentName].Tomb.length;
                opponentTombText.innerText = `${count}`;
                opponentTombText.style.position = "absolute";
                opponentTombText.style.zIndex = "110000";
                opponentTombText.style.left = "50%";
                opponentTombText.style.top = "2%";
                opponentTombText.style.transform = "translate(-50%, -50%)";
            }
        }

        opponentTombBox.addEventListener("mouseenter", updateOpponentTombText);
        opponentTombBox.addEventListener("mouseleave", () => {
            opponentTombText.innerText = "Tomb";
            opponentTombText.style.position = "absolute";
            opponentTombText.style.zIndex = "110000";
            opponentTombText.style.left = "50%";
            opponentTombText.style.top = "2%";
            opponentTombText.style.transform = "translate(-50%, -50%)";
        });

    // Create Tomb Button Overlay
    const opponentTombButton = document.createElement("button");
        opponentTombButton.style.position = "absolute";
        opponentTombButton.style.left = "372px";
        opponentTombButton.style.top = "270px";
        opponentTombButton.style.width = "87px";
        opponentTombButton.style.height = "115px";
        opponentTombButton.style.backgroundColor = "rgba(0, 255, 0)";
        opponentTombButton.style.opacity = "0";
        opponentTombButton.style.border = "none";
        opponentTombButton.style.zIndex = "100800";
        opponentTombButton.style.cursor = "pointer";
        opponentTombButton.title = "Tomb";

        // Add event listener for click
        opponentTombButton.addEventListener("click", () => {
            const popup = document.createElement("div");
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.maxWidth = "min(90%, 800px)";
                popup.style.overflowY = "auto";
                popup.style.maxHeight = "unset";
                popup.style.height = "auto";
                popup.style.overflow = "visible";
                popup.style.padding = "10px 20px";
                popup.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
                popup.style.border = "3px solid white";
                popup.style.borderRadius = "12px";
                popup.style.zIndex = "120900";
                popup.style.display = "flex";
                popup.style.flexDirection = "column";
                popup.style.alignItems = "center";
                popup.style.gap = "20px";

            const title = document.createElement("div");
                title.textContent = "Opponent's Tomb";
                title.style.color = "white";
                title.style.fontSize = "2em";
                title.style.textAlign = "center";
            popup.appendChild(title);

            const tombCards = gameState?.[opponentName]?.Tomb || [];

            if (tombCards.length === 0) {
                const none = document.createElement("div");
                none.textContent = "Opponent's Tomb is empty.";
                none.style.color = "white";
                popup.appendChild(none);
            } else {
                const cardContainer = document.createElement("div");
                    cardContainer.style.display = "flex";
                    cardContainer.style.flexWrap = "wrap";
                    cardContainer.style.justifyContent = "center";
                    cardContainer.style.gap = "10px";
                    cardContainer.style.marginRight = "10px";
                    cardContainer.style.maxWidth = "100%";
                    cardContainer.style.overflow = "visible";

                const scale = 0.3;
                const cardWidth = 240;
                const cardHeight = 420;

                tombCards.forEach(cardData => {
                    const card = cards.find(c => String(c.id) === String(cardData.id));
                    if (!card) return;

                    const scale = 0.3;
                    const scaledCard = renderCard(card);
                        scaledCard.style.transform = `scale(${scale})`;
                        scaledCard.style.transformOrigin = "top left";
                        scaledCard.style.margin = "5px";
                        scaledCard.style.position = "relative";
                    scaledCard.dataset.zone = "Tomb";
                    attachHoverMenu(scaledCard, cardData);

                    const wrapper = document.createElement("div");
                        wrapper.style.width = `${260 * scale}px`;
                        wrapper.style.height = `${400 * scale}px`;
                        wrapper.style.overflow = "visible";
                        wrapper.style.position = "relative";

                    // Tomb card click overlay
                    const overlay = document.createElement("button");
                        overlay.style.position = "absolute";
                        overlay.style.top = "0";
                        overlay.style.left = "0";
                        overlay.style.width = "100%";
                        overlay.style.height = "100%";
                        overlay.style.opacity = "0";
                        overlay.style.border = "none";
                        overlay.style.background = "transparent";
                        overlay.style.cursor = "pointer";
                    overlay.onclick = () => alert(`Card in Tomb Clicked: ${card.name}`);

                    wrapper.appendChild(scaledCard);
                    wrapper.appendChild(overlay);

                    // Hover preview
                    wrapper.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                            scaled.innerHTML = "";
                        const preview = renderCard(card);
                            preview.style.width = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop = "7%";
                        scaled.appendChild(preview);
                    });

                    cardContainer.appendChild(wrapper);
                });
                popup.appendChild(cardContainer);
            }

            const closeBtn = document.createElement("button");
                closeBtn.textContent = "Close";
                closeBtn.style.marginTop = "10px";
                closeBtn.style.padding = "10px 20px";
                closeBtn.style.fontSize = "1.2em";
                closeBtn.style.cursor = "pointer";
                closeBtn.style.zIndex = "120000";
            closeBtn.onclick = () => popup.remove();
            popup.appendChild(closeBtn);

            document.body.appendChild(popup);
    });

    document.body.appendChild(opponentTombButton);
    //End of Opponent Tomb Creation Stuff

    //Start of Opponent Void Box Stuff
    const opponentVoidBox = document.createElement("div");
        opponentVoidBox.id = "opponentVoidBox";
        opponentVoidBox.style.position = "absolute";
        opponentVoidBox.style.left = "372px";  // Same X as Deck
        opponentVoidBox.style.top = "415px";   // Directly above the Deck
        opponentVoidBox.style.width = "147px";
        opponentVoidBox.style.height = "90px";
        opponentVoidBox.style.outline = "none";//"4px solid white";
        opponentVoidBox.style.zIndex = "1000";
        //opponentVoidBox.style.backgroundColor = "rgba(255, 0, 0)";
        opponentVoidBox.style.opacity = "0";
        opponentVoidBox.style.transition = "opacity 1s ease-in-out";
        opponentVoidBox.style.textAlign = "center";
        opponentVoidBox.style.fontWeight = "bold";
        opponentVoidBox.style.fontSize = "1.2em";
        opponentVoidBox.style.color = "white";
        opponentVoidBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

        const opponentVoidText = document.createElement("span");
            opponentVoidText.innerText = "Void";
            opponentVoidText.style.position = "absolute";
            opponentVoidText.style.zIndex = "110000";
            opponentVoidText.style.left = "50%";
            opponentVoidText.style.top = "5%";
            opponentVoidText.style.transform = "translate(-50%, -50%)";

        opponentVoidBox.appendChild(opponentVoidText);
        document.body.appendChild(opponentVoidBox);

        setTimeout(() => {
            opponentVoidBox.style.opacity = "1";
        }, 6500);

        function updateOpponentVoidText() {
            if (gameState && gameState[opponentName]) {
                const count = gameState[opponentName].Void.length;
                opponentVoidText.innerText = `${count}`;
                opponentVoidText.style.zIndex = "110000";
            }
        }

        opponentVoidBox.addEventListener("mouseenter", updateOpponentVoidText);
        opponentVoidBox.addEventListener("mouseleave", () => {
            opponentVoidText.innerText = "Void";
            opponentVoidText.style.zIndex = "110000";
        });

    // Create Void Button Overlay
    const opponentVoidButton = document.createElement("button");
        opponentVoidButton.style.position = "absolute";
        opponentVoidButton.style.left = "372px";
        opponentVoidButton.style.top = "425px";
        opponentVoidButton.style.width = "148px";
        opponentVoidButton.style.height = "81px";
        opponentVoidButton.style.backgroundColor = "rgba(255, 0, 0)";
        opponentVoidButton.style.opacity = "0";
        opponentVoidButton.style.border = "none";
        opponentVoidButton.style.zIndex = "100800";
        opponentVoidButton.style.cursor = "pointer";
        opponentVoidButton.title = "Void";

        // Add event listener for click
        opponentVoidButton.addEventListener("click", () => {
            const popup = document.createElement("div");
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.maxWidth = "min(90%, 800px)";
                popup.style.overflowY = "auto";
                popup.style.maxHeight = "unset";
                popup.style.height = "auto";
                popup.style.overflow = "visible";
                popup.style.padding = "10px 20px";
                popup.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
                popup.style.border = "3px solid white";
                popup.style.borderRadius = "12px";
                popup.style.zIndex = "120900";
                popup.style.display = "flex";
                popup.style.flexDirection = "column";
                popup.style.alignItems = "center";
                popup.style.gap = "20px";

            const title = document.createElement("div");
                title.textContent = "Opponent's Void";
                title.style.color = "white";
                title.style.fontSize = "2em";
                title.style.textAlign = "center";
            popup.appendChild(title);

            const voidCards = gameState?.[username]?.Void || [];

            if (voidCards.length === 0) {
                const none = document.createElement("div");
                none.textContent = "Opponent's Void is empty.";
                none.style.color = "white";
                popup.appendChild(none);
            } else {
                const cardContainer = document.createElement("div");
                    cardContainer.style.display = "flex";
                    cardContainer.style.flexWrap = "wrap";
                    cardContainer.style.justifyContent = "center";
                    cardContainer.style.gap = "10px";
                    cardContainer.style.marginRight = "10px";
                    cardContainer.style.maxWidth = "100%";
                    cardContainer.style.overflow = "visible";

                const scale = 0.3;
                const cardWidth = 240;
                const cardHeight = 420;

                voidCards.forEach(cardData => {
                    const card = cards.find(c => String(c.id) === String(cardData.id));
                    if (!card) return;

                    const scale = 0.3;
                    const scaledCard = renderCard(card);
                        scaledCard.style.transform = `scale(${scale})`;
                        scaledCard.style.transformOrigin = "top left";
                        scaledCard.style.margin = "5px";
                        scaledCard.style.position = "relative";
                    scaledCard.dataset.zone = "Void";
                    attachHoverMenu(scaledCard, cardData);

                    const wrapper = document.createElement("div");
                        wrapper.style.width = `${240 * scale}px`;
                        wrapper.style.height = `${420 * scale}px`;
                        wrapper.style.overflow = "visible";
                        wrapper.style.position = "relative";

                    // Void card click overlay
                    const overlay = document.createElement("button");
                        overlay.style.position = "absolute";
                        overlay.style.top = "0";
                        overlay.style.left = "0";
                        overlay.style.width = "100%";
                        overlay.style.height = "100%";
                        overlay.style.opacity = "0";
                        overlay.style.border = "none";
                        overlay.style.background = "transparent";
                        overlay.style.cursor = "pointer";
                    overlay.onclick = () => alert(`Card in Void Clicked: ${card.name}`);

                    wrapper.appendChild(scaledCard);
                    wrapper.appendChild(overlay);

                    // Hover preview
                    wrapper.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                            scaled.innerHTML = "";
                        const preview = renderCard(card);
                            preview.style.width = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop = "7%";
                        scaled.appendChild(preview);
                    });

                    cardContainer.appendChild(wrapper);
                });
                popup.appendChild(cardContainer);
            }

            const closeBtn = document.createElement("button");
                closeBtn.textContent = "Close";
                closeBtn.style.marginTop = "10px";
                closeBtn.style.padding = "10px 20px";
                closeBtn.style.fontSize = "1.2em";
                closeBtn.style.cursor = "pointer";
                closeBtn.style.zIndex = "120000";
            closeBtn.onclick = () => popup.remove();
            popup.appendChild(closeBtn);

            document.body.appendChild(popup);
    });

    document.body.appendChild(opponentVoidButton);
    //End of Opponent Void Stack Creation

    // Opponent zones
    const oppChampionBox = document.getElementById("opponentChampionsBox");
        oppChampionBox.style.position       = "fixed";
        oppChampionBox.style.left           = "1090px";
        oppChampionBox.style.top            = "255px";
        oppChampionBox.style.width          = "525px";
        oppChampionBox.style.height         = "128px";
        oppChampionBox.style.zIndex         = "100300";
        oppChampionBox.style.pointerEvents  = "none";
        oppChampionBox.style.backgroundColor= "rgba(255,0,0,0)";
        oppChampionBox.style.display        = "flex";
        oppChampionBox.style.justifyContent = "flex-end";
        oppChampionBox.style.alignItems     = "center";
        oppChampionBox.style.transform      = "none";
        oppChampionBox.style.gap            = "0px";
        oppChampionBox.style.flexWrap       = "nowrap";

    const overlapCSS = document.createElement('style');
        overlapCSS.innerHTML = `
        #opponentChampionsBox .card {
            flex-shrink: 0 !important;
            margin-left: -195px !important;
            transform: rotate(180deg) scale(0.3) !important;
            transform-origin: center center !important;
        }
        `;
    document.head.appendChild(overlapCSS);

    const oppFaceDownBox = document.getElementById("opponentFaceDownBox");
        oppFaceDownBox.style.position = "fixed";
        oppFaceDownBox.style.left     = "1235px";
        oppFaceDownBox.style.top      = "200px";     // same top as oppChampionBox
        oppFaceDownBox.style.width    = "470px";
        oppFaceDownBox.style.height   = "128px";
        oppFaceDownBox.style.zIndex   = "100300";
        oppFaceDownBox.style.pointerEvents = "none";
        oppFaceDownBox.style.backgroundColor = "rgba(0,255,0,0)";
        oppFaceDownBox.style.display        = "flex";
        oppFaceDownBox.style.justifyContent = "flex-start";
        oppFaceDownBox.style.alignItems     = "center";
        oppFaceDownBox.style.transform      = "none";
        oppFaceDownBox.style.gap            = "0px";
        oppFaceDownBox.style.flexWrap       = "nowrap";

    const overlapOppFacedownCSS = document.createElement('style');
        overlapOppFacedownCSS.innerHTML = `
        #opponentFaceDownBox .card {
            flex-shrink: 0 !important;
            margin-left: -195px !important;
            transform: rotate(180deg) scale(0.3) !important;
            transform-origin: center center !important;
        }
        `;
    document.head.appendChild(overlapOppFacedownCSS);

    const oppArsenalBox = document.getElementById("opponentArsenalBox");
        oppArsenalBox.style.position = "fixed";
        oppArsenalBox.style.left     = "710px";
        oppArsenalBox.style.top      = "350px";     // mirror player’s arsenal top (825px → ~350px)
        oppArsenalBox.style.width    = "525px";
        oppArsenalBox.style.height   = "128px";
        oppArsenalBox.style.zIndex   = "100300";
        oppArsenalBox.style.pointerEvents = "none";
        oppArsenalBox.style.backgroundColor = "rgba(255,0,0,0)";
        oppArsenalBox.style.display        = "flex";
        oppArsenalBox.style.justifyContent = "flex-end";
        oppArsenalBox.style.alignItems     = "center";
        oppArsenalBox.style.transform      = "none";
        oppArsenalBox.style.gap            = "0px";
        oppArsenalBox.style.flexWrap       = "nowrap";

    const overlapArsenalCSS = document.createElement('style');
        overlapArsenalCSS.innerHTML = `
        #opponentArsenalBox .card {
            flex-shrink: 0 !important;
            margin-left: -195px !important;
            transform: rotate(180deg) scale(0.3) !important;
            transform-origin: center center !important;
        }
        `;
    document.head.appendChild(overlapArsenalCSS);

    const oppFaceDownArsenalBox = document.getElementById("opponentFaceDownArsenalBox");
        oppFaceDownArsenalBox.style.position = "fixed";
        oppFaceDownArsenalBox.style.left     = "1235px";
        oppFaceDownArsenalBox.style.top      = "347.5px"; // mirror facedownArsenal top :contentReference[oaicite:1]{index=1}
        oppFaceDownArsenalBox.style.width    = "565px";
        oppFaceDownArsenalBox.style.height   = "128px";
        oppFaceDownArsenalBox.style.zIndex   = "100300";
        oppFaceDownArsenalBox.style.pointerEvents = "none";
        oppFaceDownArsenalBox.style.backgroundColor = "rgba(255,0,0,0)";
        oppFaceDownArsenalBox.style.display        = "flex";
        oppFaceDownArsenalBox.style.justifyContent = "flex-start";
        oppFaceDownArsenalBox.style.alignItems     = "center";
        oppFaceDownArsenalBox.style.transform      = "none";
        oppFaceDownArsenalBox.style.gap            = "0px";
        oppFaceDownArsenalBox.style.flexWrap       = "nowrap";

    const overlapFacedownArsenalCSS = document.createElement('style');
        overlapFacedownArsenalCSS.innerHTML = `
        #opponentFaceDownArsenalBox .card {
            flex-shrink: 0 !important;
            margin-left: -195px !important;
            transform: rotate(180deg) scale(0.3) !important;
            transform-origin: center center !important;
        }
        `;
    document.head.appendChild(overlapFacedownArsenalCSS);
    // End of opponent field stuff

    // Create Surrender Button Overlay
    const surrenderButton = document.createElement("button");
        surrenderButton.style.position = "absolute";
        surrenderButton.style.left = "1758px";
        surrenderButton.style.top = "690px";
        surrenderButton.style.width = "85px";
        surrenderButton.style.height = "113px";//addBox("93%", "81%", "6%", "19%", "lightblue");  // Player Deck
        surrenderButton.style.backgroundColor = "rgba(255, 0, 0)";
        surrenderButton.style.opacity = "0";
        surrenderButton.style.border = "none";
        surrenderButton.style.zIndex = "200100";
        surrenderButton.style.cursor = "pointer";
        surrenderButton.title = "Surrender";

    // Add event listener for click
    surrenderButton.addEventListener("click", () => {
        const confirmBox = document.createElement("div");
        confirmBox.style.position = "fixed";
        confirmBox.style.top = "50%";
        confirmBox.style.left = "50%";
        confirmBox.style.transform = "translate(-50%, -50%)";
        confirmBox.style.padding = "20px";
        confirmBox.style.backgroundColor = "#333";
        confirmBox.style.color = "white";
        confirmBox.style.border = "2px solid red";
        confirmBox.style.borderRadius = "10px";
        confirmBox.style.zIndex = "100900";
        confirmBox.style.textAlign = "center";
        confirmBox.style.boxShadow = "0 0 10px black";

        confirmBox.innerHTML = `
            <p style="margin-bottom: 20px;">Are you sure you'd like to surrender?</p>
            <button id="confirm-surrender" style="margin-right: 10px;">Surrender</button>
            <button id="cancel-surrender">Cancel</button>
        `;

        document.body.appendChild(confirmBox);

        document.getElementById("confirm-surrender").onclick = async () => {
            try {
                await fetch("https://geimon-app-833627ba44e0.herokuapp.com/endGame", {
                    method: "POST",
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        gameId,
                        loser: username,
                        reason: "Surrendered"
                    })
                });

                showBanner("You Lose", "Surrendered");
                document.body.removeChild(confirmBox);
            } catch (err) {
                console.error("Error ending game:", err);
                alert("Failed to surrender. Please try again.");
            }
        };

        document.getElementById("cancel-surrender").onclick = () => {
            document.body.removeChild(confirmBox);
        };
    });

    document.body.appendChild(surrenderButton);

    const toolButtons = document.getElementById("tool-buttons");
    const lifeAdjustBox = document.getElementById("life-adjust-box");
    setTimeout(() => {
        toolButtons.style.opacity = "1";
        lifeAdjustBox.style.opacity = "1";
        playerDeckBox.style.opacity = "1";
        playerDeckBox.style.zIndex = "200000";
        playerDeckBox.style.pointerEvents = "auto";
        attachDeckHoverMenu();
    }, 6500);
    let deckCount = "Deck";

    // Ensure it exists before adding event listeners
    if (opponentDeckBox) {
        opponentDeckBox.style.display = "block";
        opponentDeckBox.style.outline = "1px solid white";
        //opponentDeckBox.style.position = "relative"; // ensure positioning context

        // Create and append a rotated inner span
        if (opponentDeckBox) {
            opponentDeckBox.style.display = "block";
            opponentDeckBox.style.outline = "1px solid white";
            //opponentDeckBox.style.position = "relative"; // makes positioning work

            // Create or reuse the inner rotated span
            let textSpan = opponentDeckBox.querySelector(".rotated-text");
            if (!textSpan) {
                textSpan = document.createElement("span");
                textSpan.className = "rotated-text";
                textSpan.innerText = "Deck";

                // Styling for top-aligned, centered, rotated text
                textSpan.style.position = "absolute";
                textSpan.style.top = "100%";
                textSpan.style.left = "50%";
                textSpan.style.transform = "translateX(-50%) rotate(180deg)";
                textSpan.style.transformOrigin = "top center";
                textSpan.style.width = "100%";
                textSpan.style.textAlign = "center";
                textSpan.style.pointerEvents = "none"; // optional: avoid blocking hover

                opponentDeckBox.innerHTML = ""; // clear anything inside
                opponentDeckBox.appendChild(textSpan);
            }

            opponentDeckBox.addEventListener("mouseenter", () => {
                const opponentName = gameState.player1 === username ? gameState.player2 : gameState.player1;
                const opponentDeck = gameState?.[opponentName]?.Deck || [];
                textSpan.innerText = `${opponentDeck.length}`;
            });

            opponentDeckBox.addEventListener("mouseleave", () => {
                textSpan.innerText = "Deck";
            });
        }
    }

    // Fetch deck count dynamically
    setTimeout(async () => {
        const urlParams = new URLSearchParams(window.location.search);
        const playerUsernameParam   = urlParams.get("playerUsername") || "";
        const opponentUsernameParam = urlParams.get("opponent")       || "";

        async function getDeckFromParam(paramName) {
            const paramValue = urlParams.get(paramName);

            // 1) If the param is already a JSON array of IDs, use it directly
            try {
            const parsed = JSON.parse(paramValue);
            if (Array.isArray(parsed)) {
                return parsed;
            }
            } catch (e) {
            // not JSON → continue to fetch by name
            }

            // 2) Decide whose deck we’re fetching
            const isOpponent = paramName === "opponentDeck";
            const owner      = isOpponent ? opponentUsernameParam : username || playerUsernameParam;

            // 3) Fetch from the server, passing the owner
            try {
            return await fetchDeckCards(paramValue, owner);
            } catch (err) {
            console.error(`Failed to load deck '${paramName}':`, err.message);
            return [];
            }
        }

        // 4) Load both decks
        const playerDeckCardIds   = await getDeckFromParam("playerDeck");
        const opponentDeckCardIds = await getDeckFromParam("opponentDeck");

        // 5) Now you can continue your setup, e.g.:
        // startGameWithDecks(playerDeckCardIds, opponentDeckCardIds);
        }, 200);


        let remainingDeck = []; // Store shuffled deck globally
        let drawnCardsArray = []; // Track drawn cards separately
        let initialDeckSize = 0; // Store starting deck size globally
        Object.defineProperty(window, 'gameState', {
            configurable: true,
            enumerable: true,
            get() {
                return window._gameState;
            },
            set(value) {
                //console.trace("🧠 gameState updated:", value);
                if (value === undefined) {
                    console.warn("⚠️ gameState was set to undefined!");
                }
                window._gameState = value;
            }
        });

        // Initialize to empty object or null to avoid undefined errors
        window._gameState = {};


        // Function to update deck text dynamically
        function updateDeckText() {
            if (deckText) {
                deckText.innerText = `Deck`; // Correct dynamic update
            }
        }

        // Function to shuffle the deck using Fisher-Yates algorithm
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        const CHAMPION_ZONE = "Zone (Champion)";
        const FACEDOWN_ZONE = "FaceDownZone";

        const ARSENAL_ZONE = "Zone (Arsenal)";
        const FACEDOWN_ARSENAL_ZONE = "FaceDownArsenalZone";

        async function renderDrawnCards() {
            if (renderingHand) return; // ✅ prevent double render
                renderingHand = true;

            try {
                const drawnCardsContainer = document.getElementById("drawn-cards");
                const scaledCardContainer = document.getElementById("scaled-card");
                const viewingWindow = document.getElementById("viewing-window");
                const contextWindow = document.getElementById("context-window");
                const playerLifeWindow = document.getElementById("player-life-window");
                const opponentLifeWindow = document.getElementById("opponent-life-window");
                const playerProfilePic = document.getElementById("player-profile-pic");
                const opponentProfilePic = document.getElementById("opponent-profile-pic");
                const phaseTracker = document.getElementById("phase-tracker");
                const turnCounter = document.getElementById("turn-counter");
                const currentPhase = gameState?.turn?.currentPhase;

                drawnCardsContainer.innerHTML = ""; // Clear previous renders

                if (drawnCardsArray.length === 0) {
                    //console.log("No cards have been drawn yet.");
                    return;
                }
                //console.log("drawnCardsArray length:", drawnCardsArray.length);

                // Sort drawn cards (optional, as you had)
                drawnCardsArray.sort((a, b) => {
                    const cardA = cards.find(c => String(c.id) === String(a.id));
                    const cardB = cards.find(c => String(c.id) === String(b.id));
                    if (!cardA || !cardB) return 0;

                    const typeOrder = ["Champion", "Action", "Equipment", "Obelisk", "Rush", "Reflex"];
                    const indexA = typeOrder.indexOf(cardA.type);
                    const indexB = typeOrder.indexOf(cardB.type);

                    if (indexA !== indexB) return indexA - indexB;
                    return cardA.name.localeCompare(cardB.name);
                });

                // --- Now render each drawn card ---
                for (const cardObj of drawnCardsArray) {
                    const card = cards.find(c => String(c.id) === String(cardObj.id));
                    if (!card) return;

                    const cardElement = renderCard(card);
                    cardElement.dataset.boardState = cardObj.boardState;
                    cardElement.dataset.lastBoardState = cardObj.lastBoardState;
                    cardElement.dataset.cardId = String(card.id); // Ensure this is set for lookup!
                    cardElement.style.transform = "scale(0.5)";
                    cardElement.style.position = "relative";
                    cardElement.style.marginLeft = "-15%";
                    cardElement.style.opacity = "1";
                    cardElement.style.transition = "opacity 1s ease-in-out";

                    // Invisible button to capture clicks
                    const cardButton = document.createElement("button");
                    cardButton.classList.add("card-button");
                    cardButton.style.position = "absolute";
                    cardButton.style.top = "0";
                    cardButton.style.right = "0";
                    cardButton.style.width = "100%";
                    cardButton.style.height = "100%";
                    cardButton.style.opacity = "0";
                    cardButton.style.background = "transparent";
                    cardButton.style.border = "none";
                    cardButton.style.pointerEvents = "auto";
                    cardButton.style.padding = "5px";
                    cardButton.style.zIndex = "100100";
                    cardButton.style.cursor = "pointer";

                    cardButton.onclick = () => {
                        const parentCard = cardButton.closest(".card");
                        const cardId = parentCard?.dataset.cardId;

                        if (!cardId) {
                            console.warn("❌ No cardId found on clicked card");
                            return;
                        }

                        const fullCard = cards.find(c => String(c.id) === String(cardId));
                        if (!fullCard) {
                            console.warn("❌ Card not found in cards array:", cardId);
                            return;
                        }
                    };

                    cardButton._originalHandler = cardButton.onclick;

                    // Hover effect for preview
                    cardElement.addEventListener("mouseenter", () => {
                        scaledCardContainer.innerHTML = "";
                        const clone = cardElement.cloneNode(true);
                        const sleeve = clone.querySelector(".sleeve-overlay");
                        if (sleeve) sleeve.remove();
                        const cloneButton = clone.querySelector(".card-button");
                        if (cloneButton) cloneButton.remove();
                        clone.style.transform = "scale(1.2)";
                        clone.style.width = "100%";
                        clone.style.position = "relative";
                        scaledCardContainer.appendChild(clone);
                        addTooltipListeners(clone);
                        addTokenTooltipListeners(clone);
                    });

                    cardElement.appendChild(cardButton);
                    drawnCardsContainer.appendChild(cardElement);
                    cardElement.dataset.zone     = cardObj.boardState;
                    cardElement.dataset.facedown = (cardObj.boardState.includes("FaceDown") || card.faceDown) ? "true" : "false";
                    attachHoverMenu(cardElement, card);

                    const fullCard = cards.find(c => String(c.id) === String(card.id));

                    // Fade in after render
                    setTimeout(() => {
                        cardElement.style.opacity = "1";
                        cardButton.style.opacity = "1";
                        cardButton.style.cursor = "pointer";
                    }, 1500);
                }

                // Fade in UI overlays
                if (window.totemFullyFaded && !window.totemFadeDoneEmitted) {
                    window.totemFadeDoneEmitted = true; // prevent multiple emits
                    setTimeout(() => {
                        viewingWindow.style.opacity = "1";
                        contextWindow.style.opacity = "1";
                        playerLifeWindow.style.opacity = "1";
                        opponentLifeWindow.style.opacity = "1";
                        phaseTracker.style.opacity = "1";
                        turnCounter.style.opacity = "1";
                    }, 0);
                    window.socket.emit("totem_fade_done", { gameId });
                }
            } finally {
                renderingHand = false;
            }
            applyHoverMenus();
        }

        async function updatePhaseDisplay(currentPhase) {
            const turnCount = gameState?.turn?.count || 0;
            const currentPlayer = gameState?.turn?.currentPlayer;
            const isPlayerTurn = currentPlayer === username;

            // Define valid transitions
            const allowedTransitions = {
                "Intermission": ["Draw"],
                "Draw": ["Main 1"],
                "Main 1": ["Battle", "End"],
                "Battle": ["Main 2"],
                "Main 2": ["End"]
            };

            document.querySelectorAll('.phase-box').forEach(box => {
                const phase = box.textContent.trim();
                box.classList.remove('active');
                if (turnCount === 1 && (phase === "Battle" || phase === "Main 2")) {
                    box.style.backgroundColor = "darkred";
                    box.style.cursor = "not-allowed";
                    return;
                }
                if (!isPlayerTurn) {
                    box.style.cursor = "not-allowed";
                    box.style.backgroundColor = "dimgray";
                    return;
                }
                const validNextPhases = allowedTransitions[currentPhase] || [];
                if (validNextPhases.includes(phase)) {
                    box.style.cursor = "pointer";
                    box.style.backgroundColor = "lightgray";
                } else {
                    box.style.cursor = "not-allowed";
                    box.style.backgroundColor = "dimgray";
                }
            });

            const activeBox = document.getElementById(`phase-${currentPhase}`);
            if (activeBox) {
                activeBox.classList.add('active');
                activeBox.style.backgroundColor = "lightgreen";
            }

            const turnNum = gameState.turn?.count;

            if (
                currentPhase === "Intermission" &&
                isPlayerTurn &&
                turnNum !== lastLoggedIntermissionTurn
            ) {
                addGameLogEntry(`${username}'s turn. Turn #${turnNum}`);
                addGameLogEntry(`${username} changed phase to Intermission`);
                lastLoggedIntermissionTurn = turnNum; // ✅ Prevent duplicate logs
                if (gameState[username]) {
                    gameState[username].hasBasicRallied = false;
                    await fetch("https://geimon-app-833627ba44e0.herokuapp.com/updateGameState", {
                        method: "POST",
                        credentials: "include",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            gameId,
                            owner: username,
                            updatedZones: {
                                hasBasicRallied: false
                            }
                        })
                    });
                    //console.log("🔄 Reset hasBasicRallied for", username);
                }
            }
            if (currentPhase === "Main 1" || currentPhase === "Main 2") {
                renderDrawnCards();
            }
        }

        async function sendZoneUpdate(zones) {
            const updatedZones = {};
            zones.forEach(z => updatedZones[z] = gameState[username][z]);
            //console.log("🔧 sendZoneUpdate ▶ payload:", updatedZones);

            const res = await fetch(`${serverUrl}/updateGameState`, {
                method: "POST",
                credentials: "include",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ gameId, owner: username, updatedZones })
            });

            const data = await res.json();
            //console.log("📜 sendZoneUpdate ◀ response:", data);

            // merge server copy back into local
            if (data.updatedPlayerZone) {
                gameState[username] = data.updatedPlayerZone;
                //console.log("🔄 state synced → Arsenal:", gameState[username]["Zone (Arsenal)"].map(c=>c.id), "Tomb:", gameState[username].Tomb.map(c=>c.id));
            }

            return data;
        }

        function updateCounterOverlay(cardElement, cardData) {
            // 1️⃣  normalise the backing number
            if (typeof cardData.counters !== "number") cardData.counters = 0;

            // 2️⃣  find or create the overlay badge
            let badge = cardElement.querySelector(".counter-overlay");
            if (!badge && cardData.counters > 0) {
                badge = document.createElement("div");
                badge.className = "counter-overlay";
                Object.assign(badge.style, {
                position:       "absolute",
                top:            "50%",
                left:           "50%",
                transform:      "translate(-50%, -50%)",
                width:          "64px",
                height:         "64px",
                borderRadius:   "50%",
                background:     "#000",
                color:          "#fff",
                fontSize:       "2.6em",
                fontWeight:     "600",
                display:        "flex",
                alignItems:     "center",
                justifyContent: "center",
                pointerEvents:  "none",
                zIndex:         "125000"
                });
                cardElement.appendChild(badge);
            }

            // 3️⃣  update or remove it
            if (badge) {
                if (cardData.counters > 0) {
                badge.textContent = cardData.counters;
                } else {
                badge.remove();
                }
            }
        }

        /* show a small modal, update cardData + DOM on “Save” */
        function showChangeStatsPrompt(cardElement, cardData) {
            // ── overlay ─────────────────────────────────────────────────
            const overlay = document.createElement("div");
            Object.assign(overlay.style, {
                position: "fixed", inset: 0, background: "rgba(0,0,0,.6)",
                display: "flex", alignItems: "center", justifyContent: "center",
                zIndex: 200000
            });

            // ── popup panel ─────────────────────────────────────────────
            const panel = document.createElement("div");
            panel.style.cssText =
                "background:#222;color:#fff;padding:20px 24px;border-radius:8px;" +
                "box-shadow:0 0 10px #000;font-size:18px;width:260px;text-align:center";

            panel.innerHTML = `
                <h3 style="margin-top:0;font-size:1.1em">Change Stats</h3>
                <label>Damage<br>
                <input id="dmg" type="number" min="0" step="1"
                        style="width:70px" value="${cardData.damage}">
                </label><br><br>
                <label>Life<br>
                <input id="life" type="number" min="0" step="1"
                        style="width:70px" value="${cardData.life}">
                </label><br><br>
                <label>Threshold<br>
                <input id="th" type="number" min="0" step="1"
                        style="width:70px" value="${cardData.damageThreshold}">
                </label><br><br>
                <button id="saveStats" style="margin-right:10px">Save</button>
                <button id="cancelStats">Cancel</button>
            `;
            overlay.appendChild(panel);
            document.body.appendChild(overlay);

            // helper: refresh the numbers shown on the visible card
            function refreshCardFace(cardEl, card) {
                const dmg  = cardEl.querySelector(".damage");
                const life = cardEl.querySelector(".life");
                let  thr   = cardEl.querySelector(".damageThreshold");

                if (!thr) {
                    // card was rendered before the always-show change → build the cell now
                    thr = document.createElement("div");
                    thr.className = "damageThreshold";
                    cardEl.querySelector(".bottom-bar").appendChild(thr);
                }

                if (dmg)  dmg.textContent  = card.damage;
                if (life) life.textContent = card.life;
                thr.textContent = card.damageThreshold;   // card.threshold if you renamed it
            }

            // ── button wiring ───────────────────────────────────────────
            panel.querySelector("#saveStats").onclick = () => {
                cardData.damage           = +panel.querySelector("#dmg").value || 0;
                cardData.life             = +panel.querySelector("#life").value || 0;
                cardData.damageThreshold  = +panel.querySelector("#th").value || 0;
                refreshCardFace(cardElement, cardData);
                addGameLogEntry(
                `${cardData.name}'s stats set to ` +
                `${cardData.damage}/${cardData.life} (${cardData.damageThreshold}).`);
                overlay.remove();
            };

            panel.querySelector("#cancelStats").onclick = () => overlay.remove();
        }

        function getOpponentUsername(username, gameState) {
            return Object.keys(gameState).find(name => name !== username);
        }

        async function animateBlock(cardElement, isFaceDown = false) {
            // Capture original transform (style or computed)
            const computedStyle = window.getComputedStyle(cardElement);
            const originalTransform = computedStyle.transform === 'none' ? '' : computedStyle.transform;

            // Calculate deltas to move card to center
            const rect = cardElement.getBoundingClientRect();
            const deltaX = window.innerWidth/2 - (rect.left + rect.width/2);
            const deltaY = window.innerHeight/2 - (rect.top + rect.height/2);

            // Build the transform strings
            const move = isFaceDown ? `translate(${deltaX*0.9}px, ${-deltaY*20}px)` : `translate(${deltaX*5}px, ${deltaY*3}px)`;
            const rotate = isFaceDown ? `` : ` rotate(90deg)`;
            const targetTransform = `${originalTransform} ${move}${rotate}`.trim();

            // Animate to center (and rotate if not face-down)
            cardElement.style.transition = 'transform 0.3s ease-in-out';
            cardElement.style.transform = targetTransform;
            await new Promise(res => setTimeout(res, 400));

            // Animate back to original
            cardElement.style.transition = 'transform 0.3s ease-in-out';
            cardElement.style.transform = originalTransform;
            await new Promise(res => setTimeout(res, 400));

            // Cleanup transition property
            cardElement.style.transition = '';
        }

        /**
         * Turn the TOP of the card to face the viewport center,
         * move it straight in, then return—while preserving ANY existing transforms.
         */
        function animateAttackToCenter(cardEl, duration = 800) {
            // 1) Remember any inline transform you’d set before
            const origInline = cardEl.style.transform || '';

            // 2) Grab the true “start” matrix (including CSS rules, scale, etc.)
            const cs = getComputedStyle(cardEl).transform;
            const startMatrix = (cs === 'none') ? '' : cs;

            // 3) Figure out where “center of viewport” is relative to the card’s center
            const r  = cardEl.getBoundingClientRect();
            const cx = r.left + r.width  / 2;
            const cy = r.top  + r.height / 2;
            const vx = window.innerWidth  / 2;
            const vy = window.innerHeight / 2;
            const dx = vx - cx;
            const dy = vy - cy;

            // 4) Compute the angle so the TOP edge points at (dx,dy)
            //    atan2(dy,dx) = angle of that vector; +90° makes the top face it
            const angle = Math.atan2(dy, dx) * 180/Math.PI + 90;

            // 5) Build our “pivot” translations
            const px = r.width  / 2;  // bottom-center X in local coords
            const py = r.height;      // bottom-center Y
            const toPivot   = `translate(${ px * 20 }px, ${ -px * 10 }px)`;
            const fromPivot = `translate(${-px }px, ${-py }px)`;

            // 6) Keyframes: start → tilt only → tilt+move → back
            const kf = [
                { transform: startMatrix },
                { transform: `${startMatrix} ${toPivot} rotate(${angle}deg) ${fromPivot}` },
                { transform: `${startMatrix} ${toPivot} rotate(${angle}deg) ${fromPivot} translate(${dx}px, ${dy}px)` },
                { transform: startMatrix }
            ];

            // 7) Fire it with the Web Animations API
            const anim = cardEl.animate(kf, {
                duration,
                easing:   'ease-in-out',
                fill:     'forwards'
            });

            // 8) When done, restore your original inline transform
            anim.finished.then(() => {
                cardEl.style.transform = origInline;
            });

            return anim;
        }

        async function attachHoverMenu(cardElement, cardData) {
            // don’t re-attach if already done
            if (cardElement.dataset.hoverMenuAttached) return;
            cardElement.dataset.hoverMenuAttached = "true";
            cardElement.style.position = "relative";

            // ─── helper to move card in state + UI + server ───────────────────────────
            async function doMove(fromZone, toZoneKey, containerId, faceDown, placeOnTop = false) {
                // 0) Update local gameState arrays
                const zoneArr = gameState[username][fromZone];
                const idx     = zoneArr.findIndex(c => String(c.id) === String(cardData.id));
                if (idx < 0) return;
                const [moved] = zoneArr.splice(idx, 1);
                moved.boardState = toZoneKey;
                moved.faceDown   = faceDown;
                const targetArr = gameState[username][toZoneKey];
                if (toZoneKey === "Deck" && placeOnTop) {
                    targetArr.unshift(moved);
                } else {
                    targetArr.push(moved);
                }

                const container = document.getElementById(containerId);
                if (toZoneKey !== "Deck") {
                const container = document.getElementById(containerId);
                if (toZoneKey === "Deck" && placeOnTop) {
                    // never, because Deck is skipped
                    container.prepend(cardElement);
                } else {
                    container.appendChild(cardElement);
                }
                }
                cardElement.dataset.zone     = toZoneKey;
                cardElement.dataset.facedown = faceDown ? "true" : "false";

                const oldMenu = cardElement.querySelector(".hover-menu");
                if (oldMenu) oldMenu.remove();               // throw away the Hand menu
                delete cardElement.dataset.hoverMenuAttached; // let attachHoverMenu run again
                attachHoverMenu(cardElement, moved);         // moved == card’s live data object

                // 2) Apply visual transforms
                //    always shrink
                const transforms = ["scale(0.3)"];
                if (
                    !faceDown ||               // we’re no longer face-down
                    (containerId !== "playerFaceDownBox" &&
                    containerId !== "playerFaceDownArsenalBox")
                ) {
                    const straySleeve = cardElement.querySelector(".sleeve-overlay");
                    if (straySleeve) straySleeve.remove();
                }
                //    if facedown-champion, also rotate + sleeve overlay
                if (containerId === "playerFaceDownBox") {
                    transforms.push("rotate(90deg)");

                    // remove any previous sleeve overlay
                    const oldSleeve = cardElement.querySelector(".sleeve-overlay");
                    if (oldSleeve) oldSleeve.remove();

                    // add one sleeve overlay
                    const sleeve = document.createElement("img");
                    sleeve.src       = userSleeveURL;
                    sleeve.className = "sleeve-overlay";
                    Object.assign(sleeve.style, {
                        position:        "absolute",
                        top:             "0",
                        left:            "0",
                        width:           "260px",
                        height:          "420px",
                        transform:       "rotate(180deg)",
                        transformOrigin: "center center",
                        pointerEvents:   "none",
                        zIndex:          "110000",
                    });
                    cardElement.appendChild(sleeve);
                } if (containerId === "playerFaceDownArsenalBox") {
                    const oldSleeve = cardElement.querySelector(".sleeve-overlay");
                    if (oldSleeve) oldSleeve.remove();

                    // add one sleeve overlay
                    const sleeve = document.createElement("img");
                    sleeve.src       = userSleeveURL;
                    sleeve.className = "sleeve-overlay";
                    Object.assign(sleeve.style, {
                        position:        "absolute",
                        top:             "0",
                        left:            "0",
                        width:           "260px",
                        height:          "420px",
                        transformOrigin: "center center",
                        pointerEvents:   "none",
                        zIndex:          "110000",
                    });
                    cardElement.appendChild(sleeve);
                } if (containerId === "playerReserveBox") {
                    transforms.push("scale(0.3)");
                }

                cardElement.style.transform       = transforms.join(" ");
                cardElement.style.transformOrigin = "center center";
                cardElement.style.marginLeft = "";

                // 3) Persist change to server
                await sendZoneUpdate([fromZone, toZoneKey]);
                const mainZones = [
                  { name: "Zone (Champion)",         container: "playerChampionsBox"       },
                  { name: "FaceDownZone",            container: "playerFaceDownBox"        },
                  { name: "Zone (Arsenal)",          container: "playerArsenalBox"         },
                  { name: "FaceDownArsenalZone",     container: "playerFaceDownArsenalBox" },
                  { name: "Reserve",                 container: "playerReserveBox"         },
                ];
                mainZones.forEach(({ name, container }) => {
                  if (fromZone === name || toZoneKey === name) {
                    renderCardZone(gameState[username][name], container);
                  }
                });

                // 4) Re-render zones so spacing/layout updates
                renderDrawnCards();
                renderLatestTombCard();
                renderLatestVoidCard();
            }
            // ────────────────────────────────────────────────────────────────────────────

            const zone = cardElement.dataset.zone;
            const isFaceDown = (zone === "FaceDownZone");

            // build the hover menu
            const hoverMenu = document.createElement("div");
            hoverMenu.className = "hover-menu";
            Object.assign(hoverMenu.style, {
                position:       "absolute",
                bottom:         "100%",
                left:           "50%",
                transform:      "translateX(-50%) scale(1)",
                marginBottom:   "0em",
                backgroundColor:"#111",
                color:          "white",
                border:         "1px solid #ccc",
                padding:        "6px",
                display:        "none",
                zIndex:         "150000",
                flexDirection:  "column",
                fontSize:       "2em",
                whiteSpace:     "nowrap",
                boxShadow:      "0 0 5px black",

                // position + transform: choose based on face-down
                bottom:   isFaceDown ? ""       : "100%",
                left:     isFaceDown ? ""       : "50%",
                top:      isFaceDown ? "50%"    : "",
                right:    isFaceDown ? "100%"   : "",
                transform: isFaceDown
                    ? "translateY(-50%) scale(1) rotate(-90deg)"
                    : "translateX(-50%) scale(1)",
                marginBottom:   "0em",
            });

            // decide options based on current zone
            let opts = [];

            if (zone === "Hand") {
                opts = [
                "Change Control","Reveal","Declare",
                "To Champion (Face-Up)","To Champion (Face-Down)",
                "To Arsenal (Face-Up)","To Arsenal (Face-Down)",
                "To Reserve","To Tomb","To Void",
                "To Top of Deck","To Bottom of Deck"
                ];
            } else if (zone === "Tomb" || zone === "Void") {
                hoverMenu.style.fontSize = "3em";
                opts = [
                    zone === "Tomb" ? "To Void" : "To Tomb",
                    "To Hand",
                    "To Top of Deck",
                    "To Bottom of Deck",
                    "To Reserve",
                    "To Champion (Face-Up)",
                    "To Champion (Face-Down)",
                    "To Arsenal (Face-Up)",
                    "To Arsenal (Face-Down)",
                    "Declare"
                ];
            } else if (zone === "Deck") {
                hoverMenu.style.fontSize = "3.5em";
                opts = [
                    "To Hand",
                    "To Tomb",
                    "To Void",
                    "To Top of Deck",
                    "To Bottom of Deck",
                    "To Reserve",
                    "To Champion (Face-Up)",
                    "To Champion (Face-Down)",
                    "To Arsenal (Face-Up)",
                    "To Arsenal (Face-Down)"
                ];
            } else if (zone === "Zone (Champion)") {
                hoverMenu.style.fontSize = "3.5em";
                opts = [
                    "Change Control",
                    "Add 1 Counter",
                    "Add 5 Counters",
                    "Remove 1 Counter",
                    "Remove All Counters",
                    "To Hand",
                    "To Tomb",
                    "To Void",
                    "To Top of Deck",
                    "To Bottom of Deck",
                    "To Reserve",
                    "To Champion (Face-Down)",
                    "To Arsenal (Face-Up)",
                    "To Arsenal (Face-Down)",
                    "Change Stats",
                    "Declare",
                    "Attack",
                    "Block"
                ];
            } else if (zone === "Zone (Arsenal)") {
                hoverMenu.style.fontSize = "3.5em";
                opts = [
                    "Change Control",
                    "Add 1 Counter",
                    "Add 5 Counters",
                    "Remove 1 Counter",
                    "Remove All Counters",
                    "To Hand",
                    "To Tomb",
                    "To Void",
                    "To Top of Deck",
                    "To Bottom of Deck",
                    "To Reserve",
                    "To Champion (Face-Up)",
                    "To Champion (Face-Down)",
                    "To Arsenal (Face-Down)",
                    "Declare"
                ];
            } else if (zone === "Reserve") {
                hoverMenu.style.fontSize = "3.5em";
                opts = [
                    "Change Control",
                    "Add 1 Counter",
                    "Add 5 Counters",
                    "Remove 1 Counter",
                    "Remove All Counters",
                    "To Hand",
                    "To Tomb",
                    "To Void",
                    "To Top of Deck",
                    "To Bottom of Deck",
                    "To Champion (Face-Up)",
                    "To Champion (Face-Down)",
                    "To Arsenal (Face-Up)",
                    "To Arsenal (Face-Down)",
                    "Declare"
                ];
            } else if (zone === "FaceDownZone") {
                hoverMenu.style.fontSize = "3.5em";
                opts = [
                    "Change Control",
                    "To Hand",
                    "To Tomb",
                    "To Void",
                    "To Top of Deck",
                    "To Bottom of Deck",
                    "To Reserve",
                    "To Champion (Face-Up)",
                    "To Arsenal (Face-Up)",
                    "To Arsenal (Face-Down)",
                    "Block"
                ];
            } else if (zone === "FaceDownArsenalZone") {
                hoverMenu.style.fontSize = "3.5em";
                opts = [
                    "Change Control",
                    "To Hand",
                    "To Tomb",
                    "To Void",
                    "To Top of Deck",
                    "To Bottom of Deck",
                    "To Reserve",
                    "To Champion (Face-Up)",
                    "To Champion (Face-Down)",
                    "To Arsenal (Face-Up)"
                ];
            }

            // populate buttons
            opts.forEach(text => {
                const btn = document.createElement("div");
                btn.textContent = text;
                Object.assign(btn.style, { padding:"2px 5px", cursor:"pointer" });
                btn.addEventListener("click", async e => {
                e.stopPropagation();
                hoverMenu.style.display = "none";
                switch (text) {
                    case "To Champion (Face-Up)":
                        await doMove(zone,           "Zone (Champion)",         "playerChampionsBox",        false);
                        break;
                    case "To Champion (Face-Down)":
                        await doMove(zone,           "FaceDownZone",            "playerFaceDownBox",         true);
                        break;
                    case "To Arsenal (Face-Up)":
                        await doMove(zone,           "Zone (Arsenal)",          "playerArsenalBox",          false);
                        break;
                    case "To Arsenal (Face-Down)":
                        await doMove(zone,           "FaceDownArsenalZone",     "playerFaceDownArsenalBox",  true);
                        break;
                    case "To Reserve":
                        await doMove(zone, "Reserve", "playerReserveBox", false);
                        break;
                    case "To Hand":
                        await doMove(zone, "Hand", "drawn-cards", false);
                        break;
                    case "To Tomb":
                        await doMove(zone, "Tomb", "playerTombBox", false);
                        break;
                    case "To Void":
                        await doMove(zone, "Void", "playerVoidBox", false);
                        break;
                    case "To Top of Deck":
                        await doMove(zone, "Deck", "playerDeckBox", false, true);
                        break;
                    case "To Bottom of Deck":
                        await doMove(zone, "Deck", "playerDeckBox", false, false);
                        break;
                    case "Declare":
                        addGameLogEntry(`${cardData.name}'s effect was declared from the ${zone}.`);
                        break;
                    case "Reveal":
                        addGameLogEntry(`${cardData.name} was revealed from the ${zone}.`);
                        break;
                    case "Change Stats":
                        showChangeStatsPrompt(cardElement, cardData);
                        break;
                    case "Change Control": {
                        const owner      = username;
                        const opponent   = getOpponentUsername(username, gameState);
                        const srcZone    = zone;                 // where the card is now
                        const destZone   = srcZone;              // same zone name on opp. side

                        /* 1️⃣  Move the data object between player arrays */
                        const srcArr  = gameState[owner][srcZone];
                        const idx     = srcArr.findIndex(c => String(c.id) === String(cardData.id));
                        if (idx === -1) { console.warn("Card not found in source zone"); break; }
                        const [moved] = srcArr.splice(idx, 1);
                        gameState[opponent][destZone].push(moved);

                        /* 2️⃣  Figure out the proper container ID on the opponent’s board */
                        const containerMap = {
                            "Zone (Champion)":         "opponentChampionsBox",
                            "Zone (Arsenal)":          "opponentArsenalBox",
                            "Reserve":                 "opponentReserveBox",
                            "FaceDownZone":            "opponentFaceDownBox",
                            "FaceDownArsenalZone":     "opponentFaceDownArsenalBox",
                            "Tomb":                    "opponentTombBox",
                            "Void":                    "opponentVoidBox",
                            "Deck":                    "opponentDeckBox"       // rare but legal
                        };
                        const oppContainerId = containerMap[srcZone];
                        if (!oppContainerId) {
                            console.warn("No opponent container mapped for", srcZone);
                            break;
                        }

                        /* 3️⃣  Park the DOM element in that container */
                        const oppContainer = document.getElementById(oppContainerId);
                        if (oppContainer) oppContainer.appendChild(cardElement);

                        /* 4️⃣  Clean old menu + attach a fresh one for the new controller */
                        const oldMenu = cardElement.querySelector(".hover-menu");
                        if (oldMenu) oldMenu.remove();
                        delete cardElement.dataset.hoverMenuAttached;
                        cardElement.dataset.zone = destZone;
                        attachHoverMenu(cardElement, moved);     // menu now shows *their* options

                        /* 5️⃣  Persist & log */
                        await sendZoneUpdate([srcZone, destZone]);
                        addGameLogEntry(`${cardData.name} changes control to the opponent.`);

                        break;
                    }
                    case "Attack": {
                        animateAttackToCenter(cardElement, 800)
                            .finished.then(() => {
                            addGameLogEntry(`${cardData.name} declared an attack.`);
                            });
                        break;
                    }
                    case "Block": {
                        // Determine if blocking from face-down zone
                        const isFaceDown = cardData.boardState === 'FaceDownZone';
                        await animateBlock(cardElement, isFaceDown);

                        addGameLogEntry(`${cardData.name} was declared as a blocker.`);
                        break;
                    }
                    case "Add 1 Counter": {
                        cardData.counters = (cardData.counters || 0) + 1;
                        updateCounterOverlay(cardElement, cardData);
                        addGameLogEntry(`${cardData.name} gains 1 counter (now ${cardData.counters}).`);
                        break;
                    }
                    case "Add 5 Counters": {
                        cardData.counters = (cardData.counters || 0) + 5;
                        updateCounterOverlay(cardElement, cardData);
                        addGameLogEntry(`${cardData.name} gains 5 counters (now ${cardData.counters}).`);
                        break;
                    }
                    case "Remove 1 Counter": {
                        cardData.counters = Math.max(0, (cardData.counters || 0) - 1);
                        updateCounterOverlay(cardElement, cardData);
                        addGameLogEntry(`${cardData.name} loses 1 counter (now ${cardData.counters}).`);
                        break;
                    }
                    case "Remove All Counters": {
                        cardData.counters = 0;
                        updateCounterOverlay(cardElement, cardData);
                        addGameLogEntry(`${cardData.name} loses all counters.`);
                        break;
                    }
                    default:
                        console.warn("Unhandled action:", text);
                }
                });
                btn.addEventListener("mouseenter", () => btn.style.background = "#333");
                btn.addEventListener("mouseleave", () => btn.style.background = "transparent");
                hoverMenu.appendChild(btn);
            });

            cardElement.appendChild(hoverMenu);

            Object.assign(hoverMenu.style, {
                transform:  isFaceDown
                    ? "translateX(10px) translateY(-50%) rotate(-90deg)"
                    : "translate(-50%, 10px)",
                opacity:    "0",
                transition: "transform 150ms ease, opacity 150ms ease"
            });

            let hideTimer;

            function showMenu() {
                clearTimeout(hideTimer);
                cardElement.style.zIndex = "120000";
                hoverMenu.style.display = "flex";

                // force initial state
                void hoverMenu.offsetWidth;
                if (isFaceDown) {
                    hoverMenu.style.transform = "translateX(0) translateY(-50%) rotate(-90deg)";
                    hoverMenu.style.opacity   = "1";
                } else {
                    hoverMenu.style.transform = "translate(-50%, 0)";
                    hoverMenu.style.opacity   = "1";
                }
            }

            // 5) hide menu
            function hideMenu() {
                if (isFaceDown) {
                    hoverMenu.style.transform = "translateX(10px) translateY(-50%) rotate(-90deg)";
                } else {
                    hoverMenu.style.transform = "translate(-50%, 10px)";
                }
                hoverMenu.style.opacity = "0";
                setTimeout(() => {
                    hoverMenu.style.display   = "none";
                    cardElement.style.zIndex  = "";
                }, 150);
            }

            // 6) event wiring
            cardElement.addEventListener("mouseenter", showMenu);
            cardElement.addEventListener("mouseleave", () => hideTimer = setTimeout(hideMenu, 150));
            hoverMenu.addEventListener("mouseenter", () => clearTimeout(hideTimer));
            hoverMenu.addEventListener("mouseleave", hideMenu);
        }

        function applyHoverMenus() {
            document.querySelectorAll('.card').forEach(el => {
                const cardData = el._card || { name: el.dataset.zone };
                attachHoverMenu(el, cardData);
            });
        }

        function changeLife(player, amount, gameState, username, gameId) {
            if (!gameState[player]) return;

            if (gameState.invertHealingAndDamage) {
                amount = -amount;
            }

            const originalLife = gameState[player].life;
            let newLife = originalLife + amount;
            if (newLife < 0) newLife = 0;

            gameState[player].life = newLife;

            const isSelf = player === username;
            const lifeElem = document.getElementById(isSelf ? "player-life" : "opponent-life");
            const screenHalf = document.getElementById(isSelf ? "player-side" : "opponent-side");

            if (lifeElem && screenHalf) {
                animateLifeNumber(lifeElem, originalLife, newLife);

                const flash = document.createElement("div");
                flash.className = `life-flash ${amount > 0 ? "heal" : "damage"} ${isSelf ? "bottom" : "top"}`;
                screenHalf.appendChild(flash);

                setTimeout(() => flash.classList.add("active"), 10);
                setTimeout(() => flash.remove(), 700);
            }

            sendLifeUpdate(gameId, gameState, player);

            if (newLife <= 0) {
                // Dispatch a custom event to trigger game loss
                document.dispatchEvent(new CustomEvent("playerLifeReachedZero", {
                    detail: { player }
                }));
            }

            // Return true if this reduced the player's life to 0
            return newLife <= 0;
        }

        function animateLifeNumber(element, start, end) {
            const duration = 500;
            const stepTime = 30;
            const steps = Math.floor(duration / stepTime);
            let currentStep = 0;

            const step = () => {
                currentStep++;
                const progress = currentStep / steps;
                const value = Math.round(start + (end - start) * progress);
                element.textContent = value;

                if (currentStep < steps) {
                    setTimeout(step, stepTime);
                } else {
                    element.textContent = end;
                }
            };
            step();
        }

        async function sendLifeUpdate(gameId, gameState, player) {
            await fetch('https://geimon-app-833627ba44e0.herokuapp.com/updateGameState', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    gameId,
                    updatedZones: {
                        life: gameState[player].life
                    },
                    owner: player
                })
            });
        }

        document.getElementById('confirm-life-change').addEventListener('click', () => {
            const amt = parseInt(document.getElementById('life-amount').value, 10);
            if (isNaN(amt) || amt <= 0) return alert('Enter a positive number');
            const increase = document.getElementById('increase-life').classList.contains('active');

            changeLife(
                username,
                increase ? amt : -amt,
                gameState,
                username,
                gameId
            );

            document.getElementById('life-amount').value = '';
        });

        document.querySelectorAll('#increase-life, #decrease-life').forEach(btn => {
            btn.addEventListener('click', () => {
                document.getElementById('increase-life').classList.remove('active');
                document.getElementById('decrease-life').classList.remove('active');
                btn.classList.add('active');
            });
        });

        async function attachDeckHoverMenu() {
            const deckBox = document.getElementById("playerDeckBox");
                deckBox.style.position = "relative";
                deckBox.style.zIndex   = "200000";
                deckBox.style.overflow       = "visible";
                deckBox.style.pointerEvents  = "auto";

            if (!deckBox) {
                console.error("   ❌ No #playerDeckBox in DOM");
                return;
            }

            if (deckBox.dataset.hoverMenuAttached) {
                console.log("   ℹ️ hover menu already attached, bailing");
                return;
            }
            deckBox.dataset.hoverMenuAttached = "true";

            const menu = document.createElement("div");
            menu.className = "hover-menu";
            Object.assign(menu.style, {
                position:       "fixed",
                display:        "none",
                backgroundColor:"#111",
                color:          "white",
                border:         "1px solid #ccc",
                padding:        "6px",
                zIndex:         "300000",
                flexDirection:  "column",
                fontSize:       "0.8em",
                whiteSpace:     "nowrap",
                boxShadow:      "0 0 5px black",
                pointerEvents:  "auto"
            });

            const options = [
                "Mill",
                "Obliterate Mill",
                "View",
                "Shuffle",
                "Draw"
            ];

            options.forEach(text => {
                const btn = document.createElement("div");
                btn.textContent = text;
                Object.assign(btn.style, { padding:"2px 5px", cursor:"pointer" });

                btn.addEventListener("click", async e => {
                e.stopPropagation();
                menu.style.display = "none";

                switch (text) {
                    case "Shuffle":
                        animateDeckShuffle();
                        // Fisher–Yates shuffle (exists in your code)
                        shuffleDeck(gameState[username].Deck);
                        await sendZoneUpdate(["Deck"]);       // persist new deck order
                        updateDeckText();                     // update count display
                        addGameLogEntry(`${username} shuffled their deck.`);
                        break;

                    case "Draw":
                        // use your drawCards helper :contentReference[oaicite:2]{index=2}
                        await drawCards(gameState[username].Deck, 1);
                        break;

                    case "Mill":
                    if (gameState[username].Deck.length === 0) return;
                    {
                        const [card] = gameState[username].Deck.splice(0,1);
                        card.boardState = "Tomb";
                        gameState[username].Tomb.push(card);
                        await sendZoneUpdate(["Deck","Tomb"]);updateDeckText
                        renderLatestTombCard();
                        updateDeckText();
                        addGameLogEntry(`${username} milled the top card of their deck.`);
                    }
                    break;

                    case "Obliterate Mill":
                    if (gameState[username].Deck.length === 0) return;
                    {
                        const [card] = gameState[username].Deck.splice(0,1);
                        card.boardState = "Void";
                        gameState[username].Void.push(card);
                        await sendZoneUpdate(["Deck","Void"]);
                        renderLatestVoidCard();
                        updateDeckText();
                        addGameLogEntry(`${username} obliterated the top card of their deck.`);
                    }
                    break;

                    case "View":
                    // build a modal overlay
                    const overlay = document.createElement("div");
                    Object.assign(overlay.style, {
                        position:        "fixed",
                        top:             "45%",
                        left:            "50%",
                        transform:       "translate(-50%, -50%)",
                        width:           "60vw",
                        height:          "80vh",
                        padding:         "0px 0px 0px",
                        backgroundColor: "rgba(0, 0, 0, 0.85)",
                        border:          "3px solid white",
                        borderRadius:    "12px",
                        zIndex:          "300000",
                        overflow:        "visible"
                    });

                    const scrollArea = document.createElement("div");
                    Object.assign(scrollArea.style, {
                        position:       "absolute",
                        top:            "0",
                        left:           "0",
                        width:          "100%",
                        height:         "calc(100% - 60px)",
                        overflowY:     "visible",
                        display:       "grid",
                        gridTemplateColumns: "repeat(auto-fill, minmax(85px, 1fr))",
                        gridAutoRows:        "135px",
                        rowGap:              "4px",
                        columnGap:     "4px",
                        justifyContent:"start",
                        alignItems:    "start",
                        padding:       "16px",
                    });
                    // add each deck card at 1/3 scale
                    gameState[username].Deck.forEach(cardObj => {
                        const card = cards.find(c => String(c.id) === String(cardObj.id));
                        const el = renderCard(card);
                            el.style.transform = "scale(0.28)";
                            el.style.transformOrigin  = "top left";
                            el.style.margin = "0px";
                            el.style.padding = "0";
                            el.style.pointerEvents = "auto";
                        el.dataset.zone = "Deck";
                        attachHoverMenu(el, card);
                        // highlight on hover
                        el.addEventListener("mouseenter", () => {
                            // clear out previous preview
                            const scaled = document.getElementById("scaled-card");
                            scaled.innerHTML = "";

                            // render full-size clone
                            const big = renderCard(card);
                                big.style.marginLeft = "-62px";
                                big.style.marginTop = "-27px";
                                big.style.transform     = "scale(1.2)";
                                big.style.transformOrigin = "top left";
                                big.style.pointerEvents = "none";

                            scaled.appendChild(big);
                        });
                        el.addEventListener("mouseleave", () => el.style.boxShadow = "none");
                        scrollArea.appendChild(el);
                    });

                    overlay.appendChild(scrollArea);

                    const btnContainer = document.createElement("div");
                    Object.assign(btnContainer.style, {
                        position:        "absolute",
                        bottom:          "10px",    // 10px above the overlay’s bottom edge
                        left:            "50%",
                        transform:       "translateX(-50%)",
                        zIndex:          "300001",  // just above the overlay content
                    });

                    // close button
                    const closeBtn = document.createElement("button");
                    closeBtn.textContent = "Close";
                    Object.assign(closeBtn.style, {
                        position:        "fixed",
                        bottom:          "20px",
                        left:            "50%",
                        transform:       "translateX(-50%)",
                        padding:         "8px 16px",
                        fontSize:        "1em",
                        zIndex:          "4000",
                        cursor:          "pointer",
                    });
                    closeBtn.onclick = () => overlay.remove();
                    overlay.appendChild(closeBtn);
                    overlay.appendChild(btnContainer);

                    document.body.appendChild(overlay);
                    break;
                }
                });

                btn.addEventListener("mouseenter", () => btn.style.background = "#333");
                btn.addEventListener("mouseleave", () => btn.style.background = "transparent");
                menu.appendChild(btn);
            });

            deckBox.appendChild(menu);

            //console.log("deckText exists?", !!document.getElementById("deckText"));
            deckBox.addEventListener("mouseenter", () => {
                document.getElementById("deckText").textContent = `${remainingDeck.length}`;
                const rect = deckBox.getBoundingClientRect();
                menu.style.left = `${rect.left + rect.width/2}px`;
                menu.style.top  = `${rect.top}px`;
                menu.style.transform = "translate(-50%, -100%)";
                menu.style.display = "flex";
            });
            deckBox.addEventListener("mouseleave", () => {
                document.getElementById("deckText").textContent = "Deck";
                menu.style.display = "none";
            });
        }

        async function renderCardZone(cardsArray, containerId) {
            const container = document.getElementById(containerId);
                container.style.gap = containerId === "playerFaceDownBox" ? "75px" : "4px";
                container.style.gap = containerId === "playerFaceDownArsenalBox" ? "25px" : "4px";
            if (!container) return;

            container.innerHTML = ""; // Clear previous

            if (!cardsArray || cardsArray.length === 0) return;

            const half = Math.floor(cardsArray.length / 2);
            const ordered = [];

            for (let i = 0; i < cardsArray.length; i++) {
                const offset = i % 2 === 0 ? i / 2 : -(Math.ceil(i / 2));
                ordered.push(cardsArray[half + offset] || cardsArray[half - offset]);
            }

            if (!userSleeveURL) {
                userSleeveURL = await fetchUserData();
            }

            ordered.forEach(cardData => {
                if (!cardData || !cardData.id) {
                    console.warn("❗ Skipping cardData due to missing ID:", cardData);
                    return;
                }

                let card = cards.find(c => String(c.id) === String(cardData.id));

                if (!card) {
                    const baseToken = tokens.find(t => String(cardData.id).startsWith(String(t.id)));
                    if (baseToken) {
                        card = { ...baseToken, ...cardData }; // use token base with live data
                        console.debug(`🪙 renderCardZone: resolved token ID ${cardData.id} using base ${baseToken.id}`);
                    }
                }

                const isFaceDownArsenal = cardData.boardState === "FaceDownArsenalZone";
                const isFaceDown        = !!cardData.faceDown;

                // If neither a real card nor a token (and not face-down), skip it
                if (!card && !isFaceDown) return;

                let element;

                if (isFaceDownArsenal) {
                    const arsenalWrapper = document.createElement("div");
                        arsenalWrapper.style.display = "inline-block";
                        arsenalWrapper.style.position = "relative";
                        arsenalWrapper.style.marginLeft = "-33.8%";
                        arsenalWrapper.style.transformOrigin = "top center";
                        arsenalWrapper.style.marginTop = "-16px";
                        arsenalWrapper.style.pointerEvents = "auto";
                        arsenalWrapper.style.backgroundColor = "rgba(255,0,0,0)";
                        arsenalWrapper.style.width = "260px";
                        arsenalWrapper.style.height = "400px";
                        arsenalWrapper.style.transform = "scale(0.3)";
                        arsenalWrapper.style.outline = "0px dashed red";
                        arsenalWrapper.style.cursor = "pointer";

                    const arsenalCard = document.createElement("div");
                        arsenalCard.style.width = "100%";
                        arsenalCard.style.height = "100%";
                        arsenalCard.style.backgroundImage = `url(${userSleeveURL || 'default-sleeve.png'})`;
                        arsenalCard.style.backgroundSize = "cover";
                        arsenalCard.style.backgroundPosition = "center";
                        arsenalCard.style.border = "2px solid white";
                        arsenalCard.style.position = "relative";
                        arsenalCard.style.zIndex = "110";
                        arsenalCard.style.pointerEvents = "none";
                        arsenalCard.style.opacity = "1";
                        arsenalCard.style.transition = "opacity 1s ease-in-out";

                    // Hover logic for scaled preview
                    arsenalWrapper.addEventListener("mouseenter", () => {
                        const full = cards.find(c => String(c.id) === String(cardData.id));
                        if (!full) {
                            console.error(`❌ No card found with ID '${cardData.id}' for preview.`);
                            return;
                        }

                        const scaled = document.querySelector("#viewing-window .scaled-card");
                        if (!scaled) {
                            console.warn("⚠️ #viewing-window .scaled-card not found.");
                            return;
                        }

                        scaled.innerHTML = "";

                        const preview = renderCard(full);
                        preview.style.width = "240px";
                        preview.style.height = "420px";
                        preview.style.transform = "scale(1.2)";
                        preview.style.marginLeft = "-15%";
                        preview.style.marginTop = "7%";

                        scaled.appendChild(preview);
                    });

                    arsenalWrapper.appendChild(arsenalCard);
                    container.appendChild(arsenalWrapper);
                    const fullCard = cards.find(c => String(c.id) === String(cardData.id));
                    if (!fullCard) {
                        console.error(`No card with ID ${cardData.id} found`);
                        return;
                    }
                    return;
                }

                if (isFaceDown) {
                    const wrapperDiv = document.createElement("div");
                    wrapperDiv.id = `card-${cardData.id}`;
                        wrapperDiv.style.display = "inline-block";
                        wrapperDiv.style.position = "relative";
                        wrapperDiv.style.marginLeft = "-39.3%";
                        wrapperDiv.style.transformOrigin = "top center";
                        wrapperDiv.style.marginTop = "16px";
                        wrapperDiv.style.pointerEvents = "auto";
                        wrapperDiv.style.backgroundColor = "rgba(255,0,0,0)";
                        wrapperDiv.style.width = "260px";
                        wrapperDiv.style.height = "400px";
                        wrapperDiv.style.transform = "translateY(11%) rotate(270deg) scale(0.33)";
                        wrapperDiv.style.outline = "0px dashed red"; // visually show wrapperDiv box
                        wrapperDiv.style.cursor = "pointer";

                    element = document.createElement("div");
                        element.style.width = "100%"; // fill wrapper
                        element.style.height = "100%";
                        element.style.backgroundImage = `url(${userSleeveURL || 'default-sleeve.png'})`;
                        element.style.backgroundSize = "cover";
                        element.style.backgroundPosition = "center";
                        element.style.transform = ""; // reset transform
                        element.style.marginTop = "0px";
                        element.style.position = "relative";
                        element.style.zIndex = "110";
                        element.style.border = "2px solid white";
                        element.style.pointerEvents = "none";
                        element.style.opacity = "1";
                        element.style.transition = "opacity 1s ease-in-out";

                    wrapperDiv.addEventListener("mouseenter", () => {
                        //console.log("mouseenter fired on face-down card", cardData.id);
                        if (containerId === "playerFaceDownBox"){
                            rendered.dataset.zone = "Zone (Champion)";
                        }
                        if (containerId === "playerFaceDownArsenalBox"){
                            rendered.dataset.zone = "Zone (Arsenal)";
                        }
                        const realCard = cards.find(c => String(c.id) === String(cardData.id));
                        if (!realCard) {
                            console.error(`❌ Hover preview: No card found with ID '${cardData.id}'. Check if the card exists in 'cards' array.`);
                            return;
                        }

                        const scaled = document.querySelector("#viewing-window .scaled-card");
                        if (!scaled) {
                            console.warn("⚠️ #viewing-window .scaled-card not found!");
                            return;
                        }

                        scaled.innerHTML = "";

                        const preview = renderCard(realCard);
                        preview.style.width = "240px";
                        preview.style.height = "420px";
                        preview.style.transform = "scale(1.2)";
                        preview.style.marginLeft = "-15%";
                        preview.style.marginTop = "7%";

                        scaled.appendChild(preview);
                    });
                    wrapperDiv.appendChild(element);
                    container.appendChild(wrapperDiv);
                } else {
                    const enriched = { ...card, ...cardData };
                    const rendered = renderCard(enriched);
                    if (containerId === "playerChampionsBox"){
                        rendered.dataset.zone = "Zone (Champion)";
                    }
                    if (containerId === "playerArsenalBox"){
                        rendered.dataset.zone = "Zone (Arsenal)";
                    }
                    if (containerId === "playerReserveBox"){
                        rendered.dataset.zone = "Reserve";
                    }
                    rendered._card        = cardData;
                    attachHoverMenu(rendered, cardData);

                    const wrapper = document.createElement("div");
                        wrapper.style.display        = "inline-block";
                        wrapper.style.position       = "relative";
                    if (containerId === "playerReserveBox") {
                        wrapper.style.marginLeft  = "-210px";
                        wrapper.style.marginTop   = "-350px";
                        wrapper.style.transform       = "scale(0.3)";
                        wrapper.style.transformOrigin = "top center";
                    } else {
                        wrapper.style.marginLeft  = "-44px";
                        wrapper.style.marginTop   = "323px";
                        wrapper.style.transformOrigin = "top center";
                        wrapper.style.transform       = "scale(0.3)";
                    }
                    wrapper.style.pointerEvents   = "auto";
                    wrapper.style.zIndex          = "200000";

                    // Hover-to-preview logic
                    wrapper.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                            scaled.innerHTML = "";

                        const preview = renderCard(enriched);
                            preview.style.width = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop = "7%";

                        scaled.appendChild(preview);
                    });
                    wrapper.appendChild(rendered);
                    container.appendChild(wrapper);
                }
            });
        }
    applyHoverMenus();

    async function flipCard(cardId) {
        const facedownZone = gameState[username].FaceDownZone;
        const championsZone = gameState[username]["Zone (Champion)"];

        const cardIndex = facedownZone.findIndex(c => String(c.id) === String(cardId));
        if (cardIndex === -1) {
            console.warn("❌ Card not found in FaceDownZone:", cardId);
            return;
        }

        const card = facedownZone[cardIndex];

        // ❌ Only the player on their turn can flip
        if (gameState.turn.currentPlayer !== username) {
            alert("You can only flip cards during your turn.");
            return;
        }

        // ❌ Only during Main 1 or Main 2
        const phase = gameState.turn.currentPhase;
        if (phase !== "Main 1" && phase !== "Main 2") {
            alert("You can only flip champions face-up during your Main Phase.");
            return;
        }

        // ❌ Cannot flip the turn it's set
        if (gameState.turn.count <= card.setTurn) {
            alert("You cannot flip this card the turn it was set.");
            return;
        }

        // ✅ Move to Champion Zone
        facedownZone.splice(cardIndex, 1);
        delete card.faceDown;
        delete card.setTurn;
        card.lastBoardState = "FaceDownZone";
        card.boardState = "Zone (Champion)";
        championsZone.push(card);

        addGameLogEntry(`${username} flipped a champion face-up: ${card.name}`);

        await fetch("https://geimon-app-833627ba44e0.herokuapp.com/updateGameState", {
            method: "POST",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                gameId,
                owner: username,
                updatedZones: {
                    FaceDownZone: facedownZone,
                    [CHAMPION_ZONE]: championsZone
                }
            })
        });
        setTimeout(async () => {
            await updateLocalFromGameState();
        }, 100); // adjust if needed
    }

    // Fetch and shuffle deck, then update count
    async function fetchAndShuffleDeck(deckParam) {
        let cardIds = [];

        try {
            // Try to parse as a JSON array
            const parsed = JSON.parse(deckParam);
            if (Array.isArray(parsed)) {
                cardIds = parsed;
            } else {
                // Fallback to server fetch
                const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                    method: "POST",
                    credentials: "include",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ deck_name: deckParam }),
                });

                const data = await response.json();
                if (!data.success) {
                    console.error("Error:", data.message);
                    return;
                }

                cardIds = data.card_ids;
            }
        } catch (e) {
            // Not valid JSON — must be a normal deck name
            const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                method: "POST",
                credentials: "include",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({ deck_name: deckParam }),
            });

            const data = await response.json();
            if (!data.success) {
                console.error("Error:", data.message);
                return;
            }

            cardIds = data.card_ids;
        }

        // At this point, cardIds is valid
        initialDeckSize = cardIds.length;
        remainingDeck = shuffleDeck(cardIds).map(id => ({
            id,
            boardState: "Deck",
            lastBoardState: null
        }));

        console.log("Deck Shuffled:", remainingDeck);
        console.log("Total Cards in Deck:", initialDeckSize);
    }

    document.addEventListener("gameStateUpdated", () => {
        console.log("gameStateUpdated event fired");
        updateLocalFromGameState();
    });

    document.addEventListener("playerLifeReachedZero", async (e) => {
        if (gameEnded) return;
        gameEnded = true;
        const loser = e.detail.player;
        const winner = Object.keys(gameState).find(name =>
            name !== loser && name !== "turn" && name !== "player1" && name !== "player2"
        );

        await fetch("https://geimon-app-833627ba44e0.herokuapp.com/endGame", {
            method: "POST",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                gameId,
                loser,
                reason: "Life reached 0"
            })
        });

        if (loser === username) {
            showBanner("You Lose", "Your life reached 0");
        } else {
            showBanner("You Win", "Opponent’s life reached 0");
        }
    });

    document.addEventListener("DOMContentLoaded", () => {
        const tooltip = document.getElementById("tooltip");
        const tokenTooltip = document.getElementById("token-tooltip");

        const tabs = document.querySelectorAll(".tab-button");
        const contents = document.querySelectorAll(".tab-content");

        tabs.forEach(tab => {
            tab.addEventListener("click", () => {
                tabs.forEach(t => t.classList.remove("active"));
                contents.forEach(c => c.classList.remove("active"));

                tab.classList.add("active");
                document.getElementById(tab.dataset.tab).classList.add("active");
            });
        });

        // Game Log Data Population
        const params = new URLSearchParams(window.location.search);
        //document.getElementById("totem").textContent = params.get("totem");

        const dictionarySearch = document.getElementById("dictionary-search");
        const dictionaryResults = document.getElementById("dictionary-results");

        const loadAllTerms = () => {
            dictionaryResults.innerHTML = "";
            const allTerms = [...Object.entries(keywords), ...Object.entries(rules)];
            allTerms.sort((a, b) => a[0].localeCompare(b[0]));
            allTerms.forEach(([key, value]) => {
                const resultItem = document.createElement("p");
                resultItem.innerHTML = `<strong>${key}:</strong> ${value}`;
                dictionaryResults.appendChild(resultItem);
            });
        };
        loadAllTerms();

        dictionarySearch.addEventListener("input", () => {
            const query = dictionarySearch.value.toLowerCase();
            dictionaryResults.innerHTML = "";

            if (!query) {
                loadAllTerms();
                return;
            }

            const matchedKeywords = Object.entries(keywords).filter(([key]) =>
                key.toLowerCase().includes(query)
            );

            const matchedRules = Object.entries(rules).filter(([key]) =>
                key.toLowerCase().includes(query)
            );

            [...matchedKeywords, ...matchedRules].forEach(([key, value]) => {
                const resultItem = document.createElement("p");
                resultItem.innerHTML = `<strong>${key}:</strong> ${value}`;
                dictionaryResults.appendChild(resultItem);
            });
        });

        document.querySelectorAll(".keyword").forEach(keyword => {
            const description = keyword.dataset.description;

            if (description && description.trim() !== "") {
                keyword.addEventListener("mouseenter", (e) => {
                    tooltip.textContent = description;
                    tooltip.style.display = "block";
                    tokenTooltip.querySelector(".token-tooltip-text").textContent = description;
                    tokenTooltip.style.display = "block";
                });

                keyword.addEventListener("mouseleave", () => {
                    tooltip.style.display = "none";
                    tokenTooltip.style.display = "none";
                });

                keyword.addEventListener("mousemove", (e) => {
                    if (tooltip.style.display === "block") {
                        tooltip.style.left = `${e.pageX + 10}px`;
                        tooltip.style.top = `${e.pageY - 40}px`;
                    }
                    if (tokenTooltip.style.display === "block") { // ✅ Fix: Remove `else if`
                        tokenTooltip.style.left = `${e.pageX + 10}px`;
                        tokenTooltip.style.top = `${e.pageY - 40}px`;
                    }
                });
            }
        });
    });
    initGameClient();
    </script>
</body>
</html>