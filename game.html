<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
    <link rel="icon" href="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/favicon.png" type="image/png">
    <link rel="stylesheet" href="style.css">
    <title>ACTIVE GAME</title>
</head>
<style>
  #coin {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    transition: transform 0.1s;
}
  #drawn-cards {
    position: fixed;
    bottom: 2%; /* Positions the cards near the bottom */
    left: 42%;
    transform: translate(-25%, 30%);
    display: flex;
    flex-direction: row; /* Aligns cards in a horizontal row */
    align-items: center;
    z-index: 9999; /* Places it over everything */
    gap: -50%; /* Allows 5% overlap */
}
.card {
    width: 240px; /* Reduces card size */
    height: 420px;
    position: relative; /* Ensures controlled placement */
    margin-left: -50%; /* Overlaps cards by 5% */
}
.viewing-window {
    position: fixed;
    left: 0.5%; /* Keeps it on the left */
    top: 25%;
    transform: translateY(-50%);
    width: 280px; /* Size for zoomed card */
    height: 440px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #1e1e1e;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110; /* Ensures it's on top */
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.context-window {
    position: fixed;
    left: 0.5%;
    top: 75%;
    transform: translateY(-50%);
    width: 280px;
    height: 440px;
    display: flex;
    flex-direction: column;
    background-color: #1e1e1e;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.player-life-window {
    position: fixed;
    left: 93%;
    top: 58.5%;
    transform: translateY(-50%);
    width: 100px;
    height: 100px;
    display: flex;
    flex-direction: column;
    background-color: #2d1eff;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.opponent-life-window {
    position: fixed;
    left: 93%;
    top: 32%;
    transform: translateY(-50%);
    width: 100px;
    height: 100px;
    display: flex;
    flex-direction: column;
    background-color: #970000;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.tabs {
    display: flex;
    justify-content: space-around;
    padding: 5px;
}
.tab-button {
    padding: 5px;
    cursor: pointer;
    background: #505050;
    color: white;
    border: none;
    border-radius: 5px;
}
.tab-button.active {
    background: #838383;
}
.tab-content-container {
    flex-grow: 1;
    padding: 10px;
    overflow-y: auto;
}
.tab-content {
    display: none;
    color: white;
}
.tab-content.active {
    display: block;
}
#viewing-window .scaled-card {
    pointer-events: auto !important;
    z-index: 100110; /* Ensures it's on top */
    width: 240px;
    height: 420px;
    margin-top: -12%;
}
#viewing-window .scaled-card .card-name {
    max-width: 100%;
}
#viewing-window .scaled-card .card-cost,
#viewing-window .scaled-card .card-text,
#viewing-window .scaled-card .card-name,
#viewing-window .scaled-card .card-condition,
#viewing-window .scaled-card .card-tags,
#viewing-window .scaled-card .bottom-bar,
#viewing-window .scaled-card .card-image {
    z-index: 100200 !important;
}
.tooltip {
    z-index: 110000 !important;
}
#tooltip {
    position: absolute;
    display: none;
    background-color: rgba(0, 0, 0, 1);
    color: white;
    padding: 5px;
    border-radius: 5px;
    font-size: 14px;
    max-width: 250px;
    z-index: 110000; /* Ensure it appears above other elements */
}
.token-tooltip {
    pointer-events: auto !important;
    z-index: 110000 !important;
}
#token-tooltip {
    z-index: 110000; /* Ensure it appears above other elements */
}
.keyword {
    pointer-events: auto !important;
    position: relative; /* Ensures proper hovering */
    z-index: 110000; /* Ensures tooltip appears above other elements */
}
.card-cost .keyword {
    position: relative;
    z-index: 110000 !important;
    pointer-events: auto !important;
}
.card-cost {
    pointer-events: auto !important;
    z-index: 100000 !important;
}
.card-text {
    pointer-events: auto !important;
    z-index: 100000 !important;
}
.scaled-card .card-button {
    display: none !important;
}
.life {
    color: white;
    text-align: center;
    font-weight: bold;
    font-size: 4em;
}
.player-name,
.opponent-name {
    color: white;
    font-size: 1.1em;
    text-align: center;
    font-weight: bold;
    overflow: hidden;          /* Hide overflowed content */
    text-overflow: ellipsis;   /* Show ... when text overflows */
    white-space: nowrap;       /* Prevent text from wrapping */
    max-width: 100%;           /* Optional: control how much space the text gets */
    display: inline-block;     /* Required for ellipsis to take effect */
}
#loss-banner {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0,0,0,0.8);
    padding: 40px 80px;
    border-radius: 16px;
    color: white;
    text-align: center;
    font-family: sans-serif;
    z-index: 120000;
    display: none;
}
#loss-banner .main {
    font-size: 3em;
    font-weight: bold;
    margin-bottom: 10px;
}
#loss-banner .reason {
    font-size: 1.5em;
}
#phase-tracker {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin: 10px auto;
  padding: 10px;
  position: fixed;
  top: 42%;
  left: 46.5%;
  transform: translateX(-50%);
  z-index: 100600;
  opacity: 0;
}
.phase-box {
  padding: 10px 14px;
  background: dimgray;
  color: white;
  border-radius: 6px;
  font-weight: bold;
  min-width: 90px;
  text-align: center;
  transition: background 0.3s;
}
.phase-box.active {
  background: lightgreen;
  text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;
}
#turn-counter {
  position: fixed;
  top: 44.6%;
  left: 75.5%; /* adjust this to line up visually with the button */
  z-index: 100600;
  color: white;
  font-weight: bold;
  font-size: 1.5em;
  opacity: 0;
  text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;
}
#turn-indicator {
  position: fixed;
  top: 44.6%;
  left: 66.1%;
  z-index: 100600;
  color: white;
  font-weight: bold;
  font-size: 1.5em;
  opacity: 0;
  text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;
}
.card-zone {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  gap: 0px;
  overflow: visible;
  z-index: 100300;
  position: relative;
}
</style>
<body style="background-color:rgb(78, 78, 78);">
  <img src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/try_2.png" class="bg-image" alt="">
        <div id="coin-flip-container" style="display: none; text-align: center; margin-top: 50px;">
            <img id="coin" src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png" alt="coin" style="width: 150px; height: 150px;">
            <h2 id="flip-result" style="display: none;"></h2>
        </div>
        <div id="tooltip" class="tooltip"></div>
        <div id="token-tooltip" style="display: none; position: absolute;">
            <div class="token-tooltip-text" style="font-family: 'Times New Roman', serif; font-size: 14px;"></div>
        </div>
        <div id="playerDeckBox"></div>
        <div id="drawn-cards" style="display: flex; flex-wrap: wrap; gap: 10px; padding: 10px;">
            <p id="drawn-message" style="color: white; font-size: 1.5em;"></p>
        </div>
        <div class="viewing-window" id="viewing-window">
            <div class="scaled-card" id="scaled-card" style="transform: scale(0.797); transform-origin: center; pointer-events: none; margin-left: 14%;"></div>
        </div>
        <div class="context-window" id="context-window">
            <div class="tabs">
                <button class="tab-button" data-tab="chat">Chat</button>
                <button class="tab-button active" data-tab="game-log">Game Log</button>
                <button class="tab-button" data-tab="dictionary">Dictionary</button>
            </div>
            <div class="tab-content-container">
                <div class="tab-content" id="chat">
                    <p>This is a Solo Game, and we here at Geimon! do not believe that AI should be allowed to speak.</p>
                </div>
                <div class="tab-content active" id="game-log">
                    <p>Totem: <span id="totem" style="color: goldenrod;"></span></p>
                    <div id="game-log-placeholder"></div>
                </div>
                <div class="tab-content" id="dictionary">
                    <input type="text" id="dictionary-search" placeholder="Search terms..." style="width: 95%;">
                    <div id="dictionary-results"></div>
                </div>
            </div>
        </div>
        <div class="player-life-window" id="player-life-window">
            <div class="player-name" id="player-name"></div>
            <div class="life" id="player-life"></div>
            <div class="player-name" style="font-size: 80%;">Life</div>
        </div>
        <div class="opponent-life-window" id="opponent-life-window">
            <div class="opponent-name" id="opponent-name"></div>
            <div class="life" id="opponent-life"></div>
            <div class="player-name" style="font-size: 80%;">Life</div>
        </div>
        <div id="loss-banner">
            <div class="main" id="loss-main-text">You Lose</div>
            <div class="reason" id="loss-reason-text">Surrendered</div>
        </div>
        <div id="phase-tracker">
            <div class="phase-box" id="phase-Intermission">Intermission</div>
            <div class="phase-box" id="phase-Draw">Draw</div>
            <div class="phase-box" id="phase-Main 1">Main 1</div>
            <div class="phase-box" id="phase-Battle">Battle</div>
            <div class="phase-box" id="phase-Main 2">Main 2</div>
            <div class="phase-box" id="phase-End">End</div>
        </div>
        <div id="turn-indicator">Your Turn</div>
        <div id="turn-counter">Turn: 1</div>
        <div id="playerArsenalBox" class="card-zone"></div>
        <div id="playerChampionsBox" class="card-zone"></div>
        <div id="playerReserveBox" class="card-zone"></div>

        <script type="module">
            import { cards } from "./data/cards.js";
            import { tokens } from "./data/tokens.js";
            import { renderCard } from "./utils/cardRenderer.js";
            import { addTooltipListeners, addTokenTooltipListeners } from "./utils/cardRenderer.js";
            import { keywords } from "./data/keywords.js";
            import { rules } from "./data/rules.js";
            import * as AbilityExecutor from './utils/abilityExecutor.js';

            let gameId = new URLSearchParams(window.location.search).get("gameId");
            if (gameId) {
                // Use the gameId from URL and update localStorage
                localStorage.setItem("gameId", gameId);
            } else {
                // Fallback: create a new one if not in URL or localStorage
                gameId = localStorage.getItem("gameId") || Math.random().toString(36).substr(2, 9);
                localStorage.setItem("gameId", gameId);
            }

            let username = null;
            let hasDrawnInitialHand = false;
            let lastLoggedIntermissionTurn = null;

            let discardMode = false;

            const params = new URLSearchParams(window.location.search);
            const isSinglePlayer = params.get("gameType") === "single";
            const otherPlayerName = params.get("opponent") || "Unknown_Opponent"; // if multiplayer later

            let previousHandIds = [];
            let lastDrawTurn = null;

            function addGameLogEntry(message) {
                if (!username) {
                    console.warn("‚ùå addGameLogEntry called before username was set.");
                    return;
                }
                const gameLog = document.getElementById("game-log-placeholder");
                if (!gameLog) {
                    console.warn("No game log container found.");
                    return;
                }
                const time = new Date().toLocaleTimeString();
                const entry = document.createElement("div");
                entry.textContent = `[${time}] ${message}`;
                gameLog.appendChild(entry);
                gameLog.scrollTop = gameLog.scrollHeight;
            }

        function handsAreEqual(currentHand) {
        return (
            currentHand.length === previousHandIds.length &&
            currentHand.every((card, index) => card.id === previousHandIds[index])
        );
        }

        function updateLocalFromGameState() {
            const player = gameState[username];
            const currentHand = player.Hand;

            const prevLength = previousHandIds.length;
            const newLength = currentHand.length;

            if (!handsAreEqual(currentHand)) {
                drawnCardsArray = currentHand;
                previousHandIds = currentHand.map(card => card.id);
                renderDrawnCards();

                if (!hasDrawnInitialHand && newLength >= 5) {
                    hasDrawnInitialHand = true;
                    return;
                }

                if (hasDrawnInitialHand && newLength > prevLength) {
                    const numDrawn = newLength - prevLength;
                    addGameLogEntry(`${username} drew ${numDrawn} card${numDrawn > 1 ? 's' : ''}`);
                }
            }

            remainingDeck = player.Deck;
            updateDeckText();

            // ‚úÖ Add this:
            updateTurnDisplay(gameState.turn);
            updatePhaseDisplay(gameState.turn.currentPhase);
            renderLatestTombCard();
            renderLatestVoidCard();

            if (gameState[username] && gameState[username].hasBasicRallied === undefined) {
                gameState[username].hasBasicRallied = false;
            }

            const zoneMappings = {
                "Zone (Champion)": "Champions",
                "Zone (Arsenal)": "Arsenal",
                "Reserve": "Reserve"
            };

            Object.entries(zoneMappings).forEach(([zoneKey, domSuffix]) => {
                renderCardZone(gameState[username][zoneKey], `player${domSuffix}Box`);
            });
        }

            async function getUsername() {
                const res = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/me', { credentials: 'include' });
                const data = await res.json();
                if (data.loggedIn) {
                    username = data.username;
                }
            }
            async function initGameClient() {
                await getUsername();
                if (!username) {
                    alert("Could not retrieve username.");
                    return; // ‚úÖ This is now valid
                }
            }

        window.onload = () => {
            (async () => {
                await initGameClient();
                    if (!username) {
                        console.warn("Username not set after init.");
                        return;
                }

            const params = new URLSearchParams(window.location.search);
            const turnOrder = params.get("turnOrder");

            if (turnOrder === "coinflip") {
                const container = document.getElementById("coin-flip-container");
                const coin = document.getElementById("coin");
                const resultText = document.getElementById("flip-result");
                container.style.display = "block";
                resultText.textContent = "";

                // Image paths
                const headsImg = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png";
                const tailsImg = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/tails.png";

                let positionY = window.innerHeight / 2;
                let velocity = -25;
                let gravity = 1;
                let flips = 0;

                function animateFlip() {
                    coin.src = Math.random() > 0.5 ? headsImg : tailsImg;

                    positionY += velocity;
                    velocity += gravity;

                    coin.style.top = `${positionY}px`;

                    if (velocity > 0 && positionY >= window.innerHeight / 2) {
                        clearInterval(interval);

                        const finalResult = Math.random() > 0.5 ? "Heads" : "Tails";
                        coin.src = finalResult === "Heads" ? headsImg : tailsImg;

                        if (finalResult === "Tails") {
                            resultText.textContent = "You are going second.";
                            resultText.style.display = "block";
                            resultText.style.fontSize = "2em";
                            resultText.style.marginTop = "10%";
                            resultText.style.textShadow ="2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black";
                            setTimeout(() => transitionToNextScreen("second"), 2000);
                        } else {
                            resultText.textContent = "You won the coin flip! Choose:";
                            resultText.style.display = "block";
                            resultText.style.fontSize = "2em";
                            resultText.style.marginTop = "10%";
                            resultText.style.textShadow = "2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black";

                            const buttonContainer = document.createElement("div");
                            buttonContainer.style.marginTop = "20px";

                            const goFirstButton = document.createElement("button");
                            goFirstButton.textContent = "Go First";
                            goFirstButton.style.marginRight = "10px";
                            goFirstButton.className = "button button";
                            goFirstButton.onclick = () => {
                                clearTimeout(autoSelectTimer); // Cancel timer if selected manually
                                transitionToNextScreen("first");
                            };

                            const goSecondButton = document.createElement("button");
                            goSecondButton.textContent = "Go Second";
                            goSecondButton.className = "button button";
                            goSecondButton.onclick = () => {
                                clearTimeout(autoSelectTimer); // Cancel timer if selected manually
                                transitionToNextScreen("second");
                            };

                            buttonContainer.appendChild(goFirstButton);
                            buttonContainer.appendChild(goSecondButton);
                            container.appendChild(buttonContainer);

                            // Start 3-second timer for automatic selection
                            const autoSelectTimer = setTimeout(() => {
                                const randomChoice = Math.random() < 0.5 ? "first" : "second"; // 50/50 chance
                                console.log(`Time expired! Automatically choosing: ${randomChoice}`);
                                transitionToNextScreen(randomChoice);
                            }, 3000); // 3 seconds
                        }

                    }
                }
                const interval = setInterval(animateFlip, 50);
            }
            else if (turnOrder === "first" || turnOrder === "second") {
                // Directly proceed to game setup
                transitionToNextScreen(turnOrder);
            }
            else {
                document.body.innerHTML = `
                    <h1>Game Configuration</h1>
                    <p>Player Deck: ${params.get("playerDeck")}</p>
                    <p>Opponent Deck: ${params.get("opponentDeck")}</p>
                    <p>Game Type: ${params.get("gameType")}</p>
                    <p>Totem: ${params.get("totem")}</p>
                    <p>Turn Order: ${turnOrder}</p>
                `;
            }
        })();
    };
        async function fetchLatestTurnState() {
            const res = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`, {
                credentials: "include",
            });
            if (!res.ok) return gameState;
            return await res.json();
            }
        async function waitForGameState(retries = 10, delayMs = 500) {
            for (let i = 0; i < retries; i++) {
                const res = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`, {
                credentials: "include"
                });

                if (res.ok) {
                const gameState = await res.json();
                if (gameState && gameState.turn) return gameState;
                }

                console.warn(`Retry ${i + 1} of ${retries}... waiting for game state...`);
                await new Promise(resolve => setTimeout(resolve, delayMs));
            }

            throw new Error("Game state failed to initialize in time.");
        }

        async function fetchGameStateFromServer() {
            try {
                const response = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`, {
                    credentials: "include"
                });

                if (!response.ok) {
                console.warn("‚ö†Ô∏è Failed to fetch game state:", response.status);
                return; // Don't continue if response is bad
                }

                const newGameState = await response.json();
                if (!newGameState || !newGameState.turn) {
                console.warn("‚ö†Ô∏è Game state or turn missing from server");
                return;
                }

                gameState = newGameState;
                updateLocalFromGameState();
                const currentTurn = gameState.turn;
                const playerState = gameState[username];

            } catch (err) {
                console.error("üí• Error fetching game state:", err);
            }
        }

        function showLossBanner(mainText, reasonText) {
            const banner = document.getElementById("loss-banner");
            document.getElementById("loss-main-text").textContent = mainText;
            document.getElementById("loss-reason-text").textContent = reasonText;
            banner.style.display = "block";
        }

        function checkActivatableCards() {
            console.log("Check for activatable cards here...");
        }

        async function handleCardDiscard(gameState, username, cards, gameId, phase, updateLocalFromGameState, addGameLogEntry, updatePhaseDisplay) {
            discardMode = true;
            const hand = gameState[username].Hand;
            if (hand.length <= 6) return;

            const drawnCardsContainer = document.getElementById("drawn-cards");
            if (!drawnCardsContainer) return;

            const discardsNeeded = hand.length - 6;
            let discardsLeft = discardsNeeded;

            // Disable phase clicks
            document.querySelectorAll(".phase-box").forEach(box => box.style.pointerEvents = "none");

            // Create discard instruction
            const discardInstruction = document.createElement("div");
            discardInstruction.textContent = `Select ${discardsLeft} card${discardsLeft > 1 ? "s" : ""} to discard`;
            Object.assign(discardInstruction.style, {
                position: "fixed",
                bottom: "50%",
                left: "55%",
                transform: "translateX(-50%)",
                color: "black",
                fontSize: "4em",
                backgroundColor: "rgba(255, 0, 0, 0.85)",
                padding: "12px 20px",
                borderRadius: "10px",
                zIndex: "120000"
            });
            document.body.appendChild(discardInstruction);

            drawnCardsContainer.querySelectorAll(".card-button").forEach(button => {
                const originalClick = button.onclick;
                button._originalHandler = originalClick;

                button.onclick = () => {
                    const parentCard = button.closest(".card");
                    const cardId = parentCard?.dataset.cardId;
                    if (!cardId) return console.warn("‚ùå No cardId found on clicked button");

                    const cardData = gameState[username].Hand.find(c => String(c.id) === cardId);
                    const fullCard = cards.find(c => String(c.id) === cardId);
                    if (!cardData || !fullCard) return console.warn("‚ùå Could not find card data");

                    const enrichedCard = { ...cardData, ...fullCard, lastBoardState: "Hand", boardState: "Tomb" };

                    const confirmBox = document.createElement("div");
                    Object.assign(confirmBox.style, {
                        position: "fixed",
                        top: "50%",
                        left: "50%",
                        transform: "translate(-50%, -50%)",
                        padding: "20px",
                        backgroundColor: "#333",
                        color: "white",
                        border: "2px solid white",
                        borderRadius: "10px",
                        zIndex: "120001",
                        textAlign: "center",
                        boxShadow: "0 0 10px black"
                    });
                    confirmBox.innerHTML = `
                        <p>Discard this card?</p>
                        <div style="margin: 10px 0;">${fullCard.name}</div>
                        <button id="confirm-discard">Confirm</button>
                        <button id="cancel-discard" style="margin-left: 10px;">Cancel</button>
                    `;
                    document.body.appendChild(confirmBox);

                    document.getElementById("confirm-discard").onclick = async () => {
                        const index = gameState[username].Hand.findIndex(c => String(c.id) === cardId);
                        gameState[username].Hand.splice(index, 1);
                        gameState[username].Tomb.push(enrichedCard);

                        AbilityExecutor.handleBoardStateChange(
                            enrichedCard,
                            "Tomb",
                            "Hand",
                            gameState,
                            username,
                            gameId,
                            updateLocalFromGameState,
                            addGameLogEntry
                        );

                        addGameLogEntry(`${username} discarded ${fullCard.name} for hand size limit`);

                        await fetch("https://geimon-app-833627ba44e0.herokuapp.com/updateGameState", {
                            method: "POST",
                            credentials: "include",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                gameId,
                                owner: username,
                                updatedZones: {
                                    Hand: gameState[username].Hand,
                                    Tomb: gameState[username].Tomb
                                }
                            })
                        });

                        document.body.removeChild(confirmBox);
                        updateLocalFromGameState();
                        renderLatestTombCard();

                        discardsLeft--;
                        discardInstruction.textContent = `Select ${discardsLeft} card${discardsLeft === 1 ? "" : "s"} to discard`;

                        if (discardsLeft === 0) {
                            discardMode = false;
                            document.body.removeChild(discardInstruction);
                            drawnCardsContainer.querySelectorAll(".card-button").forEach(btn => {
                                btn.onclick = btn._originalHandler || null;
                            });
                            document.querySelectorAll(".phase-box").forEach(box => box.style.pointerEvents = "auto");

                            const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/setPhase", {
                                method: "POST",
                                credentials: "include",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({ gameId, username, phase })
                            });

                            if (response.ok) {
                                const updated = await response.json();
                                updatePhaseDisplay(updated.currentPhase);
                            }
                        }
                    };

                    document.getElementById("cancel-discard").onclick = () => {
                        document.body.removeChild(confirmBox);
                    };
                };
            });
        }


        function updateTurnDisplay(turnData) {
        if (turnData && turnData.count) {
            document.getElementById("turn-counter").textContent = `Turn: ${turnData.count}`;

            const indicator = document.getElementById("turn-indicator");
            if (turnData.currentPlayer === username) {
            indicator.textContent = "Your Turn";
            } else {
            indicator.textContent = "Opponent's Turn";
            }
            indicator.style.opacity = "1";

            const colorBox = document.getElementById("turn-color-box");
            if (colorBox) {
                if (turnData.currentPlayer === username) {
                    colorBox.style.backgroundColor = "blue";
                } else {
                    colorBox.style.backgroundColor = "red";
                }
            }
        }
        }
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        document.querySelectorAll(".phase-box").forEach(box => {
            box.style.cursor = "pointer";
            box.addEventListener("click", async () => {
                const phase = box.textContent.trim();
                const turnCount = gameState.turn.count;
                const currentPhase = gameState.turn.currentPhase;
                const player = gameState.turn.currentPlayer;

                if (player !== username) return;

                // Turn 1: restrict Battle and Main 2
                if (turnCount === 1 && (phase === "Battle" || phase === "Main 2")) return;

                // Enforce phase flow:
                const allowedTransitions = {
                    "Intermission": ["Draw"],
                    "Draw": ["Main 1"],
                    "Main 1": ["Battle", "End"],
                    "Battle": ["Main 2"],
                    "Main 2": ["End"]
                };

                const validNextPhases = allowedTransitions[currentPhase] || [];

                if (!validNextPhases.includes(phase)) {
                    console.warn(`Invalid transition from ${currentPhase} to ${phase}`);
                    return;
                }

                if (phase === "End" && gameState.turn.currentPlayer === username) {
                    if (gameState[username].Hand.length > 6) {
                        await handleCardDiscard(
                            gameState,
                            username,
                            cards,
                            gameId,
                            phase,
                            updateLocalFromGameState,
                            addGameLogEntry,
                            updatePhaseDisplay
                        );
                    return; // üõë Prevent premature turn advancement
                }
            }

            // ‚úÖ Normal flow if no discards needed
            const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/setPhase", {
            method: "POST",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ gameId, username, phase })
            });

            if (response.ok) {
                const updated = await response.json();
                updatePhaseDisplay(updated.currentPhase);
                addGameLogEntry(`${username} changed phase to ${updated.currentPhase}`);
            }
        });
    });

        function sendToTomb(card) {
            console.log("Incoming card to sendToTomb:", card);
            console.log("Card ID:", card?.id);
            const fullCard = cards.find(c => String(c.id) === String(card.id)) || card;
            console.log("Resolved full card:", fullCard);

            if (!fullCard) {
                console.error(`Full card data not found for ID ${card.id}`);
                return;
            }

            fullCard.lastBoardState = card.boardState;
            fullCard.boardState = "Tomb";

            gameState[username].Tomb.push(fullCard);

            AbilityExecutor.handleBoardStateChange(fullCard, fullCard.boardState, fullCard.lastBoardState, gameState, username, gameId, updateLocalFromGameState, addGameLogEntry);
        }

        function renderLatestTombCard() {
            const tombTop = gameState?.[username]?.Tomb?.slice(-1)[0];
            if (!tombTop) return;

            const card = cards.find(c => String(c.id) === String(tombTop.id));
            if (!card) return;

            // Clear previous
            playerTombBox.innerHTML = "";

            // Render card scaled down
            const miniCard = renderCard(card);
            miniCard.style.transform = "scale(0.3)";
            miniCard.style.transformOrigin = "top left";
            miniCard.style.marginTop = "-8%";
            miniCard.style.marginLeft = "0%";
            miniCard.style.pointerEvents = "none"; // Prevent dragging
            playerTombBox.appendChild(miniCard);

            // Tomb hover label (like Deck)
            const tombTextOverlay = document.createElement("div");
                tombTextOverlay.innerText = "Tomb";
                tombTextOverlay.style.position = "absolute";
                tombTextOverlay.style.left = "50%";
                tombTextOverlay.style.top = "10%";
                tombTextOverlay.style.transform = "translate(-50%, -50%)";
                tombTextOverlay.style.fontWeight = "bold";
                tombTextOverlay.style.fontSize = "1.2em";
                tombTextOverlay.style.color = "white";
                tombTextOverlay.style.textShadow = `
                    -2px -2px 4px black,  
                    2px -2px 4px black,  
                    -2px 2px 4px black,  
                    2px 2px 4px black
                `;
            playerTombBox.appendChild(tombTextOverlay);

            playerTombBox.addEventListener("mouseenter", () => {
                tombTextOverlay.innerText = `${gameState[username].Tomb.length}`;
            });
            playerTombBox.addEventListener("mouseleave", () => {
                tombTextOverlay.innerText = "Tomb";
            });
        }

        function renderLatestVoidCard() {
            const voidTop = gameState?.[username]?.Void?.slice(-1)[0];
            if (!voidTop) return;

            const card = cards.find(c => String(c.id) === String(voidTop.id));
            if (!card) return;

            // Clear previous
            playerVoidBox.innerHTML = "";

            // Render card scaled down
            const miniCard = renderCard(card);
            miniCard.style.transform = "scale(0.3)";
            miniCard.style.transformOrigin = "top left";
            miniCard.style.marginTop = "-8%";
            miniCard.style.marginLeft = "0%";
            miniCard.style.pointerEvents = "none"; // Prevent dragging
            playerVoidBox.appendChild(miniCard);

            // Void hover label (like Deck)
            const voidTextOverlay = document.createElement("div");
            voidTextOverlay.innerText = "Void";
            voidTextOverlay.style.position = "absolute";
            voidTextOverlay.style.left = "50%";
            voidTextOverlay.style.top = "10%";
            voidTextOverlay.style.transform = "translate(-50%, -50%)";
            voidTextOverlay.style.fontWeight = "bold";
            voidTextOverlay.style.fontSize = "1.2em";
            voidTextOverlay.style.color = "white";
            voidTextOverlay.style.textShadow = `
                -2px -2px 4px black,  
                2px -2px 4px black,  
                -2px 2px 4px black,  
                2px 2px 4px black
            `;
            playerVoidBox.appendChild(voidTextOverlay);

            playerVoidBox.addEventListener("mouseenter", () => {
                voidTextOverlay.innerText = `${gameState[username].Void.length}`;
            });
            playerVoidBox.addEventListener("mouseleave", () => {
                voidTextOverlay.innerText = "Void";
            });
        }

        async function transitionToNextScreen(choice) {
            // Keep the background image visible
            const bgImage = document.querySelector(".bg-image");

            // Create a semi-transparent overlay
            const overlay = document.createElement("div");
            overlay.style.position = "absolute";
            overlay.style.top = "0";
            overlay.style.left = "0";
            overlay.style.width = "100%";
            overlay.style.height = "100%";
            overlay.style.backgroundColor = "rgba(0, 0, 0, 0.4)"; // Dark transparency
            overlay.style.zIndex = "10";

            // Main container for the structured design
            const mainContainer = document.createElement("div");
                mainContainer.style.position = "absolute";
                mainContainer.style.top = "2%";
                mainContainer.style.left = "2%";
                mainContainer.style.width = "94%";
                mainContainer.style.height = "92%";
                mainContainer.style.display = "flex";
                mainContainer.style.flexDirection = "column";
                mainContainer.style.justifyContent = "center";
                mainContainer.style.alignItems = "center";
                mainContainer.style.gap = "10px";
                mainContainer.style.padding = "20px";
                mainContainer.style.backgroundColor = "rgba(0, 0, 0)";
                mainContainer.style.borderRadius = "20px";
                mainContainer.style.zIndex = "20";
                mainContainer.style.opacity = "0"; // Start fully invisible
                mainContainer.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
                mainContainer.style.transform = "scale(0.8)  translate(100px,-50px)";

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                mainContainer.style.opacity = "1";
            }, 50);

            // Central result box
            const resultBox = document.createElement("div");
                resultBox.style.position = "absolute";
                resultBox.style.top = "50%";
                resultBox.style.left = "50%";
                resultBox.style.transform = "translate(-50%, -50%)";
                resultBox.style.padding = "20px 40px";
                resultBox.style.color = "white";
                resultBox.style.fontSize = "2em";
                resultBox.style.borderRadius = "10px";
                resultBox.style.textAlign = "center";
                resultBox.style.opacity = "0"; // Start fully invisible
                resultBox.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
                resultBox.style.zIndex = "100700"; // On top of everything
                resultBox.style.boxShadow = "0 0 20px black";

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                resultBox.style.opacity = "1";
            }, 50);

            // Set background color based on choice
            resultBox.style.backgroundColor = choice === "first" ? "blue" : "red";
            resultBox.textContent = choice === "first" ? "Your Turn" : "Opponent's Turn";

            // Main board container
            const board = document.createElement("div");
                board.style.position = "absolute";
                board.style.top = "2%";
                board.style.left = "2%";
                board.style.width = "96%";
                board.style.height = "94%";
                board.style.backgroundColor = "black";
                board.style.zIndex = "20";
                board.style.borderRadius = "20px";
                board.style.opacity = "0"; // Start fully invisible
                board.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                board.style.opacity = "1";
            }, 50);

            const turnBox = document.createElement("div");
                turnBox.id = "turn-color-box";
                turnBox.style.position = "absolute";
                turnBox.style.left = "65.6%";
                turnBox.style.top = "43.9%";
                turnBox.style.width = "14.8%";
                turnBox.style.height = "4.2%";
                turnBox.style.zIndex = "30";
                turnBox.style.border = "0px solid white";
                turnBox.style.borderRadius = "4px";
                turnBox.style.transition = "background-color 1s ease";
                turnBox.style.opacity = "0";
            document.body.appendChild(turnBox);

            setTimeout(() => {
                turnBox.style.opacity = "1"; // Fades out smoothly
            }, 2700);

            const arsenalBox = document.createElement("div");
                arsenalBox.id = "playerArsenalBox";
                arsenalBox.className = "card-zone";
                arsenalBox.style.position = "absolute";
                arsenalBox.style.left = "34.2%";
                arsenalBox.style.top = "68.1%";
                arsenalBox.style.width = "49.9%";
                arsenalBox.style.height = "13.4%";
                arsenalBox.style.zIndex = "1000";
                arsenalBox.style.pointerEvents = "none";
            arsenalBox.style.backgroundColor = "rgba(255, 0, 0, 0)";
            document.body.appendChild(arsenalBox);

            const championBox = document.getElementById("playerChampionsBox");
                championBox.style.position = "fixed";
                championBox.style.left = "38%";
                championBox.style.top = "68%";
                championBox.style.width = "49.9%";
                championBox.style.height = "13.4%";
                championBox.style.zIndex = "100300"; // ensure it's above the board
                championBox.style.pointerEvents = "none";
                championBox.style.backgroundColor = "rgba(255, 0, 0, 0)"; // debug transparent background

            const reserveBox = document.createElement("div");
                reserveBox.id = "playerReserveBox";
                reserveBox.className = "card-zone";
                reserveBox.style.position = "absolute";
                reserveBox.style.left = "18%";
                reserveBox.style.top = "52.9%";
                reserveBox.style.width = "14.6%";
                reserveBox.style.height = "28.7%";
                reserveBox.style.zIndex = "1000";
                reserveBox.style.pointerEvents = "none";
            reserveBox.style.backgroundColor = "rgba(255, 0, 0, 0)";
            document.body.appendChild(reserveBox);

            fetchUserData().then(userData => {
                if (userData && userData.zoneArt) {
                    const zoneArtContainer = document.createElement("div");
                        zoneArtContainer.style.position = "absolute";
                        zoneArtContainer.style.left = "0";
                        zoneArtContainer.style.bottom = "0";
                        zoneArtContainer.style.width = "100%";
                        zoneArtContainer.style.height = "50%";
                        zoneArtContainer.style.overflow = "hidden";

                    const zoneArtImage = document.createElement("img");
                        zoneArtImage.src = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Zones/${userData.zoneArt}`;
                        zoneArtImage.style.position = "absolute";
                        zoneArtImage.style.width = "100%";
                        zoneArtImage.style.height = "200%"; // Double height so top half is offscreen
                        zoneArtImage.style.top = "0%"; // Shift to crop top, show only bottom half
                        zoneArtImage.style.left = "0";
                        zoneArtImage.style.zIndex = "10";
                        zoneArtImage.style.border = "6px solid black";
                        zoneArtImage.style.objectFit = "cover";
                    zoneArtContainer.appendChild(zoneArtImage);
                    board.appendChild(zoneArtContainer);
                }
            });

            // After all elements like playerDeckBox and deckText are added
            fetchUserData().then(userData => {
                if (userData && userData.deckSleeve) {
                    playerDeckBox.style.backgroundImage = `url(https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Sleeves/${userData.deckSleeve})`;
                    playerDeckBox.style.backgroundSize = "cover";
                    playerDeckBox.style.backgroundPosition = "center";
                    playerDeckBox.style.backgroundRepeat = "no-repeat";
                }
            });

            // Function to add a box
            function addBox(x, y, w, h, color="green", backColor="black", opa="0.5") {
                const box = document.createElement("div");
                    box.style.position = "absolute";
                    box.style.left = x;
                    box.style.top = y;
                    box.style.width = w;
                    box.style.height = h;
                    box.style.border = `4px solid ${color}`;
                    box.style.backgroundColor = `${backColor}`;
                    box.style.opacity = `${opa}`;
                    box.style.zIndex = "30";
                board.appendChild(box);
            }

            // Reproduce visual layout from image (values are approximate %)
            addBox("1%", "1%", "6%", "19%", "lightsalmon");     // Opponent Deck
            addBox("9%", "1%", "68%", "19%", "lightsalmon");    // Opponent Arsenal

            addBox("79%", "1%", "20%", "40%", "lightsalmon");   // Opponent Reserve

            addBox("1%", "22%", "6%", "19%", "lightsalmon");    // Opponent Tomb
            addBox("9%", "22%", "68%", "19%", "lightsalmon");   // Opponent Champions

            addBox("1%", "44%", "10%", "14%", "lightsalmon");    // Opponent Void

            addBox("14%", "47%", "72%", "7%", "lightgreen");    // Path
            //addBox("65.8%", "48%", "19.75%", "5%", "white","","1"); // Back of turn count, player turn

            addBox("89%", "44%", "10%", "14%", "lightblue");   // Player Void

            addBox("1%", "60%", "20%", "40%", "lightblue");   // Player Reserve

            addBox("23%", "60%", "68%", "19%", "lightblue");  // Player Champions
            addBox("93%", "60%", "6%", "19%", "lightblue");  // Player Tomb

            addBox("23%", "81%", "68%", "19%", "lightblue");  // Player Arsenal
            addBox("93%", "81%", "6%", "19%", "lightblue");  // Player Deck

            document.body.appendChild(overlay);
            document.body.appendChild(mainContainer);
            mainContainer.appendChild(board);
            mainContainer.appendChild(resultBox);

            // Fade out the result box after 3 seconds
            setTimeout(() => {
                resultBox.style.opacity = "0"; // Fades out smoothly
            }, 2000);

            const params = new URLSearchParams(window.location.search);
            const selectedTotem = params.get("totem");
            const selectedTotemText = params.get("totemText");

            document.getElementById("totem").textContent = selectedTotem;
            const totemTextElement = document.createElement("p");
                totemTextElement.innerHTML = `<strong>Description:</strong> ${selectedTotemText}`;
            document.getElementById("game-log-placeholder").appendChild(totemTextElement);

            const totemBox = document.createElement("div");
                totemBox.style.position = "absolute";
                totemBox.style.top = "46%";
                totemBox.style.left = "53%";
                totemBox.style.transform = "translate(-50%, -50%)";
                totemBox.style.padding = "16px 32px";
                totemBox.style.backgroundColor = "goldenrod";
                totemBox.style.color = "white";
                totemBox.style.fontSize = "1.5em";
                totemBox.style.borderRadius = "10px";
                totemBox.style.textAlign = "center";
                totemBox.style.opacity = "0"; // Start invisible
                totemBox.style.transition = "opacity 1s ease-in-out";
                totemBox.style.zIndex = "100900";
                totemBox.style.boxShadow = "0 0 20px black";
                totemBox.textContent = `Selected Totem: ${selectedTotem} - ${selectedTotemText}`;

            // Add to document
            document.body.appendChild(totemBox);

            // Trigger fade-in
            setTimeout(() => {
                totemBox.style.opacity = "1";
            }, 2500); // Slight delay after result box

            setTimeout(() => {
                totemBox.style.opacity = "0";
                totemBox.style.zIndex = "10";
            }, 6500);

            // Function to fetch user data from the session
            async function fetchUserData() {
                try {
                    const res = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/me', {
                        credentials: 'include'
                    });
                    if (!res.ok) throw new Error('Response error');

                    const data = await res.json();
                    if (!data.loggedIn) return null;

                    return data;
                } catch (err) {
                    console.error('Failed to fetch user data:', err);
                    return null;
                }
            }

            // Fetch deck and start game
            const playerDeckName = new URLSearchParams(window.location.search).get("playerDeck");
            const opponentDeckName = new URLSearchParams(window.location.search).get("opponentDeck");

            const playerDeckResult = await fetchDeckCards(playerDeckName);
            const opponentDeckResult = await fetchDeckCards(opponentDeckName);

            if (!playerDeckResult.success || !opponentDeckResult.success) {
                console.error("Deck fetch failed");
                return;
            }

            const playerDeck = playerDeckResult.card_ids;
            shuffleDeck(playerDeck);

            const opponentDeck = opponentDeckResult.card_ids;
            shuffleDeck(opponentDeck);

            if (playerDeckResult.success && opponentDeckResult.success) {
                await fetch('https://geimon-app-833627ba44e0.herokuapp.com/startGame', {
                    method: 'POST',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        gameId,
                        playerUsername: username,
                        opponentUsername: isSinglePlayer ? "Bot" : otherPlayerName,
                        playerDeck,
                        opponentDeck,
                        isSinglePlayer: true,
                        goesFirst: choice === "first" ? username : (isSinglePlayer ? "Bot" : otherPlayerName)
                    })
                });

                gameState = await waitForGameState();
                updateLocalFromGameState();

                setInterval(async () => {
                    await fetchGameStateFromServer();
                }, 1500);

                const opponentName = isSinglePlayer ? "Bot" : otherPlayerName;
                document.getElementById("player-name").textContent = username;
                document.getElementById("player-life").textContent = gameState[username].life;

                document.getElementById("opponent-name").textContent = opponentName;
                document.getElementById("opponent-life").textContent = gameState[opponentName].life;

                console.log("Creating game for", username, "vs", isSinglePlayer ? "Bot" : otherPlayerName);
                await fetchGameStateFromServer();
                if (!gameState || !gameState[username]) {
                    alert("Game could not be started.");
                    return;
                }

                if (gameState[username].Hand.length === 0) {
                    for (let i = 0; i < 5; i++) {
                        await drawCards(gameState[username].Deck, 1);
                    }
                    console.log("üÉè Drew 5 starting cards for", username);
                    await sendZoneUpdate(["Deck", "Hand"]);
                }

                updateDeckText();
            } else {
                console.error("Deck loading failed:", playerDeckResult.message);
            }
            await fetchGameStateFromServer();
        }

        async function fetchDeckCards(deckName) {
        if (deckName === "Random") {
            // Generate a random deck locally
            const cardPool = cards.map(card => card.id); // Extract all IDs
            const deckSize = Math.floor(Math.random() * 41) + 60; // Random between 60‚Äì100
            const shuffled = cardPool.sort(() => 0.5 - Math.random());
            const card_ids = shuffled.slice(0, deckSize);

            deckCount = `${card_ids.length}`;
            if (playerDeckBox) {
                playerDeckBox.innerText = "Deck";
            }

            return { success: true, card_ids };
        }

        // Fallback to real server call for named decks
        try {
            const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                method: "POST",
                credentials: 'include',
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ deck_name: deckName })
            });

            const data = await response.json();

            if (data.success) {
                deckCount = `${data.card_ids.length}`;
                if (playerDeckBox) {
                    playerDeckBox.innerText = "Deck";
                }
            } else {
                deckCount = data.message;
            }

            return data;
        } catch (error) {
            console.error("Error fetching deck cards:", error);
            return { success: false, message: 'Fetch error' };
        }
    }

    // Select the existing Player Deck box after it's created
    const playerDeckBox = document.createElement("div");
        playerDeckBox.id = "playerDeckBox";
        playerDeckBox.style.position = "absolute";
        playerDeckBox.style.left = "86.1%";
        playerDeckBox.style.top = "68.9%";
        playerDeckBox.style.width = "3.72%";
        playerDeckBox.style.height = "11.8%";
        //playerDeckBox.style.backgroundColor = "lightblue";
        playerDeckBox.style.outline = "2px solid white"; // Bright white outline for debugging
        playerDeckBox.style.display = "block"; // Ensure it's always visible
        playerDeckBox.style.zIndex = "1000"; // Bring it to the front layer
        playerDeckBox.style.opacity = "0"; // Start fully invisible
        playerDeckBox.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
        playerDeckBox.style.textAlign = "center"; // Ensures proper alignment
        playerDeckBox.style.fontWeight = "bold";
        playerDeckBox.style.fontSize = "1.2em";
        playerDeckBox.style.color = "white";
        playerDeckBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

    // Create the text span element separately
    const deckText = document.createElement("span");
        deckText.innerText = "Deck";
        deckText.style.position = "absolute"; // Positions independently inside the box
        deckText.style.left = "50%"; // Centers horizontally
        deckText.style.top = "70%"; // Moves text downward
        deckText.style.transform = "translate(-50%, -50%)"; // Ensures precise centering
    playerDeckBox.appendChild(deckText);
    document.body.appendChild(playerDeckBox); // Add to the document

    //Start of Tomb Box Stuff
    const playerTombBox = document.createElement("div");
        playerTombBox.id = "playerTombBox";
        playerTombBox.style.position = "absolute";
        playerTombBox.style.left = "86.1%";  // Same X as Deck
        playerTombBox.style.top = "53.7%";   // Directly above the Deck
        playerTombBox.style.width = "3.72%";
        playerTombBox.style.height = "11.8%";
        playerTombBox.style.outline = "none";//"4px solid white";
        playerTombBox.style.zIndex = "1000";
        playerTombBox.style.opacity = "0";
        playerTombBox.style.transition = "opacity 1s ease-in-out";
        playerTombBox.style.textAlign = "center";
        playerTombBox.style.fontWeight = "bold";
        playerTombBox.style.fontSize = "1.2em";
        playerTombBox.style.color = "white";
        playerTombBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

        const tombText = document.createElement("span");
            tombText.innerText = "Tomb";
            tombText.style.position = "absolute";
            tombText.style.left = "50%";
            tombText.style.top = "5%";
            tombText.style.transform = "translate(-50%, -50%)";
        playerTombBox.appendChild(tombText);
        document.body.appendChild(playerTombBox);

        setTimeout(() => {
        playerTombBox.style.opacity = "1";
        }, 6500);

        function updateTombText() {
            if (gameState && gameState[username]) {
                const count = gameState[username].Tomb.length;
                tombText.innerText = `${count}`;
            }
        }

        playerTombBox.addEventListener("mouseenter", updateTombText);
        playerTombBox.addEventListener("mouseleave", () => {
            tombText.innerText = "Tomb";
        });

    // Create Tomb Button Overlay
    const tombButton = document.createElement("button");
        tombButton.style.position = "absolute";
        tombButton.style.left = "86.1%";
        tombButton.style.top = "56%";
        tombButton.style.width = "3.72%";
        tombButton.style.height = "10%"; //addBox("93%", "60%", "6%", "19%", "lightblue");  // Player Tomb
        tombButton.style.backgroundColor = "rgba(255, 0, 0)";
        tombButton.style.opacity = "0";
        tombButton.style.border = "none";
        tombButton.style.zIndex = "100800";
        tombButton.style.cursor = "pointer";
        tombButton.title = "Tomb";

        // Add event listener for click
        tombButton.addEventListener("click", () => {
            const popup = document.createElement("div");
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.maxWidth = "min(90%, 800px)";
                popup.style.overflowY = "auto";
                popup.style.maxHeight = "unset";
                popup.style.height = "auto";
                popup.style.overflow = "visible";
                popup.style.padding = "10px 20px";
                popup.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
                popup.style.border = "3px solid white";
                popup.style.borderRadius = "12px";
                popup.style.zIndex = "100900";
                popup.style.display = "flex";
                popup.style.flexDirection = "column";
                popup.style.alignItems = "center";
                popup.style.gap = "20px";

            const title = document.createElement("div");
                title.textContent = "Tomb";
                title.style.color = "white";
                title.style.fontSize = "2em";
                title.style.textAlign = "center";
            popup.appendChild(title);

            const tombCards = gameState?.[username]?.Tomb || [];

            if (tombCards.length === 0) {
                const none = document.createElement("div");
                none.textContent = "Tomb is empty.";
                none.style.color = "white";
                popup.appendChild(none);
            } else {
                const cardContainer = document.createElement("div");
                    cardContainer.style.display = "flex";
                    cardContainer.style.flexWrap = "wrap";
                    cardContainer.style.justifyContent = "center";
                    cardContainer.style.gap = "10px";
                    cardContainer.style.maxWidth = "100%";
                    cardContainer.style.overflow = "visible";

                const scale = 0.3;
                const cardWidth = 240;
                const cardHeight = 420;

                tombCards.forEach(cardData => {
                    const card = cards.find(c => String(c.id) === String(cardData.id));
                    if (!card) return;

                    const scale = 0.3;
                    const scaledCard = renderCard(card);
                        scaledCard.style.transform = `scale(${scale})`;
                        scaledCard.style.transformOrigin = "top left";
                        scaledCard.style.margin = "5px";
                        scaledCard.style.position = "relative";

                    const wrapper = document.createElement("div");
                        wrapper.style.width = `${240 * scale}px`;
                        wrapper.style.height = `${420 * scale}px`;
                        wrapper.style.overflow = "visible";
                        wrapper.style.position = "relative";

                    // Tomb card click overlay
                    const overlay = document.createElement("button");
                        overlay.style.position = "absolute";
                        overlay.style.top = "0";
                        overlay.style.left = "0";
                        overlay.style.width = "100%";
                        overlay.style.height = "100%";
                        overlay.style.opacity = "0";
                        overlay.style.border = "none";
                        overlay.style.background = "transparent";
                        overlay.style.cursor = "pointer";
                    overlay.onclick = () => alert(`Card in Tomb Clicked: ${card.name}`);

                    wrapper.appendChild(scaledCard);
                    wrapper.appendChild(overlay);

                    // Hover preview
                    wrapper.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                            scaled.innerHTML = "";
                        const preview = renderCard(card);
                            preview.style.width = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop = "7%";
                        scaled.appendChild(preview);
                    });

                    cardContainer.appendChild(wrapper);
                });
                popup.appendChild(cardContainer);
            }

            const closeBtn = document.createElement("button");
                closeBtn.textContent = "Close";
                closeBtn.style.marginTop = "10px";
                closeBtn.style.padding = "10px 20px";
                closeBtn.style.fontSize = "1.2em";
                closeBtn.style.cursor = "pointer";
                closeBtn.style.zIndex = "120000";
            closeBtn.onclick = () => popup.remove();
            popup.appendChild(closeBtn);

            document.body.appendChild(popup);
    });

    document.body.appendChild(tombButton);
    //End of Tomb Creation Stuff

    //Start of Void Box Stuff
    const playerVoidBox = document.createElement("div");
        playerVoidBox.id = "playerVoidBox";
        playerVoidBox.style.position = "absolute";
        playerVoidBox.style.left = "83%";  // Same X as Deck
        playerVoidBox.style.top = "42%";   // Directly above the Deck
        playerVoidBox.style.width = "7%";
        playerVoidBox.style.height = "9%";
        playerVoidBox.style.outline = "none";//"4px solid white";
        playerVoidBox.style.zIndex = "1000";
        //playerVoidBox.style.backgroundColor = "rgba(255, 0, 0)";
        playerVoidBox.style.opacity = "0";
        playerVoidBox.style.transition = "opacity 1s ease-in-out";
        playerVoidBox.style.textAlign = "center";
        playerVoidBox.style.fontWeight = "bold";
        playerVoidBox.style.fontSize = "1.2em";
        playerVoidBox.style.color = "white";
        playerVoidBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

        const voidText = document.createElement("span");
        voidText.innerText = "Void";
        voidText.style.position = "absolute";
        voidText.style.left = "50%";
        voidText.style.top = "5%";
        voidText.style.transform = "translate(-50%, -50%)";

        playerVoidBox.appendChild(voidText);
        document.body.appendChild(playerVoidBox);

        setTimeout(() => {
        playerVoidBox.style.opacity = "1";
        }, 6500);

        function updateVoidText() {
            if (gameState && gameState[username]) {
                const count = gameState[username].Void.length;
                voidText.innerText = `${count}`;
            }
        }

        playerVoidBox.addEventListener("mouseenter", updateVoidText);
        playerVoidBox.addEventListener("mouseleave", () => {
            voidText.innerText = "Void";
        });

    // Create Void Button Overlay
    const voidButton = document.createElement("button");
        voidButton.style.position = "absolute";
        voidButton.style.left = "83%";
        voidButton.style.top = "43.7%";
        voidButton.style.width = "7%";
        voidButton.style.height = "7.2%"; //addBox("89%", "44%", "10%", "14%", "lightblue");   // Player Void
        voidButton.style.backgroundColor = "rgba(255, 0, 0)";
        voidButton.style.opacity = "0";
        voidButton.style.border = "none";
        voidButton.style.zIndex = "100800";
        voidButton.style.cursor = "pointer";
        voidButton.title = "Void";

        // Add event listener for click
        voidButton.addEventListener("click", () => {
            const popup = document.createElement("div");
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.maxWidth = "min(90%, 800px)";
                popup.style.overflowY = "auto";
                popup.style.maxHeight = "unset";
                popup.style.height = "auto";
                popup.style.overflow = "visible";
                popup.style.padding = "10px 20px";
                popup.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
                popup.style.border = "3px solid white";
                popup.style.borderRadius = "12px";
                popup.style.zIndex = "100900";
                popup.style.display = "flex";
                popup.style.flexDirection = "column";
                popup.style.alignItems = "center";
                popup.style.gap = "20px";

            const title = document.createElement("div");
                title.textContent = "Void";
                title.style.color = "white";
                title.style.fontSize = "2em";
                title.style.textAlign = "center";
            popup.appendChild(title);

            const voidCards = gameState?.[username]?.Void || [];

            if (voidCards.length === 0) {
                const none = document.createElement("div");
                none.textContent = "Void is empty.";
                none.style.color = "white";
                popup.appendChild(none);
            } else {
                const cardContainer = document.createElement("div");
                    cardContainer.style.display = "flex";
                    cardContainer.style.flexWrap = "wrap";
                    cardContainer.style.justifyContent = "center";
                    cardContainer.style.gap = "10px";
                    cardContainer.style.maxWidth = "100%";
                    cardContainer.style.overflow = "visible";

                const scale = 0.3;
                const cardWidth = 240;
                const cardHeight = 420;

                voidCards.forEach(cardData => {
                    const card = cards.find(c => String(c.id) === String(cardData.id));
                    if (!card) return;

                    const scale = 0.3;
                    const scaledCard = renderCard(card);
                        scaledCard.style.transform = `scale(${scale})`;
                        scaledCard.style.transformOrigin = "top left";
                        scaledCard.style.margin = "5px";
                        scaledCard.style.position = "relative";

                    const wrapper = document.createElement("div");
                        wrapper.style.width = `${240 * scale}px`;
                        wrapper.style.height = `${420 * scale}px`;
                        wrapper.style.overflow = "visible";
                        wrapper.style.position = "relative";

                    // Void card click overlay
                    const overlay = document.createElement("button");
                        overlay.style.position = "absolute";
                        overlay.style.top = "0";
                        overlay.style.left = "0";
                        overlay.style.width = "100%";
                        overlay.style.height = "100%";
                        overlay.style.opacity = "0";
                        overlay.style.border = "none";
                        overlay.style.background = "transparent";
                        overlay.style.cursor = "pointer";
                    overlay.onclick = () => alert(`Card in Void Clicked: ${card.name}`);

                    wrapper.appendChild(scaledCard);
                    wrapper.appendChild(overlay);

                    // Hover preview
                    wrapper.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                            scaled.innerHTML = "";
                        const preview = renderCard(card);
                            preview.style.width = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop = "7%";
                        scaled.appendChild(preview);
                    });

                    cardContainer.appendChild(wrapper);
                });
                popup.appendChild(cardContainer);
            }

            const closeBtn = document.createElement("button");
                closeBtn.textContent = "Close";
                closeBtn.style.marginTop = "10px";
                closeBtn.style.padding = "10px 20px";
                closeBtn.style.fontSize = "1.2em";
                closeBtn.style.cursor = "pointer";
                closeBtn.style.zIndex = "120000";
            closeBtn.onclick = () => popup.remove();
            popup.appendChild(closeBtn);

            document.body.appendChild(popup);
    });

    document.body.appendChild(voidButton);
    //End of Void Stack Creation

    // Create Surrender Button Overlay
    const surrenderButton = document.createElement("button");
        surrenderButton.style.position = "absolute";
        surrenderButton.style.left = "86.1%";
        surrenderButton.style.top = "72%";
        surrenderButton.style.width = "3.72%";
        surrenderButton.style.height = "9%";//addBox("93%", "81%", "6%", "19%", "lightblue");  // Player Deck
        surrenderButton.style.backgroundColor = "rgba(255, 0, 0)";
        surrenderButton.style.opacity = "0";
        surrenderButton.style.border = "none";
        surrenderButton.style.zIndex = "1001";
        surrenderButton.style.cursor = "pointer";
        surrenderButton.title = "Surrender";

    // Add event listener for click
    surrenderButton.addEventListener("click", () => {
        const confirmBox = document.createElement("div");
        confirmBox.style.position = "fixed";
        confirmBox.style.top = "50%";
        confirmBox.style.left = "50%";
        confirmBox.style.transform = "translate(-50%, -50%)";
        confirmBox.style.padding = "20px";
        confirmBox.style.backgroundColor = "#333";
        confirmBox.style.color = "white";
        confirmBox.style.border = "2px solid red";
        confirmBox.style.borderRadius = "10px";
        confirmBox.style.zIndex = "100900";
        confirmBox.style.textAlign = "center";
        confirmBox.style.boxShadow = "0 0 10px black";

        confirmBox.innerHTML = `
            <p style="margin-bottom: 20px;">Are you sure you'd like to surrender?</p>
            <button id="confirm-surrender" style="margin-right: 10px;">Surrender</button>
            <button id="cancel-surrender">Cancel</button>
        `;

        document.body.appendChild(confirmBox);

        document.getElementById("confirm-surrender").onclick = async () => {
            try {
                await fetch("https://geimon-app-833627ba44e0.herokuapp.com/endGame", {
                    method: "POST",
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        gameId,
                        loser: username,
                        reason: "Surrendered"
                    })
                });

                showLossBanner("You Lose", "Surrendered");
                document.body.removeChild(confirmBox);
            } catch (err) {
                console.error("Error ending game:", err);
                alert("Failed to surrender. Please try again.");
            }
        };

        document.getElementById("cancel-surrender").onclick = () => {
            document.body.removeChild(confirmBox);
        };
    });

    document.body.appendChild(surrenderButton);

        setTimeout(() => {
            playerDeckBox.style.opacity = "1";
        }, 6500);
        let deckCount = "Deck";

    // Ensure it exists before adding event listeners
    if (playerDeckBox) {
        playerDeckBox.style.display = "block";
        playerDeckBox.style.outline = "4px solid white";

        playerDeckBox.addEventListener("mouseenter", () => {
            playerDeckBox.innerText = deckCount;
        });

        // Mouse leave resets to "Deck"
        playerDeckBox.addEventListener("mouseleave", () => {
            playerDeckBox.innerText = "Deck";
        });
    }

    // Fetch deck count dynamically
    setTimeout(async () => {
        const urlParams = new URLSearchParams(window.location.search);

        async function getDeckFromParam(paramName) {
            const paramValue = urlParams.get(paramName);
            try {
                const parsed = JSON.parse(paramValue);
                if (Array.isArray(parsed)) {
                    return parsed; // Already a full random deck
                }
            } catch (e) {
                const result = await fetchDeckCards(paramValue);
                if (result.success) return result.card_ids;
                console.error(`Failed to load deck '${paramName}':`, result.message);
                return [];
            }
        }

        const playerDeckCardIds = await getDeckFromParam("playerDeck");
        const opponentDeckCardIds = await getDeckFromParam("opponentDeck");

        // You can now use these arrays:
        console.log("Player Deck:", playerDeckCardIds);
        console.log("Opponent Deck:", opponentDeckCardIds);

        // Optionally continue setup:
        // startGameWithDecks(playerDeckCardIds, opponentDeckCardIds);
    }, 200);


        let remainingDeck = []; // Store shuffled deck globally
        let drawnCardsArray = []; // Track drawn cards separately
        let initialDeckSize = 0; // Store starting deck size globally
        let gameState = null;


        // Function to update deck text dynamically
        function updateDeckText() {
            if (deckText) {
                deckText.innerText = `Deck (${remainingDeck.length}/${initialDeckSize})`; // Correct dynamic update
            }
        }

        // Function to shuffle the deck using Fisher-Yates algorithm
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        const CHAMPION_ZONE = "Zone (Champion)";
        async function handleBasicRally(card) {
            console.log("üîµ handleBasicRally invoked for:", card);

            if (!isBasicRallyAvailable(card, gameState.turn.currentPhase, gameState, username)) {
                console.warn("‚õî Rally not available for:", card.name);
                return;
            }

            const ralliedCard = gameState[username].Hand.find(c => String(c.id) === String(card.id));
            if (!ralliedCard) {
                console.warn("‚ùå Card not found in Hand for rally:", card.id);
                return;
            }
            Object.assign(ralliedCard, card);

            console.log("‚úÖ Card found in Hand. Proceeding with rally...");

            ralliedCard.lastBoardState = "Hand";
            ralliedCard.boardState = "Zone";

            // Remove from hand
            gameState[username].Hand = gameState[username].Hand.filter(c => c.id !== ralliedCard.id);

            // Add to champion zone
            gameState[username][CHAMPION_ZONE].push(ralliedCard);
            gameState[username].hasBasicRallied = true;

            // ‚úÖ 1. Trigger ability hooks (important for rally effects like OnRally)
            AbilityExecutor.handleBoardStateChange(
                ralliedCard,
                ralliedCard.boardState,
                ralliedCard.lastBoardState,
                gameState,
                username,
                gameId,
                updateLocalFromGameState,
                addGameLogEntry
            );

        try {
            // Post update
            const res = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/updateGameState", {
            method: "POST",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                gameId,
                owner: username,
                updatedZones: {
                Hand: gameState[username].Hand,
                [CHAMPION_ZONE]: gameState[username][CHAMPION_ZONE],
                hasBasicRallied: true
                }
            })
        });
            // ‚úÖ Read and apply server response
            const responseJson = await res.json();

            // Optional: log entire response
            console.log("üì• Server responded with:", responseJson);

            // ‚úÖ Expect the backend to return updated player zone data
            if (responseJson?.updatedPlayerZone) {
                gameState[username] = responseJson.updatedPlayerZone;
                updateLocalFromGameState();
            } else {
                console.warn("‚ö†Ô∏è Server did not return updatedPlayerZone. Falling back to manual update.");
                updateLocalFromGameState();
            }

            addGameLogEntry(`${username} performed a Basic Rally with ${card.name}`);
        } catch (err) {
            console.error("üí• Error sending rally update:", err);
        }
        updateAllRallyHighlights();
    }

        function renderDrawnCards() {
            const drawnCardsContainer = document.getElementById("drawn-cards");
            const scaledCardContainer = document.getElementById("scaled-card");
            const viewingWindow = document.getElementById("viewing-window");
            const contextWindow = document.getElementById("context-window");
            const playerLifeWindow = document.getElementById("player-life-window");
            const opponentLifeWindow = document.getElementById("opponent-life-window");
            const phaseTracker = document.getElementById("phase-tracker");
            const turnCounter = document.getElementById("turn-counter");
            const currentPhase = gameState?.turn?.currentPhase;

            drawnCardsContainer.innerHTML = ""; // Clear previous renders

            if (drawnCardsArray.length === 0) {
                console.log("No cards have been drawn yet.");
                return;
            }

            // Sort drawn cards (optional, as you had)
            drawnCardsArray.sort((a, b) => {
                const cardA = cards.find(c => String(c.id) === String(a.id));
                const cardB = cards.find(c => String(c.id) === String(b.id));
                if (!cardA || !cardB) return 0;

                const typeOrder = ["Champion", "Action", "Equipment", "Obelisk", "Rush", "Reflex"];
                const indexA = typeOrder.indexOf(cardA.type);
                const indexB = typeOrder.indexOf(cardB.type);

                if (indexA !== indexB) return indexA - indexB;
                return cardA.name.localeCompare(cardB.name);
            });

        // --- Helper functions (moved outside the loop) ---

        function updateBasicRallyHighlight(cardElement, cardData, currentPhase, gameState, username) {
            if (isBasicRallyAvailable(cardData, currentPhase, gameState, username)) {
                console.log("üîµ Adding glow to", cardData.name);
                cardElement.classList.add("basic-rally-highlight");
            } else {
                console.log("‚ö™ Removing glow from", cardData.name);
                cardElement.classList.remove("basic-rally-highlight");
            }
        }

        function updateAllRallyHighlights(currentPhase, gameState, username) {
            const cardElements = document.querySelectorAll(".card");
            cardElements.forEach(cardEl => {
                const cardId = cardEl.dataset.cardId;
                // Look up the full card by ID from full cards array
                const fullCard = cards.find(c => String(c.id) === String(cardId));
                if (!fullCard) {
                    console.warn("Card data not found for rally highlight ID:", cardId);
                    return;
                }
                updateBasicRallyHighlight(cardEl, fullCard, currentPhase, gameState, username);
            });
        }

            // --- Now render each drawn card ---

            drawnCardsArray.forEach(cardObj => {
                const card = cards.find(c => String(c.id) === String(cardObj.id));
                if (!card) return;

                const cardElement = renderCard(card);
                cardElement.dataset.boardState = cardObj.boardState;
                cardElement.dataset.lastBoardState = cardObj.lastBoardState;
                cardElement.dataset.cardId = String(card.id); // Ensure this is set for lookup!
                cardElement.style.transform = "scale(0.5)";
                cardElement.style.position = "relative";
                cardElement.style.marginLeft = "-15%";
                cardElement.style.opacity = "1";
                cardElement.style.transition = "opacity 1s ease-in-out";

                // Invisible button to capture clicks
                const cardButton = document.createElement("button");
                cardButton.classList.add("card-button");
                cardButton.style.position = "absolute";
                cardButton.style.top = "0";
                cardButton.style.right = "0";
                cardButton.style.width = "100%";
                cardButton.style.height = "100%";
                cardButton.style.opacity = "0";
                cardButton.style.background = "transparent";
                cardButton.style.border = "none";
                cardButton.style.pointerEvents = "auto";
                cardButton.style.padding = "5px";
                cardButton.style.zIndex = "100100";

                cardButton.onclick = () => {
                    console.log("Card button clicked");
                    const parentCard = cardButton.closest(".card");
                    const cardId = parentCard?.dataset.cardId;

                    if (!cardId) {
                        console.warn("‚ùå No cardId found on clicked card");
                        return;
                    }

                    if (discardMode) {
                        return handleCardDiscard(gameState, username, cards, gameId, currentPhase, updateLocalFromGameState, addGameLogEntry, updatePhaseDisplay);
                    }

                    const fullCard = cards.find(c => String(c.id) === String(cardId));
                    if (!fullCard) {
                        console.warn("‚ùå Card not found in cards array:", cardId);
                        return;
                    }

                    if (isBasicRallyAvailable(fullCard, currentPhase, gameState, username)) {
                        handleBasicRally(fullCard); // ‚úÖ Trigger rally!
                    }

                    updateAllRallyHighlights(currentPhase, gameState, username);
                };

                cardButton._originalHandler = cardButton.onclick;

                // Initial highlight check for this card
                updateBasicRallyHighlight(cardElement, card, currentPhase, gameState, username);

                // Hover effect for preview
                cardElement.addEventListener("mouseenter", () => {
                    scaledCardContainer.innerHTML = "";
                    const clone = cardElement.cloneNode(true);
                    const cloneButton = clone.querySelector(".card-button");
                    if (cloneButton) cloneButton.remove();
                    clone.style.transform = "scale(1.2)";
                    clone.style.width = "100%";
                    clone.style.position = "relative";
                    scaledCardContainer.appendChild(clone);
                    addTooltipListeners(clone);
                    addTokenTooltipListeners(clone);
                });

                cardElement.appendChild(cardButton);
                drawnCardsContainer.appendChild(cardElement);

                // Fade in after render
                setTimeout(() => {
                    cardElement.style.opacity = "1";
                    cardButton.style.opacity = "1";
                    cardButton.style.cursor = "pointer";
                }, 1500);
            });

            // Fade in UI overlays
            setTimeout(() => {
                viewingWindow.style.opacity = "1";
                contextWindow.style.opacity = "1";
                playerLifeWindow.style.opacity = "1";
                opponentLifeWindow.style.opacity = "1";
                phaseTracker.style.opacity = "1";
                turnCounter.style.opacity = "1";
            }, 2500);
        }

        function isBasicRallyAvailable(card, currentPhase, gameState, username) {
            console.log("=== Checking Basic Rally ===");
            console.log("currentPhase:", currentPhase);
            console.log("gameState.turn:", gameState.turn, "username:", username);
            console.log("card.cost:", card.cost);
            console.log("hasBasicRallied:", gameState[username]?.hasBasicRallied);
            console.log("User zone data:", gameState[username]);
            const isMainPhase = currentPhase.toLowerCase().startsWith("main") && gameState?.turn?.currentPlayer === username;
            const cost = String(card.cost || "").toLowerCase();
            const hasRallied = gameState[username]?.hasBasicRallied === true;
            return isMainPhase && cost === "basic" && !hasRallied;
        }

        async function updatePhaseDisplay(currentPhase) {
            const turnCount = gameState?.turn?.count || 0;
            const currentPlayer = gameState?.turn?.currentPlayer;
            const isPlayerTurn = currentPlayer === username;

            // Define valid transitions
            const allowedTransitions = {
                "Intermission": ["Draw"],
                "Draw": ["Main 1"],
                "Main 1": ["Battle", "End"],
                "Battle": ["Main 2"],
                "Main 2": ["End"]
            };

            document.querySelectorAll('.phase-box').forEach(box => {
                const phase = box.textContent.trim();
                box.classList.remove('active');
                if (turnCount === 1 && (phase === "Battle" || phase === "Main 2")) {
                    box.style.backgroundColor = "darkred";
                    box.style.cursor = "not-allowed";
                    return;
                }
                if (!isPlayerTurn) {
                    box.style.cursor = "not-allowed";
                    box.style.backgroundColor = "dimgray";
                    return;
                }
                const validNextPhases = allowedTransitions[currentPhase] || [];
                if (validNextPhases.includes(phase)) {
                    box.style.cursor = "pointer";
                    box.style.backgroundColor = "lightgray";
                } else {
                    box.style.cursor = "not-allowed";
                    box.style.backgroundColor = "dimgray";
                }
            });

            const activeBox = document.getElementById(`phase-${currentPhase}`);
            if (activeBox) {
                activeBox.classList.add('active');
                activeBox.style.backgroundColor = "lightgreen";
            }

            const turnNum = gameState.turn?.count;

            if (
                currentPhase === "Intermission" &&
                isPlayerTurn &&
                turnNum !== lastLoggedIntermissionTurn
            ) {
                addGameLogEntry(`${username}'s turn. Turn #${turnNum}`);
                addGameLogEntry(`${username} changed phase to Intermission`);
                lastLoggedIntermissionTurn = turnNum; // ‚úÖ Prevent duplicate logs
                if (gameState[username]) {
                    gameState[username].hasBasicRallied = false;
                    await fetch("https://geimon-app-833627ba44e0.herokuapp.com/updateGameState", {
                        method: "POST",
                        credentials: "include",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            gameId,
                            owner: username,
                            updatedZones: {
                                hasBasicRallied: false
                            }
                        })
                    });
                    console.log("üîÑ Reset hasBasicRallied for", username);
                }
            }
            if (currentPhase === "Main 1" || currentPhase === "Main 2") {
                renderDrawnCards();
            }
        }
        async function drawCards(deck, numCards = 5) {
        if (deck.length < numCards) {
            console.warn("Not enough cards left to draw.");
            return [];
        }

        function getCardsFromZone(zone, count) {
            return zone.splice(0, count);
        }

        function renderZone(zoneName, owner = username) {
            const cards = gameState[owner][zoneName];
        }

        const drawnCards = getCardsFromZone(gameState[username].Deck, numCards);
        drawnCards.forEach(card => {
            card.lastBoardState = card.boardState;
            card.boardState = "Hand";
        });
        gameState[username].Hand.push(...drawnCards);

        // Debugging logs for confirmation
        console.log("Initial Hand:", drawnCards);
        console.log("Remaining Deck Contents:", deck);

        await sendZoneUpdate(["Deck", "Hand"]);

        renderDrawnCards();
        updateDeckText();
        return drawnCards;
        }

        async function sendZoneUpdate(zones) {
            const updatedZones = {};
            zones.forEach(z => {
                updatedZones[z] = gameState[username][z];
            });

            await fetch('https://geimon-app-833627ba44e0.herokuapp.com/updateGameState', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    gameId,
                    updatedZones,
                    owner: username
                })
            });
        }

        // Function to update deck count visually
        function updateDeckCount() {
            if (playerDeckBox) {
                playerDeckBox.innerText = `Deck`;
            }
        }

        function renderCardZone(cardsArray, containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;

                container.innerHTML = ""; // Clear previous

                if (!cardsArray || cardsArray.length === 0) return;

                // Optional: sort or center-spread logic
                const half = Math.floor(cardsArray.length / 2);
                const ordered = [];

                for (let i = 0; i < cardsArray.length; i++) {
                    const offset = i % 2 === 0 ? i / 2 : -(Math.ceil(i / 2));
                    ordered.push(cardsArray[half + offset] || cardsArray[half - offset]);
                }

                ordered.forEach(cardData => {
                    const card = cards.find(c => String(c.id) === String(cardData.id));
                    if (!card) return;

                    const element = renderCard(card);
                        element.style.transform = "scale(0.3)";
                        element.style.marginLeft = "-19%";
                        element.style.transformOrigin = "top center";
                        element.style.position = "relative";
                        element.style.pointerEvents = "auto";
                    container.appendChild(element);

                    element.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                        scaled.innerHTML = "";

                        const preview = renderCard(card);
                        preview.style.width = "240px";
                        preview.style.height = "420px";
                        preview.style.transform = "scale(1.2)";
                        preview.style.marginLeft = "-15%";
                        preview.style.marginTop = "7%";

                        scaled.appendChild(preview);
                    });
                });
            }

        function changeLife(player, amount) {
            if (!gameState[player]) return;
            gameState[player].life += amount;

            // Update display
            if (player === username) {
                document.getElementById("player-name").textContent = username;
                document.getElementById("player-life").textContent = `${gameState[username].life}`;
            } else {
                document.getElementById("opponent-name").textContent = opponentName;
                document.getElementById("player-life").textContent = `${gameState[username].life}`;
            }

            sendLifeUpdate();
        }

        async function sendLifeUpdate() {
            await fetch('https://geimon-app-833627ba44e0.herokuapp.com/updateGameState', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    gameId,
                    updatedZones: {
                        life: gameState[username].life
                    },
                    owner: username
                })
            });
        }

        // Fetch and shuffle deck, then update count
        async function fetchAndShuffleDeck(deckParam) {
            let cardIds = [];

            try {
                // Try to parse as a JSON array
                const parsed = JSON.parse(deckParam);
                if (Array.isArray(parsed)) {
                    cardIds = parsed;
                } else {
                    // Fallback to server fetch
                    const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                        method: "POST",
                        credentials: "include",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({ deck_name: deckParam }),
                    });

                    const data = await response.json();
                    if (!data.success) {
                        console.error("Error:", data.message);
                        return;
                    }

                    cardIds = data.card_ids;
                }
            } catch (e) {
                // Not valid JSON ‚Äî must be a normal deck name
                const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                    method: "POST",
                    credentials: "include",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ deck_name: deckParam }),
                });

                const data = await response.json();
                if (!data.success) {
                    console.error("Error:", data.message);
                    return;
                }

                cardIds = data.card_ids;
            }

            // At this point, cardIds is valid
            initialDeckSize = cardIds.length;
            remainingDeck = shuffleDeck(cardIds).map(id => ({
                id,
                boardState: "Deck",
                lastBoardState: null
            }));

            console.log("Deck Shuffled:", remainingDeck);
            console.log("Total Cards in Deck:", initialDeckSize);
        }

        // Attach event listeners to update deck count dynamically
        if (playerDeckBox) {
            playerDeckBox.addEventListener("mouseenter", () => {
                playerDeckBox.innerText = `${remainingDeck.length}`;
            });

            playerDeckBox.addEventListener("mouseleave", () => {
                playerDeckBox.innerText = "Deck";
            });
        }

    document.addEventListener("DOMContentLoaded", () => {
        const tooltip = document.getElementById("tooltip");
        const tokenTooltip = document.getElementById("token-tooltip");

        const tabs = document.querySelectorAll(".tab-button");
        const contents = document.querySelectorAll(".tab-content");

        tabs.forEach(tab => {
            tab.addEventListener("click", () => {
                tabs.forEach(t => t.classList.remove("active"));
                contents.forEach(c => c.classList.remove("active"));

                tab.classList.add("active");
                document.getElementById(tab.dataset.tab).classList.add("active");
            });
        });

        // Game Log Data Population
        const params = new URLSearchParams(window.location.search);
        document.getElementById("totem").textContent = params.get("totem");

        const dictionarySearch = document.getElementById("dictionary-search");
        const dictionaryResults = document.getElementById("dictionary-results");

        const loadAllTerms = () => {
            dictionaryResults.innerHTML = "";
            const allTerms = [...Object.entries(keywords), ...Object.entries(rules)];
            allTerms.sort((a, b) => a[0].localeCompare(b[0]));
            allTerms.forEach(([key, value]) => {
                const resultItem = document.createElement("p");
                resultItem.innerHTML = `<strong>${key}:</strong> ${value}`;
                dictionaryResults.appendChild(resultItem);
            });
        };
        loadAllTerms();

        dictionarySearch.addEventListener("input", () => {
            const query = dictionarySearch.value.toLowerCase();
            dictionaryResults.innerHTML = "";

            if (!query) {
                loadAllTerms();
                return;
            }

            const matchedKeywords = Object.entries(keywords).filter(([key]) =>
                key.toLowerCase().includes(query)
            );

            const matchedRules = Object.entries(rules).filter(([key]) =>
                key.toLowerCase().includes(query)
            );

            [...matchedKeywords, ...matchedRules].forEach(([key, value]) => {
                const resultItem = document.createElement("p");
                resultItem.innerHTML = `<strong>${key}:</strong> ${value}`;
                dictionaryResults.appendChild(resultItem);
            });
        });

        document.querySelectorAll(".keyword").forEach(keyword => {
            const description = keyword.dataset.description;

            if (description && description.trim() !== "") {
                keyword.addEventListener("mouseenter", (e) => {
                    tooltip.textContent = description;
                    tooltip.style.display = "block";
                    tokenTooltip.querySelector(".token-tooltip-text").textContent = description;
                    tokenTooltip.style.display = "block";
                });

                keyword.addEventListener("mouseleave", () => {
                    tooltip.style.display = "none";
                    tokenTooltip.style.display = "none";
                });

                keyword.addEventListener("mousemove", (e) => {
                    if (tooltip.style.display === "block") {
                        tooltip.style.left = `${e.pageX + 10}px`;
                        tooltip.style.top = `${e.pageY - 40}px`;
                    }
                    if (tokenTooltip.style.display === "block") { // ‚úÖ Fix: Remove `else if`
                        tokenTooltip.style.left = `${e.pageX + 10}px`;
                        tokenTooltip.style.top = `${e.pageY - 40}px`;
                    }
                });
            }
        });
    });
    initGameClient();
    </script>
</body>
</html>