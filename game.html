<!DOCTYPE html>
<html lang=""en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv=""X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
    <link rel="icon" href="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/favicon.png" type="image/png">
    <link rel="stylesheet" href="style.css">
    <title>ACTIVE GAME</title>
</head>
<style>
  #coin {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    transition: transform 0.1s;
}
  #drawn-cards {
    position: fixed;
    bottom: 2%; /* Positions the cards near the bottom */
    left: 50%;
    transform: translate(-25%, 30%);
    display: flex;
    flex-direction: row; /* Aligns cards in a horizontal row */
    align-items: center;
    z-index: 9999; /* Places it over everything */
    gap: -5%; /* Allows 5% overlap */
}
.card {
    width: 240px; /* Reduces card size */
    height: 420px;
    position: relative; /* Ensures controlled placement */
    margin-left: -5%; /* Overlaps cards by 5% */
}
.viewing-window {
    position: fixed;
    left: 0.5%; /* Keeps it on the left */
    top: 25%;
    transform: translateY(-50%);
    width: 280px; /* Size for zoomed card */
    height: 440px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #1e1e1e;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110; /* Ensures it's on top */
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.context-window {
    position: fixed;
    left: 0.5%;
    top: 75%;
    transform: translateY(-50%);
    width: 280px;
    height: 440px;
    display: flex;
    flex-direction: column;
    background-color: #1e1e1e;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.player-life-window {
    position: fixed;
    left: 93%;
    top: 58.5%;
    transform: translateY(-50%);
    width: 100px;
    height: 100px;
    display: flex;
    flex-direction: column;
    background-color: #2d1eff;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.opponent-life-window {
    position: fixed;
    left: 93%;
    top: 32%;
    transform: translateY(-50%);
    width: 100px;
    height: 100px;
    display: flex;
    flex-direction: column;
    background-color: #970000;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.tabs {
    display: flex;
    justify-content: space-around;
    padding: 5px;
}
.tab-button {
    padding: 5px;
    cursor: pointer;
    background: #505050;
    color: white;
    border: none;
    border-radius: 5px;
}
.tab-button.active {
    background: #838383;
}
.tab-content-container {
    flex-grow: 1;
    padding: 10px;
    overflow-y: auto;
}
.tab-content {
    display: none;
    color: white;
}
.tab-content.active {
    display: block;
}
#viewing-window .scaled-card {
    pointer-events: auto !important;
    z-index: 100110; /* Ensures it's on top */
}
#viewing-window .scaled-card .card-cost,
#viewing-window .scaled-card .card-text,
#viewing-window .scaled-card .card-name,
#viewing-window .scaled-card .card-condition,
#viewing-window .scaled-card .card-tags,
#viewing-window .scaled-card .bottom-bar,
#viewing-window .scaled-card .card-image {
    z-index: 100200 !important;
}
.tooltip {
    z-index: 100300 !important;
}
#tooltip {
    position: absolute;
    display: none;
    background-color: rgba(0, 0, 0, 1);
    color: white;
    padding: 5px;
    border-radius: 5px;
    font-size: 14px;
    max-width: 250px;
    z-index: 100300; /* Ensure it appears above other elements */
}
.token-tooltip {
    pointer-events: auto !important;
    z-index: 100300 !important;
}
#token-tooltip {
    z-index: 100300; /* Ensure it appears above other elements */
}
.keyword {
    pointer-events: auto !important;
    position: relative; /* Ensures proper hovering */
    z-index: 100300; /* Ensures tooltip appears above other elements */
}
.card-cost .keyword {
    position: relative;
    z-index: 100300 !important;
    pointer-events: auto !important;
}
.card-cost {
    pointer-events: auto !important;
    z-index: 100000 !important;
}
.card-text {
    pointer-events: auto !important;
    z-index: 100000 !important;
}
.scaled-card .card-button {
    display: none !important;
}
.life {
    color: white;
    text-align: center;
    font-weight: bold;
    font-size: 4em;
}
.player-name,
.opponent-name {
    color: white;
    font-size: 1.1em;
    text-align: center;
    font-weight: bold;
    overflow: hidden;          /* Hide overflowed content */
    text-overflow: ellipsis;   /* Show ... when text overflows */
    white-space: nowrap;       /* Prevent text from wrapping */
    max-width: 100%;           /* Optional: control how much space the text gets */
    display: inline-block;     /* Required for ellipsis to take effect */
}
#loss-banner {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0,0,0,0.8);
    padding: 40px 80px;
    border-radius: 16px;
    color: white;
    text-align: center;
    font-family: sans-serif;
    z-index: 9999;
    display: none;
}
#loss-banner .main {
    font-size: 3em;
    font-weight: bold;
    margin-bottom: 10px;
}
#loss-banner .reason {
    font-size: 1.5em;
}
#phase-tracker {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin: 10px auto;
  padding: 10px;
  position: fixed;
  top: 42%;
  left: 46.5%;
  transform: translateX(-50%);
  z-index: 100700;
  opacity: 0;
}
.phase-box {
  padding: 10px 14px;
  background: dimgray;
  color: white;
  border-radius: 6px;
  font-weight: bold;
  min-width: 90px;
  text-align: center;
  transition: background 0.3s;
}
.phase-box.active {
  background: lightgreen;
}
#advance-phase {
  position: fixed;
  top: 44%;
  left: 67%;
  z-index: 100600;
  background: #5e9e5e;
  color: white;
  padding: 10px 20px;
  border: none;
  font-weight: bold;
  border-radius: 8px;
  cursor: pointer;
  opacity: 0;
}
#turn-counter {
  position: fixed;
  top: 44.5%;
  left: 76%; /* adjust this to line up visually with the button */
  z-index: 100600;
  color: white;
  font-weight: bold;
  font-size: 1.5em;
  opacity: 0;
  text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;
}
</style>
<body style="background-color:rgb(78, 78, 78);">
  <img src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/try_2.png" class="bg-image" alt="">
        <div id="coin-flip-container" style="display: none; text-align: center; margin-top: 50px;">
            <img id="coin" src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png" alt="coin" style="width: 150px; height: 150px;">
            <h2 id="flip-result" style="display: none;"></h2>
        </div>
        <div id="tooltip" class="tooltip"></div>
        <div id="token-tooltip" style="display: none; position: absolute;">
            <div class="token-tooltip-text" style="font-family: 'Times New Roman', serif; font-size: 14px;"></div>
        </div>
        <div id="playerDeckBox"></div>
        <div id="drawn-cards" style="display: flex; flex-wrap: wrap; gap: 10px; padding: 10px;">
            <p id="drawn-message" style="color: white; font-size: 1.5em;"></p>
        </div>
        <div class="viewing-window" id="viewing-window">
            <div class="scaled-card" id="scaled-card" style="transform: scale(0.797); transform-origin: center; pointer-events: none; margin-left: 14%;"></div>
        </div>
        <div class="context-window" id="context-window">
            <div class="tabs">
                <button class="tab-button active" data-tab="chat">Chat</button>
                <button class="tab-button" data-tab="game-log">Game Log</button>
                <button class="tab-button" data-tab="dictionary">Dictionary</button>
            </div>
            <div class="tab-content-container">
                <div class="tab-content active" id="chat">
                    <p>This is a Solo Game, and we here at Geimon! do not believe that AI should be allowed to speak.</p>
                </div>
                <div class="tab-content" id="game-log">
                    <p>Totem: <span id="totem" style="color: goldenrod;"></span></p>
                    <p id="game-log-placeholder"></p>
                </div>
                <div class="tab-content" id="dictionary">
                    <input type="text" id="dictionary-search" placeholder="Search terms..." style="width: 95%;"">
                    <div id="dictionary-results"></div>
                </div>
            </div>
        </div>
        <div class="player-life-window" id="player-life-window">
            <div class="player-name" id="player-name"></div>
            <div class="life" id="player-life"></div>
            <div class="player-name" style="font-size: 80%;">Life</div>
        </div>
        <div class="opponent-life-window" id="opponent-life-window">
            <div class="opponent-name" id="opponent-name"></div>
            <div class="life" id="opponent-life"></div>
            <div class="player-name" style="font-size: 80%;">Life</div>
        </div>
        <div id="loss-banner">
            <div class="main" id="loss-main-text">You Lose</div>
            <div class="reason" id="loss-reason-text">Surrendered</div>
        </div>
        <div id="phase-tracker">
            <div class="phase-box" id="phase-Intermission">Intermission</div>
            <div class="phase-box" id="phase-Draw">Draw</div>
            <div class="phase-box" id="phase-Main 1">Main 1</div>
            <div class="phase-box" id="phase-Battle">Battle</div>
            <div class="phase-box" id="phase-Main 2">Main 2</div>
            <div class="phase-box" id="phase-End">End</div>
        </div>
        <button id="advance-phase">Advance Phase</button>
        <div id="turn-counter">Turn: 1</div>

        <script type="module">
            import { cards } from "./data/cards.js";
            import { tokens } from "./data/tokens.js";
            import { renderCard } from "./utils/cardRenderer.js";
            import { addTooltipListeners, addTokenTooltipListeners } from "./utils/cardRenderer.js";
            import { keywords } from "./data/keywords.js";
            import { rules } from "./data/rules.js";
            let gameId = localStorage.getItem("gameId");
            if (!gameId) {
                gameId = Math.random().toString(36).substr(2, 9); // Simple ID
                localStorage.setItem("gameId", gameId);
            }
            let username = null;
            const params = new URLSearchParams(window.location.search);
            const isSinglePlayer = params.get("gameType") === "single";
            const otherPlayerName = params.get("opponent") || "Unknown_Opponent"; // if multiplayer later

        let previousHandIds = [];
        let playerPhaseAutoAdvancing = false;
        let lastDrawTurn = null;

        function handsAreEqual(currentHand) {
        return (
            currentHand.length === previousHandIds.length &&
            currentHand.every((card, index) => card.id === previousHandIds[index])
        );
        }

        function updateLocalFromGameState() {
            const player = gameState[username];
            const currentHand = player.Hand;

            // Only re-render if the hand has changed
            if (!handsAreEqual(currentHand)) {
                drawnCardsArray = currentHand;
                previousHandIds = currentHand.map(card => card.id);
                renderDrawnCards();
            }

            remainingDeck = player.Deck;
            updateDeckText();

            // ✅ Add this:
            updateTurnDisplay(gameState.turn);
            updatePhaseDisplay(gameState.turn.currentPhase);
        }

            async function getUsername() {
                const res = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/me', { credentials: 'include' });
                const data = await res.json();
                if (data.loggedIn) {
                    username = data.username;
                }
            }
            async function initGameClient() {
            await getUsername();
            if (!username) {
                alert("Could not retrieve username.");
                return; // ✅ This is now valid
            }
            }

        window.onload = () => {
            const params = new URLSearchParams(window.location.search);
            const turnOrder = params.get("turnOrder");

            if (turnOrder === "coinflip") {
                const container = document.getElementById("coin-flip-container");
                const coin = document.getElementById("coin");
                const resultText = document.getElementById("flip-result");
                container.style.display = "block";
                resultText.textContent = "";

                // Image paths
                const headsImg = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png";
                const tailsImg = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/tails.png";

                let positionY = window.innerHeight / 2;
                let velocity = -25;
                let gravity = 1;
                let flips = 0;

                function animateFlip() {
                    coin.src = Math.random() > 0.5 ? headsImg : tailsImg;

                    positionY += velocity;
                    velocity += gravity;

                    coin.style.top = `${positionY}px`;

                    if (velocity > 0 && positionY >= window.innerHeight / 2) {
                        clearInterval(interval);

                        const finalResult = Math.random() > 0.5 ? "Heads" : "Tails";
                        coin.src = finalResult === "Heads" ? headsImg : tailsImg;

                        if (finalResult === "Tails") {
                            resultText.textContent = "You are going second.";
                            resultText.style.display = "block";
                            resultText.style.fontSize = "2em";
                            resultText.style.marginTop = "10%";
                            resultText.style.textShadow ="2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black";
                            setTimeout(() => transitionToNextScreen("second"), 2000);
                        } else {
                            resultText.textContent = "You won the coin flip! Choose:";
                            resultText.style.display = "block";
                            resultText.style.fontSize = "2em";
                            resultText.style.marginTop = "10%";
                            resultText.style.textShadow = "2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black";

                            const buttonContainer = document.createElement("div");
                            buttonContainer.style.marginTop = "20px";

                            const goFirstButton = document.createElement("button");
                            goFirstButton.textContent = "Go First";
                            goFirstButton.style.marginRight = "10px";
                            goFirstButton.className = "button button";
                            goFirstButton.onclick = () => {
                                clearTimeout(autoSelectTimer); // Cancel timer if selected manually
                                transitionToNextScreen("first");
                            };

                            const goSecondButton = document.createElement("button");
                            goSecondButton.textContent = "Go Second";
                            goSecondButton.className = "button button";
                            goSecondButton.onclick = () => {
                                clearTimeout(autoSelectTimer); // Cancel timer if selected manually
                                transitionToNextScreen("second");
                            };

                            buttonContainer.appendChild(goFirstButton);
                            buttonContainer.appendChild(goSecondButton);
                            container.appendChild(buttonContainer);

                            // Start 3-second timer for automatic selection
                            const autoSelectTimer = setTimeout(() => {
                                const randomChoice = Math.random() < 0.5 ? "first" : "second"; // 50/50 chance
                                console.log(`Time expired! Automatically choosing: ${randomChoice}`);
                                transitionToNextScreen(randomChoice);
                            }, 3000); // 3 seconds
                        }

                    }
                }
                const interval = setInterval(animateFlip, 50);
            } else {
                document.body.innerHTML = `
                    <h1>Game Configuration</h1>
                    <p>Player Deck: ${params.get("playerDeck")}</p>
                    <p>Opponent Deck: ${params.get("opponentDeck")}</p>
                    <p>Game Type: ${params.get("gameType")}</p>
                    <p>Totem: ${params.get("totem")}</p>
                    <p>Turn Order: ${turnOrder}</p>
                `;
            }
        };
        async function fetchLatestTurnState() {
            const res = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`, {
                credentials: "include",
            });
            if (!res.ok) return gameState;
            return await res.json();
            }

        async function fetchGameStateFromServer() {
            try {
                const response = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`, {
                    credentials: "include"
                });

                if (!response.ok) {
                console.warn("⚠️ Failed to fetch game state:", response.status);
                return; // Don't continue if response is bad
                }

                const newGameState = await response.json();
                if (!newGameState || !newGameState.turn) {
                console.warn("⚠️ Game state or turn missing from server");
                return;
                }

                gameState = newGameState;
                updateLocalFromGameState();
                const currentTurn = gameState.turn;
                const playerState = gameState[username];

                // 🟩 Automatically draw 1 card if we're in our Draw phase and haven't drawn yet this turn
                if (
                currentTurn.currentPlayer === username &&
                currentTurn.currentPhase === "Draw" &&
                lastDrawTurn !== `${currentTurn.count}-${currentTurn.currentPhase}`
                ) {
                console.log("✅ Drawing 1 card in Draw phase");
                drawCards(1, playerState.Deck, playerState.Hand, "Hand");
                lastDrawTurn = `${currentTurn.count}-${currentTurn.currentPhase}`;
                }

                // Auto-advance player Intermission → Draw → Main 1
                if (
                    !playerPhaseAutoAdvancing &&
                    gameState.turn.currentPlayer === username &&
                    gameState.turn.currentPhase === "Intermission"
                    ) {
                    playerPhaseAutoAdvancing = true;

                    setTimeout(async () => {
                        //await advancePhaseForPlayer(); // Intermission → Draw

                        const latestState = await fetchLatestTurnState();
                        if (latestState.turn.currentPlayer === username && latestState.turn.currentPhase === "Draw") {
                        setTimeout(() => {
                            playerPhaseAutoAdvancing = false;
                        }, 1500);
                        } else {
                        playerPhaseAutoAdvancing = false;
                        }
                    }, 1500);
                    }

            } catch (err) {
                console.error("💥 Error fetching game state:", err);
            }
            }
        async function advancePhaseForPlayer() {
            const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/advancePhase", {
                method: "POST",
                credentials: 'include',
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ gameId, username }),
            });

            if (response.ok) {
                const data = await response.json();
                updateTurnDisplay(data.turn);
                updatePhaseDisplay(data.turn.currentPhase);
            }
        }

        function showLossBanner(mainText, reasonText) {
            const banner = document.getElementById("loss-banner");
            document.getElementById("loss-main-text").textContent = mainText;
            document.getElementById("loss-reason-text").textContent = reasonText;
            banner.style.display = "block";
        }

        function updatePhaseDisplay(currentPhase) {
            document.querySelectorAll('.phase-box').forEach(box => {
                box.classList.remove('active');
            });
            const activeBox = document.getElementById(`phase-${currentPhase}`);
            if (activeBox) {
                activeBox.classList.add('active');
            }
        }

        function checkActivatableCards() {
            console.log("Check for activatable cards here...");
        }

        function updateTurnDisplay(turnData) {
            if (turnData && turnData.count) {
                document.getElementById("turn-counter").textContent = `Turn: ${turnData.count}`;
            }
        }

        async function autoAdvanceIfMyTurn() {
            if (!gameState || !gameState.turn || gameState.turn.currentPlayer !== username) return;
            const myTurn = gameState.turn.currentPlayer === username;
            const phase = gameState.turn.currentPhase;
            const turnCount = gameState.turn.count;

            if (phase === "Intermission") {
                // ⏳ If it's the very first turn, add a longer delay
                const delayTime = turnCount === 1 ? 7500 : 1500;
                console.log(`⏳ Intermission delay: ${delayTime}ms`);
                await delay(delayTime);
                //await advancePhase(); // Move to Draw
                return;
            }

            if (phase === "Draw") {
                await delay(1500);
                //await advancePhase(); // moves to Main 1
                return;
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function advancePhase() {
            const res = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/advancePhase', {
                method: 'POST',
                credentials: 'include',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ gameId, username })
            });

            const data = await res.json();
            if (data.success) {
                gameState.turn = data.turn;
                updatePhaseDisplay(data.turn.currentPhase);
                updateTurnDisplay(data.turn);

                if (data.turn.currentPhase === "Draw") {
                    drawCards(gameState[username].Deck, 1); // Draw only 1 during Draw phase
                }
            }
        }


        document.getElementById("advance-phase").onclick = async () => {
            console.log("Sending advancePhase with:", { gameId, username });
            const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/advancePhase", {
                method: "POST",
                credentials: 'include',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ gameId, username })
            });

            if (!response.ok) {
                const errorData = await response.json();
                console.error("Backend error:", errorData);
                alert(errorData.message || "Phase advance failed.");
                return;
            }

            const data = await response.json();

            if (data.success) {
                updatePhaseDisplay(data.turn.currentPhase);
                updateTurnDisplay(data.turn);

                if (data.turn.currentPhase === "Draw") {
                drawCards(gameState[username].Deck, 1);
                }

                // Placeholder for activation checks
                if (data.turn.currentPhase === "Intermission" || data.turn.currentPhase === "End") {
                checkActivatableCards();
                }
            } else {
                alert(data.message || "Failed to advance phase.");
            }
        };

        async function transitionToNextScreen(choice) {
            // Keep the background image visible
            const bgImage = document.querySelector(".bg-image");

            // Create a semi-transparent overlay
            const overlay = document.createElement("div");
            overlay.style.position = "absolute";
            overlay.style.top = "0";
            overlay.style.left = "0";
            overlay.style.width = "100%";
            overlay.style.height = "100%";
            overlay.style.backgroundColor = "rgba(0, 0, 0, 0.4)"; // Dark transparency
            overlay.style.zIndex = "10";

            // Main container for the structured design
            const mainContainer = document.createElement("div");
            mainContainer.style.position = "absolute";
            mainContainer.style.top = "2%";
            mainContainer.style.left = "2%";
            mainContainer.style.width = "94%";
            mainContainer.style.height = "92%";
            mainContainer.style.display = "flex";
            mainContainer.style.flexDirection = "column";
            mainContainer.style.justifyContent = "center";
            mainContainer.style.alignItems = "center";
            mainContainer.style.gap = "10px";
            mainContainer.style.padding = "20px";
            mainContainer.style.backgroundColor = "rgba(0, 0, 0)";
            mainContainer.style.borderRadius = "20px";
            mainContainer.style.zIndex = "20";
            mainContainer.style.opacity = "0"; // Start fully invisible
            mainContainer.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
            mainContainer.style.transform = "scale(0.8)  translate(100px,-50px)";

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                mainContainer.style.opacity = "1";
            }, 50);

            // Central result box
            const resultBox = document.createElement("div");
            resultBox.style.position = "absolute";
            resultBox.style.top = "50%";
            resultBox.style.left = "50%";
            resultBox.style.transform = "translate(-50%, -50%)";
            resultBox.style.padding = "20px 40px";
            resultBox.style.color = "white";
            resultBox.style.fontSize = "2em";
            resultBox.style.borderRadius = "10px";
            resultBox.style.textAlign = "center";
            resultBox.style.opacity = "0"; // Start fully invisible
            resultBox.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
            resultBox.style.zIndex = "100700"; // On top of everything
            resultBox.style.boxShadow = "0 0 20px black";

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                resultBox.style.opacity = "1";
            }, 50);

            // Set background color based on choice
            resultBox.style.backgroundColor = choice === "first" ? "blue" : "red";
            resultBox.textContent = choice === "first" ? "Your Turn" : "Opponent's Turn";

            // Main board container
            const board = document.createElement("div");
            board.style.position = "absolute";
            board.style.top = "2%";
            board.style.left = "2%";
            board.style.width = "96%";
            board.style.height = "94%";
            board.style.backgroundColor = "black";
            board.style.zIndex = "20";
            board.style.borderRadius = "20px";
            board.style.opacity = "0"; // Start fully invisible
            board.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                board.style.opacity = "1";
            }, 50);

            fetchUserData().then(userData => {
                if (userData && userData.zoneArt) {
                    const zoneArtContainer = document.createElement("div");
                    zoneArtContainer.style.position = "absolute";
                    zoneArtContainer.style.left = "0";
                    zoneArtContainer.style.bottom = "0";
                    zoneArtContainer.style.width = "100%";
                    zoneArtContainer.style.height = "50%";
                    zoneArtContainer.style.overflow = "hidden";

                    const zoneArtImage = document.createElement("img");
                    zoneArtImage.src = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Zones/${userData.zoneArt}`;
                    zoneArtImage.style.position = "absolute";
                    zoneArtImage.style.width = "100%";
                    zoneArtImage.style.height = "200%"; // Double height so top half is offscreen
                    zoneArtImage.style.top = "0%"; // Shift to crop top, show only bottom half
                    zoneArtImage.style.left = "0";
                    zoneArtImage.style.zIndex = "10";
                    zoneArtImage.style.border = "6px solid black";
                    zoneArtImage.style.objectFit = "cover";

                    zoneArtContainer.appendChild(zoneArtImage);
                    board.appendChild(zoneArtContainer);
                }
            });

            // After all elements like playerDeckBox and deckText are added
            fetchUserData().then(userData => {
                if (userData && userData.deckSleeve) {
                    playerDeckBox.style.backgroundImage = `url(https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Sleeves/${userData.deckSleeve})`;
                    playerDeckBox.style.backgroundSize = "cover";
                    playerDeckBox.style.backgroundPosition = "center";
                    playerDeckBox.style.backgroundRepeat = "no-repeat";
                }
            });

            // Function to add a box
            function addBox(x, y, w, h, color="green") {
                const box = document.createElement("div");
                box.style.position = "absolute";
                box.style.left = x;
                box.style.top = y;
                box.style.width = w;
                box.style.height = h;
                box.style.border = `4px solid ${color}`;
                box.style.backgroundColor = "black";
                box.style.opacity = "0.5";
                box.style.zIndex = "30";
                board.appendChild(box);
            }

            // Reproduce visual layout from image (values are approximate %)
            addBox("1%", "1%", "6%", "19%", "lightsalmon");     // Opponent Deck
            addBox("9%", "1%", "68%", "19%", "lightsalmon");    // Opponent Arsenal

            addBox("79%", "1%", "20%", "40%", "lightsalmon");   // Opponent Reserve

            addBox("1%", "22%", "6%", "19%", "lightsalmon");    // Opponent Tomb
            addBox("9%", "22%", "68%", "19%", "lightsalmon");   // Opponent Champions

            addBox("1%", "44%", "10%", "14%", "lightsalmon");    // Opponent Void

            addBox("14%", "47%", "72%", "7%", "lightgreen");    // Path

            addBox("89%", "44%", "10%", "14%", "lightblue");   // Player Void

            addBox("1%", "60%", "20%", "40%", "lightblue");   // Player Reserve

            addBox("23%", "60%", "68%", "19%", "lightblue");  // Player Champions
            addBox("93%", "60%", "6%", "19%", "lightblue");  // Player Tomb

            addBox("23%", "81%", "68%", "19%", "lightblue");  // Player Arsenal
            addBox("93%", "81%", "6%", "19%", "lightblue");  // Player Deck

            document.body.appendChild(overlay);
            document.body.appendChild(mainContainer);
            mainContainer.appendChild(board);
            mainContainer.appendChild(resultBox);

            // Fade out the result box after 3 seconds
            setTimeout(() => {
                resultBox.style.opacity = "0"; // Fades out smoothly
            }, 2000);

            const params = new URLSearchParams(window.location.search);
            const selectedTotem = params.get("totem");
            const selectedTotemText = params.get("totemText");

            document.getElementById("totem").textContent = selectedTotem;
            const totemTextElement = document.createElement("p");
            totemTextElement.innerHTML = `<strong>Description:</strong> ${selectedTotemText}`;
            document.getElementById("game-log").appendChild(totemTextElement);

            const totemBox = document.createElement("div");
            totemBox.style.position = "absolute";
            totemBox.style.top = "46%";
            totemBox.style.left = "53%";
            totemBox.style.transform = "translate(-50%, -50%)";
            totemBox.style.padding = "16px 32px";
            totemBox.style.backgroundColor = "goldenrod";
            totemBox.style.color = "white";
            totemBox.style.fontSize = "1.5em";
            totemBox.style.borderRadius = "10px";
            totemBox.style.textAlign = "center";
            totemBox.style.opacity = "0"; // Start invisible
            totemBox.style.transition = "opacity 1s ease-in-out";
            totemBox.style.zIndex = "100700";
            totemBox.style.boxShadow = "0 0 20px black";
            totemBox.textContent = `Selected Totem: ${selectedTotem} - ${selectedTotemText}`;

            // Add to document
            document.body.appendChild(totemBox);

            // Trigger fade-in
            setTimeout(() => {
                totemBox.style.opacity = "1";
            }, 2500); // Slight delay after result box

            setTimeout(() => {
                totemBox.style.opacity = "0";
            }, 6500);

            // Function to fetch user data from the session
            async function fetchUserData() {
                try {
                    const res = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/me', {
                        credentials: 'include'
                    });
                    if (!res.ok) throw new Error('Response error');

                    const data = await res.json();
                    if (!data.loggedIn) return null;

                    return data;
                } catch (err) {
                    console.error('Failed to fetch user data:', err);
                    return null;
                }
            }

            // Fetch deck and start game
            const playerDeckName = new URLSearchParams(window.location.search).get("playerDeck");
            const opponentDeckName = new URLSearchParams(window.location.search).get("opponentDeck");

            const playerDeckResult = await fetchDeckCards(playerDeckName);
            const opponentDeckResult = await fetchDeckCards(opponentDeckName);

            if (!playerDeckResult.success || !opponentDeckResult.success) {
                console.error("Deck fetch failed");
                return;
            }

            const playerDeck = playerDeckResult.card_ids;
            const opponentDeck = opponentDeckResult.card_ids;

            if (playerDeckResult.success && opponentDeckResult.success) {
                await fetch('https://geimon-app-833627ba44e0.herokuapp.com/startGame', {
                    method: 'POST',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        gameId,
                        playerUsername: username,
                        opponentUsername: isSinglePlayer ? "Bot" : otherPlayerName,
                        playerDeck,
                        opponentDeck,
                        isSinglePlayer: true,
                        goesFirst: choice === "first" ? username : (isSinglePlayer ? "Bot" : otherPlayerName)
                    })
                });


                await fetchGameStateFromServer();
                setInterval(async () => {
                    await fetchGameStateFromServer();
                }, 1500);

                const opponentName = isSinglePlayer ? "Bot" : otherPlayerName;
                document.getElementById("player-name").textContent = username;
                document.getElementById("player-life").textContent = gameState[username].life;

                document.getElementById("opponent-name").textContent = opponentName;
                document.getElementById("opponent-life").textContent = gameState[opponentName].life;

                console.log("Creating game for", username, "vs", isSinglePlayer ? "Bot" : otherPlayerName);
                await fetchGameStateFromServer();
                if (!gameState || !gameState[username]) {
                    alert("Game could not be started.");
                    return;
                }

                if (gameState[username].Hand.length === 0) {
                    for (let i = 0; i < 5; i++) {
                        await drawCards(gameState[username].Deck, 1);
                    }
                    console.log("🃏 Drew 5 starting cards for", username);
                    await sendZoneUpdate(["Deck", "Hand"]);
                }

                updateDeckText();
            } else {
                console.error("Deck loading failed:", playerDeckResult.message);
            }
            await fetchGameStateFromServer();
            await autoAdvanceIfMyTurn();
        }
        async function fetchDeckCards(deckName) {
        if (deckName === "Random") {
            // Generate a random deck locally
            const cardPool = cards.map(card => card.id); // Extract all IDs
            const deckSize = Math.floor(Math.random() * 41) + 60; // Random between 60–100
            const shuffled = cardPool.sort(() => 0.5 - Math.random());
            const card_ids = shuffled.slice(0, deckSize);

            deckCount = `${card_ids.length}`;
            if (playerDeckBox) {
                playerDeckBox.innerText = "Deck";
            }

            return { success: true, card_ids };
        }

        // Fallback to real server call for named decks
        try {
            const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                method: "POST",
                credentials: 'include',
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ deck_name: deckName })
            });

            const data = await response.json();

            if (data.success) {
                deckCount = `${data.card_ids.length}`;
                if (playerDeckBox) {
                    playerDeckBox.innerText = "Deck";
                }
            } else {
                deckCount = data.message;
            }

            return data;
        } catch (error) {
            console.error("Error fetching deck cards:", error);
            return { success: false, message: 'Fetch error' };
        }
    }

    // Select the existing Player Deck box after it's created
    const playerDeckBox = document.createElement("div");
        playerDeckBox.id = "playerDeckBox";
        playerDeckBox.style.position = "absolute";
        playerDeckBox.style.left = "86.1%";
        playerDeckBox.style.top = "68.9%";
        playerDeckBox.style.width = "3.72%";
        playerDeckBox.style.height = "11.8%";
        //playerDeckBox.style.backgroundColor = "lightblue";
        playerDeckBox.style.outline = "4px solid white"; // Bright white outline for debugging
        playerDeckBox.style.display = "block"; // Ensure it's always visible
        playerDeckBox.style.zIndex = "1000"; // Bring it to the front layer
        playerDeckBox.style.opacity = "0"; // Start fully invisible
        playerDeckBox.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
        playerDeckBox.style.textAlign = "center"; // Ensures proper alignment
        playerDeckBox.style.fontWeight = "bold";
        playerDeckBox.style.fontSize = "1.2em";
        playerDeckBox.style.color = "white";
        playerDeckBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

    // Create the text span element separately
    const deckText = document.createElement("span");
        deckText.innerText = "Deck";
        deckText.style.position = "absolute"; // Positions independently inside the box
        deckText.style.left = "50%"; // Centers horizontally
        deckText.style.top = "70%"; // Moves text downward
        deckText.style.transform = "translate(-50%, -50%)"; // Ensures precise centering

    playerDeckBox.appendChild(deckText);
    document.body.appendChild(playerDeckBox); // Add to the document

    // Create Surrender Button Overlay
    const surrenderButton = document.createElement("button");
        surrenderButton.style.position = "absolute";
        surrenderButton.style.left = "86.1%";
        surrenderButton.style.top = "72%";
        surrenderButton.style.width = "3.72%";
        surrenderButton.style.height = "9%";//addBox("93%", "81%", "6%", "19%", "lightblue");  // Player Deck
        surrenderButton.style.backgroundColor = "rgba(255, 0, 0)";
        surrenderButton.style.opacity = "0";
        surrenderButton.style.border = "none";
        surrenderButton.style.zIndex = "1001";
        surrenderButton.style.cursor = "pointer";
        surrenderButton.title = "Surrender";

    // Add event listener for click
    surrenderButton.addEventListener("click", () => {
        const confirmBox = document.createElement("div");
        confirmBox.style.position = "fixed";
        confirmBox.style.top = "50%";
        confirmBox.style.left = "50%";
        confirmBox.style.transform = "translate(-50%, -50%)";
        confirmBox.style.padding = "20px";
        confirmBox.style.backgroundColor = "#333";
        confirmBox.style.color = "white";
        confirmBox.style.border = "2px solid red";
        confirmBox.style.borderRadius = "10px";
        confirmBox.style.zIndex = "10000";
        confirmBox.style.textAlign = "center";
        confirmBox.style.boxShadow = "0 0 10px black";

        confirmBox.innerHTML = `
            <p style="margin-bottom: 20px;">Are you sure you'd like to surrender?</p>
            <button id="confirm-surrender" style="margin-right: 10px;">Surrender</button>
            <button id="cancel-surrender">Cancel</button>
        `;

        document.body.appendChild(confirmBox);

        document.getElementById("confirm-surrender").onclick = async () => {
            try {
                await fetch("https://geimon-app-833627ba44e0.herokuapp.com/endGame", {
                    method: "POST",
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        gameId,
                        loser: username,
                        reason: "Surrendered"
                    })
                });

                showLossBanner("You Lose", "Surrendered");
                document.body.removeChild(confirmBox);
            } catch (err) {
                console.error("Error ending game:", err);
                alert("Failed to surrender. Please try again.");
            }
        };

        document.getElementById("cancel-surrender").onclick = () => {
            document.body.removeChild(confirmBox);
        };
    });

    document.body.appendChild(surrenderButton);

        setTimeout(() => {
            playerDeckBox.style.opacity = "1";
        }, 6500);
        let deckCount = "Deck";

    // Ensure it exists before adding event listeners
    if (playerDeckBox) {
        playerDeckBox.style.display = "block";
        playerDeckBox.style.outline = "4px solid white";

        playerDeckBox.addEventListener("mouseenter", () => {
            playerDeckBox.innerText = deckCount;
        });

        // Mouse leave resets to "Deck"
        playerDeckBox.addEventListener("mouseleave", () => {
            playerDeckBox.innerText = "Deck";
        });
    }

    // Fetch deck count dynamically
    setTimeout(async () => {
        const urlParams = new URLSearchParams(window.location.search);

        async function getDeckFromParam(paramName) {
            const paramValue = urlParams.get(paramName);
            try {
                const parsed = JSON.parse(paramValue);
                if (Array.isArray(parsed)) {
                    return parsed; // Already a full random deck
                }
            } catch (e) {
                const result = await fetchDeckCards(paramValue);
                if (result.success) return result.card_ids;
                console.error(`Failed to load deck '${paramName}':`, result.message);
                return [];
            }
        }

        const playerDeckCardIds = await getDeckFromParam("playerDeck");
        const opponentDeckCardIds = await getDeckFromParam("opponentDeck");

        // You can now use these arrays:
        console.log("Player Deck:", playerDeckCardIds);
        console.log("Opponent Deck:", opponentDeckCardIds);

        // Optionally continue setup:
        // startGameWithDecks(playerDeckCardIds, opponentDeckCardIds);
    }, 200);


        let remainingDeck = []; // Store shuffled deck globally
        let drawnCardsArray = []; // Track drawn cards separately
        let initialDeckSize = 0; // Store starting deck size globally
        let gameState = null;


        // Function to update deck text dynamically
        function updateDeckText() {
            if (deckText) {
                deckText.innerText = `Deck (${remainingDeck.length}/${initialDeckSize})`; // Correct dynamic update
            }
        }

        // Function to shuffle the deck using Fisher-Yates algorithm
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        // Function to render drawn cards
        function renderDrawnCards() {
            const drawnCardsContainer = document.getElementById("drawn-cards"); // Ensure this container exists
            const scaledCardContainer = document.getElementById("scaled-card");
            const viewingWindow = document.getElementById("viewing-window");
            const contextWindow = document.getElementById("context-window");
            const playerLifeWindow = document.getElementById("player-life-window");
            const opponentLifeWindow = document.getElementById("opponent-life-window");
            const phaseTracker = document.getElementById("phase-tracker");
            const advancePhase = document.getElementById("advance-phase");
            const turnCounter = document.getElementById("turn-counter");
            drawnCardsContainer.innerHTML = ""; // Clear previous renders

            if (drawnCardsArray.length === 0) {
                console.log("No cards have been drawn yet.");
                return;
            }

            console.log("Rendering Drawn Cards:", drawnCardsArray);

            // Find full card details from `cards` dataset
            const drawnCardObjects = drawnCardsArray
                .map(obj => cards.find(card => String(card.id) === String(obj.id)))
                .filter(Boolean);

            const typeOrder = ["Champion", "Action", "Equipment", "Obelisk", "Rush", "Reflex"];
            drawnCardsArray.sort((a, b) => {
                const cardA = cards.find(c => String(c.id) === String(a.id));
                const cardB = cards.find(c => String(c.id) === String(b.id));
                if (!cardA || !cardB) return 0;

                const typeOrder = ["Champion", "Action", "Equipment", "Obelisk", "Rush", "Reflex"];
                const indexA = typeOrder.indexOf(cardA.type);
                const indexB = typeOrder.indexOf(cardB.type);

                if (indexA !== indexB) return indexA - indexB;
                return cardA.name.localeCompare(cardB.name);
            });

            drawnCardsArray.forEach(cardObj => {
                const card = cards.find(card => String(card.id) === String(cardObj.id));
                if (card) {
                    const cardElement = renderCard(card, drawnCardsContainer);
                        cardElement.dataset.boardState = cardObj.boardState;
                        cardElement.dataset.lastBoardState = cardObj.lastBoardState;
                        cardElement.style.transform = "scale(0.5)";
                        cardElement.style.position = "relative"; // Ensures correct alignment
                        cardElement.style.marginLeft = "-15%"; // Overlaps cards slightly
                        cardElement.style.opacity = "1";
                        cardElement.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect

                    const cardButton = document.createElement("button");
                        cardButton.style.position = "absolute";
                        cardButton.style.top = "0";
                        cardButton.style.right = "0";
                        cardButton.style.width = "100%"; /* Covers entire card */
                        cardButton.style.height = "100%"; /* Covers entire card */
                        cardButton.style.opacity = "0";
                        cardButton.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
                        cardButton.style.border = "none";
                        cardButton.style.pointerEvents = "none";
                        cardButton.style.padding = "5px";
                        cardButton.style.zIndex = "100100";
                        cardButton.style.background = "transparent";
                        cardButton.onclick = () => alert(`Card clicked: ${card.name}`);

                    // Hover effect to display scaled card in viewing window
                    cardElement.addEventListener("mouseenter", () => {
                        scaledCardContainer.innerHTML = ""; // Clear previous preview
                        const clone = cardElement.cloneNode(true);
                        const cloneButton = clone.querySelector(".card-button");
                        if (cloneButton) cloneButton.remove(); // Remove interactions
                        clone.style.transform = "scale(1.2)"; // Slight enlargement
                        clone.style.width = "100%"; // Full width inside the viewing window
                        clone.style.position = "relative";
                        scaledCardContainer.appendChild(clone);
                        addTooltipListeners(clone);
                        addTokenTooltipListeners(clone);
                    });

                    cardElement.appendChild(cardButton);
                    drawnCardsContainer.appendChild(cardElement);
                    setTimeout(() => {
                        cardElement.style.opacity = "1";
                        cardButton.style.opacity = "1";
                        cardButton.style.pointerEvents = "auto";
                        cardButton.style.cursor = "pointer";
                    }, 1500);
                    setTimeout(() => {
                        viewingWindow.style.opacity = "1";
                        contextWindow.style.opacity = "1";
                        playerLifeWindow.style.opacity = "1";
                        opponentLifeWindow.style.opacity = "1";
                        phaseTracker.style.opacity = "1";
                        turnCounter.style.opacity = "1";
                    }, 2500);
                    setTimeout(() => {
                        advancePhase.style.zIndex = "100800";
                        advancePhase.style.opacity = "1";
                    }, 3500);
                }
            });
        }
        async function drawCards(deck, numCards = 5) {
        if (deck.length < numCards) {
            console.warn("Not enough cards left to draw.");
            return [];
        }

        function getCardsFromZone(zone, count) {
            return zone.splice(0, count);
        }

        function renderZone(zoneName, owner = username) {
            const cards = gameState[owner][zoneName];
        }

        const drawnCards = getCardsFromZone(gameState[username].Deck, numCards);
        drawnCards.forEach(card => {
            card.lastBoardState = card.boardState;
            card.boardState = "Hand";
        });
        gameState[username].Hand.push(...drawnCards);

        // Debugging logs for confirmation
        console.log("Initial Hand:", drawnCards);
        console.log("Remaining Deck Contents:", deck);

        await sendZoneUpdate(["Deck", "Hand"]);

        renderDrawnCards();
        updateDeckText();
        return drawnCards;
        }

        async function sendZoneUpdate(zones) {
            const updatedZones = {};
            zones.forEach(z => {
                updatedZones[z] = gameState[username][z];
            });

            await fetch('https://geimon-app-833627ba44e0.herokuapp.com/updateGameState', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                gameId,
                updatedZones,
                owner: username
                })
            });
        }

        // Function to update deck count visually
        function updateDeckCount() {
            if (playerDeckBox) {
                playerDeckBox.innerText = `Deck`;
            }
        }

        function changeLife(player, amount) {
            if (!gameState[player]) return;
            gameState[player].life += amount;

            // Update display
            if (player === username) {
                document.getElementById("player-name").textContent = username;
                document.getElementById("player-life").textContent = `${gameState[username].life}`;
            } else {
                document.getElementById("opponent-name").textContent = opponentName;
                document.getElementById("player-life").textContent = `${gameState[username].life}`;
            }

            sendLifeUpdate();
        }

        async function sendLifeUpdate() {
            await fetch('https://geimon-app-833627ba44e0.herokuapp.com/updateGameState', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    gameId,
                    updatedZones: {
                        life: gameState[username].life
                    },
                    owner: username
                })
            });
        }

        // Fetch and shuffle deck, then update count
        async function fetchAndShuffleDeck(deckParam) {
            let cardIds = [];

            try {
                // Try to parse as a JSON array
                const parsed = JSON.parse(deckParam);
                if (Array.isArray(parsed)) {
                    cardIds = parsed;
                } else {
                    // Fallback to server fetch
                    const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                        method: "POST",
                        credentials: "include",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({ deck_name: deckParam }),
                    });

                    const data = await response.json();
                    if (!data.success) {
                        console.error("Error:", data.message);
                        return;
                    }

                    cardIds = data.card_ids;
                }
            } catch (e) {
                // Not valid JSON — must be a normal deck name
                const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                    method: "POST",
                    credentials: "include",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ deck_name: deckParam }),
                });

                const data = await response.json();
                if (!data.success) {
                    console.error("Error:", data.message);
                    return;
                }

                cardIds = data.card_ids;
            }

            // At this point, cardIds is valid
            initialDeckSize = cardIds.length;
            remainingDeck = shuffleDeck(cardIds).map(id => ({
                id,
                boardState: "Deck",
                lastBoardState: null
            }));

            console.log("Deck Shuffled:", remainingDeck);
            console.log("Total Cards in Deck:", initialDeckSize);
        }

        // Attach event listeners to update deck count dynamically
        if (playerDeckBox) {
            playerDeckBox.addEventListener("mouseenter", () => {
                playerDeckBox.innerText = `${remainingDeck.length}`;
            });

            playerDeckBox.addEventListener("mouseleave", () => {
                playerDeckBox.innerText = "Deck";
            });
        }

    document.addEventListener("DOMContentLoaded", () => {
        const tooltip = document.getElementById("tooltip");
        const tokenTooltip = document.getElementById("token-tooltip");

        const tabs = document.querySelectorAll(".tab-button");
        const contents = document.querySelectorAll(".tab-content");

        tabs.forEach(tab => {
            tab.addEventListener("click", () => {
                tabs.forEach(t => t.classList.remove("active"));
                contents.forEach(c => c.classList.remove("active"));

                tab.classList.add("active");
                document.getElementById(tab.dataset.tab).classList.add("active");
            });
        });

        // Game Log Data Population
        const params = new URLSearchParams(window.location.search);
        document.getElementById("totem").textContent = params.get("totem");

        const dictionarySearch = document.getElementById("dictionary-search");
        const dictionaryResults = document.getElementById("dictionary-results");

        const loadAllTerms = () => {
            dictionaryResults.innerHTML = "";
            const allTerms = [...Object.entries(keywords), ...Object.entries(rules)];
            allTerms.sort((a, b) => a[0].localeCompare(b[0]));
            allTerms.forEach(([key, value]) => {
                const resultItem = document.createElement("p");
                resultItem.innerHTML = `<strong>${key}:</strong> ${value}`;
                dictionaryResults.appendChild(resultItem);
            });
        };
        loadAllTerms();

        dictionarySearch.addEventListener("input", () => {
            const query = dictionarySearch.value.toLowerCase();
            dictionaryResults.innerHTML = "";

            if (!query) {
                loadAllTerms();
                return;
            }

            const matchedKeywords = Object.entries(keywords).filter(([key]) =>
                key.toLowerCase().includes(query)
            );

            const matchedRules = Object.entries(rules).filter(([key]) =>
                key.toLowerCase().includes(query)
            );

            [...matchedKeywords, ...matchedRules].forEach(([key, value]) => {
                const resultItem = document.createElement("p");
                resultItem.innerHTML = `<strong>${key}:</strong> ${value}`;
                dictionaryResults.appendChild(resultItem);
            });
        });

        document.querySelectorAll(".keyword").forEach(keyword => {
            const description = keyword.dataset.description;

            if (description && description.trim() !== "") {
                keyword.addEventListener("mouseenter", (e) => {
                    tooltip.textContent = description;
                    tooltip.style.display = "block";
                    tokenTooltip.querySelector(".token-tooltip-text").textContent = description;
                    tokenTooltip.style.display = "block";
                });

                keyword.addEventListener("mouseleave", () => {
                    tooltip.style.display = "none";
                    tokenTooltip.style.display = "none";
                });

                keyword.addEventListener("mousemove", (e) => {
                    if (tooltip.style.display === "block") {
                        tooltip.style.left = `${e.pageX + 10}px`;
                        tooltip.style.top = `${e.pageY - 40}px`;
                    }
                    if (tokenTooltip.style.display === "block") { // ✅ Fix: Remove `else if`
                        tokenTooltip.style.left = `${e.pageX + 10}px`;
                        tokenTooltip.style.top = `${e.pageY - 40}px`;
                    }
                });
            }
        });
    });
    initGameClient();
    </script>
</body>
</html>