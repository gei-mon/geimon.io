<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
    <link rel="icon" href="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/favicon.png" type="image/png">
    <link rel="stylesheet" href="style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Active Game</title>
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <script>
        window.socket = io("https://geimon-app-833627ba44e0.herokuapp.com", {
            withCredentials: true
        });
    </script>
</head>
<style>
html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    width: 100%;
    overflow: hidden;
}
  #coin {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    transition: transform 0.1s;
}
  #drawn-cards {
    position: fixed;
    bottom: -180px; /* Positions the cards near the bottom */
    left: 650px;
    display: flex;
    flex-direction: row; /* Aligns cards in a horizontal row */
    align-items: center;
    z-index: 110020; /* Places it over (almost) everything */
    overflow: visible;
    pointer-events: none;
    max-height: 475px;
}
#drawn-cards > * {
  pointer-events: auto; /* re-enable interaction on individual cards */
}
.card {
    width: 240px; /* Reduces card size */
    height: 420px;
    position: relative; /* Ensures controlled placement */
    margin-left: -50%; /* Overlaps cards by 5% */
}
.viewing-window {
    position: fixed;
    left: 10px; /* Keeps it on the left */
    top: 270px;
    transform: translateY(-50%);
    width: 280px; /* Size for zoomed card */
    height: 440px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #1e1e1e;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110; /* Ensures it's on top */
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.context-window {
    position: fixed;
    left: 10px;
    top: 750px;
    transform: translateY(-50%);
    width: 280px;
    height: 440px;
    display: flex;
    flex-direction: column;
    background-color: #1e1e1e;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.player-life-window {
    position: fixed;
    left: 1900px;
    top: 600px;
    transform: translateY(-50%);
    width: 100px;
    height: 100px;
    display: flex;
    flex-direction: column;
    background-color: #2d1eff;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.opponent-life-window {
    position: fixed;
    left: 1900px;
    top: 320px;
    transform: translateY(-50%);
    width: 100px;
    height: 100px;
    display: flex;
    flex-direction: column;
    background-color: #970000;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.tabs {
    display: flex;
    justify-content: space-around;
    padding: 5px;
}
.tab-button {
    padding: 5px;
    cursor: pointer;
    background: #505050;
    color: white;
    border: none;
    border-radius: 5px;
}
.tab-button.active {
    background: #838383;
}
.tab-content-container {
    flex-grow: 1;
    padding: 10px;
    overflow-y: auto;
}
.tab-content {
    display: none;
    color: white;
}
.tab-content.active {
    display: block;
}
#viewing-window .scaled-card {
    pointer-events: auto !important;
    z-index: 100110; /* Ensures it's on top */
    width: 240px;
    height: 420px;
    margin-top: -12%;
}
#viewing-window .scaled-card .card-name {
    max-width: 100%;
}
#viewing-window .scaled-card .card-cost,
#viewing-window .scaled-card .card-text,
#viewing-window .scaled-card .card-name,
#viewing-window .scaled-card .card-condition,
#viewing-window .scaled-card .card-tags,
#viewing-window .scaled-card .bottom-bar,
#viewing-window .scaled-card .card-image {
    z-index: 100200 !important;
}
#viewing-window .scaled-card,
#viewing-window .scaled-card * {
  outline: none   !important;
  box-shadow: none !important;
  animation: none !important;
}
.tooltip {
    z-index: 110000 !important;
}
#tooltip {
    position: absolute;
    display: none;
    background-color: rgba(0, 0, 0, 1);
    color: white;
    padding: 5px;
    border-radius: 5px;
    font-size: 14px;
    max-width: 250px;
    z-index: 110000; /* Ensure it appears above other elements */
}
.token-tooltip {
    pointer-events: auto !important;
    z-index: 110000 !important;
}
#token-tooltip {
    z-index: 110000; /* Ensure it appears above other elements */
}
.keyword {
    pointer-events: auto !important;
    position: relative; /* Ensures proper hovering */
    z-index: 110000; /* Ensures tooltip appears above other elements */
}
.card-cost .keyword {
    position: relative;
    z-index: 110000 !important;
    pointer-events: auto !important;
}
.card-cost {
    pointer-events: auto !important;
    z-index: 100000 !important;
}
.card-text {
    pointer-events: auto !important;
    z-index: 100000 !important;
}
.scaled-card .card-button {
    display: none !important;
}
.life {
    color: white;
    text-align: center;
    font-weight: bold;
    font-size: 4em;
}
.player-name,
.opponent-name {
    color: white;
    font-size: 1.1em;
    text-align: center;
    font-weight: bold;
    overflow: hidden;          /* Hide overflowed content */
    text-overflow: ellipsis;   /* Show ... when text overflows */
    white-space: nowrap;       /* Prevent text from wrapping */
    max-width: 100%;           /* Optional: control how much space the text gets */
    display: inline-block;     /* Required for ellipsis to take effect */
}
#win-loss-banner {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0,0,0,0.8);
    padding: 40px 80px;
    border-radius: 16px;
    color: white;
    text-align: center;
    font-family: sans-serif;
    z-index: 120000;
    display: none;
}
#win-loss-banner .main {
    font-size: 3em;
    font-weight: bold;
    margin-bottom: 10px;
}
#win-loss-banner .reason {
    font-size: 1.5em;
}
#phase-tracker {
  display: flex;
  justify-content: center;
  gap: 10px;
  margin: 10px auto;
  padding: 10px;
  position: fixed;
  top: 416px;
  left: 949px;
  transform: translateX(-50%);
  z-index: 100600;
  opacity: 0;
}
.phase-box {
  padding: 10px 14px;
  background: dimgray;
  color: white;
  border-radius: 6px;
  font-weight: bold;
  min-width: 90px;
  text-align: center;
  transition: background 0.3s;
}
.phase-box.active {
  background: lightgreen;
  text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;
}
#turn-counter {
  position: fixed;
  top: 442px;
  left: 1545px; /* adjust this to line up visually with the button */
  z-index: 100600;
  color: white;
  font-weight: bold;
  font-size: 1.5em;
  opacity: 0;
  text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;
}
#turn-indicator {
  position: fixed;
  top: 442px;
  left: 1355px;
  z-index: 100600;
  color: white;
  font-weight: bold;
  font-size: 1.5em;
  opacity: 0;
  text-shadow: 2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black;
}
.card-zone {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  gap: 0px;
  overflow: visible;
  z-index: 110000;
  position: relative;
}
.board-container {
  width: 1920px;
  height: 1080px;
  transform: scale(calc(min(100vw / 1920, 100vh / 1080)));
  transform-origin: top left;
}
@keyframes phaseWave {
  0% {
    left: 0px;
    opacity: 0.5;
  }
  50% {
    left: 250px;
    opacity: 0.8;
  }
  100% {
    left: 500px;
    opacity: 0;
  }
}
.phase-wave-effect {
  position: absolute;
  top: 0;
  left: 0px;
  width: 500px;
  height: 50px;
  background: linear-gradient(90deg, rgba(0,255,0,0.2) 0%, rgba(0,255,0,0.6) 50%, rgba(0,255,0,0.2) 100%);
  z-index: 5;
  pointer-events: none;
  animation: phaseWave 1s ease-out forwards;
  border-radius: 10px;
}
#chat-messages       { border: 4px solid #000; height: 310px; overflow-y: auto;
                       background: #d3d3d3; padding: 4px; }
#chat-input          { width: 75%;  border: 4px solid #000; }
#chat-send           { width: 18%;  }
#chat-typing         { font-style: italic; color: lime; height: 1.4em; }
.system-message      { color: blue; font-style: italic; }
#chat-messages,
#chat-messages > div {          /* each message line you append */
  color: #000 !important;       /* override the white from .tab-content */
}
  #muteBtn {
    position: absolute;
    top: 865px;
    left: 1948.75px;
    width: 36px;
    height: 36px;
    border: none;
    border-radius: 50%;
    background: rgba(0,0,0,0);
    color: white;
    font-size: 64px;
    cursor: pointer;
    z-index: 100000;
    display: flex;
    align-items: center;
    justify-content: center;
  }
</style>
<body style="background-color:rgb(78, 78, 78);">
  <img src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/try_2.png" class="bg-image" alt="">
        <div id="coin-flip-container" style="display: none; text-align: center; margin-top: 50px;">
            <img id="coin" src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png" alt="coin" style="width: 150px; height: 150px;">
            <h2 id="flip-result" style="display: none;"></h2>
        </div>
        <div id="tooltip" class="tooltip"></div>
        <div id="token-tooltip" style="display: none; position: absolute;">
            <div class="token-tooltip-text" style="font-family: 'Times New Roman', serif; font-size: 14px;"></div>
        </div>
        <div id="drawn-cards" style="display: flex; flex-wrap: wrap; gap: 10px; padding: 10px;">
            <p id="drawn-message" style="color: white; font-size: 1.5em;"></p>
        </div>
        <div id="opponent-hand" style="display: flex; flex-wrap: nowrap; gap: 30px; padding: 10px; position: fixed; top: -235px; left: 765px; transform: none; z-index: 100350;"></div>
        <div id="opponentDeckBox"></div>
        <div class="viewing-window" id="viewing-window">
            <div class="scaled-card" id="scaled-card" style="transform: scale(0.797); transform-origin: center; pointer-events: none; margin-left: 14%;"></div>
        </div>
        <div class="context-window" id="context-window">
            <div class="tabs">
                <button class="tab-button active" data-tab="chat">Chat</button>
                <button class="tab-button" data-tab="game-log">Game Log</button>
                <button class="tab-button" data-tab="dictionary">Dictionary</button>
            </div>
            <div class="tab-content-container">
                <div class="tab-content active" id="chat">
                    <div id="chat-messages"></div>
                    <div id="chat-typing"></div>
                    <input id="chat-input" autocomplete="off" placeholder="Type your message…" />
                    <button id="chat-send">Send</button>
                </div>
                <div class="tab-content" id="game-log">
                    <p id="game-number" style="font-weight:bold; margin-bottom:4px;"></p>
                    <p><span id="totem" style="color: goldenrod;"></span></p>
                    <div id="game-log-placeholder"></div>
                </div>
                <div class="tab-content" id="dictionary">
                    <input type="text" id="dictionary-search" placeholder="Search terms..." style="width: 95%;">
                    <div id="dictionary-results"></div>
                </div>
            </div>
        </div>
        <div id="player-profile-pic"></div>
        <div id="player-side">
            <div class="player-life-window" id="player-life-window">
                <div class="player-name" id="player-name"></div>
                <div class="life" id="player-life"></div>
                <div class="player-name" style="font-size: 80%;">Life</div>
            </div>
        </div>
        <div id="life-adjust-box" style="opacity: 0; transition: opacity 1s ease-in-out;">
            <div class="life-adjust-buttons">
                <button id="increase-life">Increase Life</button>
                <button id="decrease-life" class="active">Decrease Life</button>
            </div>
            <input id="life-amount" type="number" placeholder="Amount" />
            <button id="confirm-life-change">Confirm</button>
        </div>
        <div id="opponent-profile-pic"></div>
        <div id="opponent-zone-art" style="position: absolute; top: 0; left: 0; width: 100%; height: 50%; z-index: 0; overflow: hidden; pointer-events: none;"></div>
        <div id="opponent-side"style="pointer-events: none;">
            <div class="opponent-life-window" id="opponent-life-window">
                <div class="opponent-name" id="opponent-name"></div>
                <div class="life" id="opponent-life"></div>
                <div class="player-name" style="font-size: 80%;">Life</div>
            </div>
        </div>
        <div id="win-loss-banner">
            <div class="main" id="win-loss-main-text">You Lose</div>
            <div class="reason" id="win-loss-reason-text">Surrendered</div>
        </div>
        <div id="phase-tracker">
            <div class="phase-box" id="phase-Intermission">Intermission</div>
            <div class="phase-box" id="phase-Dummy"></div>
            <div class="phase-box" id="phase-Draw">Draw</div>
            <div class="phase-box" id="phase-Main 1">Main 1</div>
            <div class="phase-box" id="phase-Battle">Battle</div>
            <div class="phase-box" id="phase-Main 2">Main 2</div>
            <div class="phase-box" id="phase-End">End</div>
        </div>
        <div id="turn-indicator">Your Turn</div>
        <div id="turn-counter">Turn: 1</div>
        <div id="end-turn-button" style="
            display: none;
            position: fixed;
            top: 427.5px;
            left: 1350px;
            z-index: 100700;
            background-color: gold;
            color: black;
            font-size: 1.8em;
            font-weight: bold;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 2px 2px 6px black;
            text-shadow: 1px -1px 2px rgb(131, 122, 23), -1px 1px 2px rgb(131, 122, 23);
            ">
            End Turn
        </div>
        <div id="playerArsenalBox" class="card-zone"></div>
        <div id="playerChampionsBox" class="card-zone"></div>
        <div id="playerFaceDownBox" class="card-zone"></div>
        <div id="playerFaceDownArsenalBox" class="card-zone"></div>
        <div id="playerReserveBox" class="card-zone"></div>
        <div id="opponentArsenalBox" class="card-zone"></div>
        <div id="opponentChampionsBox" class="card-zone"></div>
        <div id="opponentFaceDownBox" class="card-zone"></div>
        <div id="opponentFaceDownArsenalBox" class="card-zone"></div>
        <div id="opponentReserveBox" class="card-zone"></div>
        <button id="muteBtn" title="Mute/unmute sounds" style="opacity: 0; transition: opacity 1s ease-in-out;">🔊</button>
        <div id="tool-buttons" style="
            position: absolute;
            left: 1730px;
            top: 850px;
            z-index: 200500;
            display: grid;
            grid-template-columns:repeat(3,50px);
            grid-auto-rows:50px;
            gap: 12px;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            ">
            <img id="token-btn" src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/token.png" style="width: 40px; cursor: pointer;" title="Create Token">
            <img id="dice-btn" src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/dice.png" style="width: 40px; cursor: pointer;" title="Roll 1d6">
            <img id="coin-btn" src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png" style="width: 40px; cursor: pointer;" title="Flip Coin">

            <img id="shuffle-hand-btn" src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/shuffle.png"  title="Shuffle Hand" style="width:40px;cursor:pointer;">
            <img id="sort-hand-btn"    src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/sort.png"     title="Sort Hand"    style="width:40px;cursor:pointer;">
            <img id="reveal-hand-btn"  src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/eye.png"      title="Reveal Hand"  style="width:40px;cursor:pointer;">
        </div>

        <script type="module">
            import { cards } from "./data/cards.js";
            import { totems } from './data/totems.js';
            import { tokens } from "./data/tokens.js";
            import { renderCard } from "./utils/cardRenderer.js";
            import { addTooltipListeners, addTokenTooltipListeners } from "./utils/cardRenderer.js";
            import { keywords } from "./data/keywords.js";
            import { rules } from "./data/rules.js";

            const allCards = [...cards, ...tokens];

            if (!window.effectPath) {
                window.effectPath = [];
            }
            window.pathStepNumber = 1;

            let gameId = new URLSearchParams(window.location.search).get("gameId");
            if (gameId) {
                // Use the gameId from URL and update localStorage
                localStorage.setItem("gameId", gameId);
            } else {
                // Fallback: create a new one if not in URL or localStorage
                gameId = localStorage.getItem("gameId") || Math.random().toString(36).substr(2, 9);
                localStorage.setItem("gameId", gameId);
            }
            const attachmentsKey = `attachments_${gameId}`;
            localStorage.removeItem(attachmentsKey);

            let username = null;
            let hasDrawnInitialHand = false;
            let hasRedrawn = false;
            let lastLoggedIntermissionTurn = null;

            let discardOngoing = false;
            let userSleeveURL = null;
            let discardSessionId = 0;
            let discardLock = false;
            let discardInstruction = null;

            let intervalId = null;
            let isFetchingGameState = false;
            let gameReady = false;

            let renderingHand = false;

            const params = new URLSearchParams(window.location.search);
            const gameType = params.get("gameType") || "single"; // "single" or "match"
            const isSinglePlayer = params.get("isSinglePlayer") === "true"; // true/false
            const matchId =
                    params.get("matchId")
                || localStorage.getItem("currentMatchId")
                || Math.random().toString(36).substr(2, 9);   // brand-new match
            if (!params.get("matchId")) {
                params.set("matchId", matchId);
                history.replaceState(null, "", `?${params.toString()}`);
            }
            localStorage.setItem("currentMatchId", matchId);
            window.matchId = matchId;
            let gameNumber = Number(sessionStorage.getItem(matchId + "_gameNum") || 1);
            document.getElementById("game-number").textContent = `Game ${gameNumber}`;
            const serverUrl = "https://geimon-app-833627ba44e0.herokuapp.com";

            //console.log("Gametype:", gameType, "SinglePlayer:", isSinglePlayer);

            const otherPlayerName = params.get("opponentUsername") || "Unknown_Opponent"; // if multiplayer later

            // how much they overlap at 1920×1080
            const MAX_OVERLAP = 12.5; // percent
            // how little they overlap at very small sizes
            const MIN_OVERLAP = 5;  // percent

            function updateHandSpacing() {
            // scale from 0 (tiny) up to 1 (full-size)
            const scale = Math.min(
                window.innerWidth  / 1920,
                window.innerHeight / 1080,
                1
            );
            // interpolate overlap between MIN and MAX
            const overlap = MIN_OVERLAP + (MAX_OVERLAP - MIN_OVERLAP) * scale;
            document
                .querySelectorAll('#drawn-cards .card')
                .forEach(el => {
                el.style.marginLeft = `${-overlap}%`;
                });
            }
            window.addEventListener('resize', updateHandSpacing);


            let previousHandIds = [];
            let lastDrawTurn = null;
            let gameEnded = false;

            let opponentHandRevealed = false;
            let hasInitializedOpponentState = false;

            let opponentName;

            const tempRevealedIds = new Set();

            const socket = window.socket;                // 1️⃣ make an alias everyone can use

            let attachments = []; // { sourceId, targetId, color }
            try {
                const saved = JSON.parse(localStorage.getItem(attachmentsKey) || '[]');
                if (Array.isArray(saved)) attachments = saved;
            } catch(e) {
                console.warn("Could not parse saved attachments for", attachmentsKey, e);
            }

            // Once the DOM is ready, stamp any you loaded
            window.addEventListener('DOMContentLoaded', () => {
                document.querySelectorAll('.attachment-circle').forEach(el => el.remove());
                clearAttachmentLines();

                attachments.forEach(({ sourceId, targetId, color }) => {
                    placeCircle(sourceId, color);
                    placeCircle(targetId, color);
                });
            });

            function saveAttachments() {
                localStorage.setItem(attachmentsKey, JSON.stringify(attachments));
            }

            socket.on('attach_card', ({ gameId: g, sourceId, targetId, color }) => {
                //console.log('[attach_card]', sourceId, targetId, color);
                attachments.push({ sourceId, targetId, color });
                saveAttachments();
                placeCircle(sourceId, color);
                placeCircle(targetId, color);
            });

            const hoveredAttachmentCards = new Set();

            function drawAttachmentLines() {
                // clear old
                document.querySelectorAll(".attachment-line").forEach(l => l.remove());
                // for any attachment where *either* end is hovered, draw its line
                attachments.forEach(({ sourceId, targetId, color }) => {
                    if (!hoveredAttachmentCards.has(sourceId) &&
                        !hoveredAttachmentCards.has(targetId)) return;

                    const srcDot = document.querySelector(
                    `[data-card-id="${sourceId}"] .attachment-circle[data-color="${color}"]`
                    );
                    const tgtDot = document.querySelector(
                    `[data-card-id="${targetId}"] .attachment-circle[data-color="${color}"]`
                    );
                    if (!srcDot || !tgtDot) return;

                    const r = srcDot.getBoundingClientRect();
                    const s = tgtDot.getBoundingClientRect();
                    const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
                    svg.classList.add("attachment-line");
                    Object.assign(svg.style,{
                        position: "fixed", top: 0, left: 0,
                        width: "100%", height: "100%",
                        pointerEvents: "none", zIndex: 110000
                    });
                    const line = document.createElementNS(svg.namespaceURI,"line");
                    line.setAttribute("x1", r.left + r.width/2);
                    line.setAttribute("y1", r.top  + r.height/2);
                    line.setAttribute("x2", s.left + s.width/2);
                    line.setAttribute("y2", s.top  + s.height/2);
                    line.setAttribute("stroke", color);
                    line.setAttribute("stroke-width", "5");
                    line.setAttribute("stroke-dasharray", "4 4");
                    svg.appendChild(line);
                    document.body.appendChild(svg);
                });
            }

            function clearAttachmentLines() {
                document.querySelectorAll(".attachment-line").forEach(l => l.remove());
            }

            function placeCircle(cardId, color) {
                // pick the real field wrapper
                const all = Array.from(document.querySelectorAll(`[data-card-id="${cardId}"]`));
                const el  = all.find(e => !e.closest('#viewing-window'));
                if (!el) {
                    console.warn(`placeCircle: no wrapper for ${cardId}`);
                    return;
                }

                if (getComputedStyle(el).position === "static") {
                    el.style.position = "relative";
                }

                // remove old dot
                el.querySelectorAll(`.attachment-circle[data-color="${color}"]`)
                    .forEach(d => d.remove());

                // add new dot
                const circle = document.createElement("div");
                circle.className = "attachment-circle";
                circle.dataset.color = color;
                Object.assign(circle.style,{
                    position:     "absolute",
                    width:        "48px",
                    height:       "48px",
                    border:       `4px solid white`,
                    backgroundColor: `${color}`,
                    borderRadius: "50%",
                    top:          "25%",
                    left:         "0%",
                    transform:    "translate(-50%, -50%)",
                    pointerEvents:"none",
                    zIndex:       200000
                });
                el.appendChild(circle);

                // unbind any old enter/leave
                if (el._enter) el.removeEventListener("mouseenter", el._enter);
                if (el._leave) el.removeEventListener("mouseleave", el._leave);

                // bind new hover handlers
                const onEnter = () => {
                    hoveredAttachmentCards.add(cardId);
                    drawAttachmentLines();
                };
                const onLeave = () => {
                    hoveredAttachmentCards.delete(cardId);
                    if (hoveredAttachmentCards.size) drawAttachmentLines();
                    else clearAttachmentLines();
                };
                el._enter = onEnter;
                el._leave = onLeave;
                el.addEventListener("mouseenter", onEnter);
                el.addEventListener("mouseleave", onLeave);
            }

            function removeCircle(cardId) {
                const all = Array.from(document.querySelectorAll(`[data-card-id="${cardId}"]`));
                const el  = all.find(e => !e.closest('#viewing-window'));
                if (!el) return;
                el.querySelectorAll(".attachment-circle").forEach(d => d.remove());
                clearAttachmentLines();
            }

            socket.on('remove_attachment', ({ sourceId, targetId, color }) => {
                // remove from array
                const idx = attachments.findIndex(a =>
                    a.sourceId==sourceId && a.targetId==targetId && a.color==color
                );
                if (idx !== -1) {
                    attachments.splice(idx, 1);
                    saveAttachments();
                    removeCircle(sourceId);
                    removeCircle(targetId);
                }
            });

            socket.on('play_sound', ({ url }) => {
                const audio = new Audio(url);
                audio.play().catch(err => console.error('Failed to play sound:', err));
            });

            // ─ Preload image URLs ───────────────────────────────────────────
            const headsImgUrl = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png";
            const tailsImgUrl = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/tails.png";
            const diceImgPrefix = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/dice"; // e.g. dice1.png–dice6.png

            // 1️⃣ Update the coin-flip button handler
            document.getElementById("coin-btn").onclick = () => {
                const result = Math.random() < 0.5 ? "Heads" : "Tails";
                playSoundEffect('coin');
                addGameLogEntry(`${username} flipped a coin: ${result}`);
                showCentralCoin(result);
                socket.emit('coin_flip', { gameId, result });
            };

            // track mute state
            let isMuted = false;

            // grab the button
            const muteBtn = document.getElementById('muteBtn');
            muteBtn.addEventListener('click', () => {
                isMuted = !isMuted;
                muteBtn.textContent = isMuted ? '🔇' : '🔊';
            });

            // Keep a reference to the native Audio constructor
            const NativeAudio = window.Audio;

            // Replace it with a wrapper
            window.Audio = function(src) {
                const a = new NativeAudio(src);
                // ensure it always follows your global mute flag
                Object.defineProperty(a, 'muted', {
                    get:    () => isMuted,
                    set:    () => {},     // ignore any external attempts to override
                    configurable: true
                });
                // Also zero out volume if you prefer
                a.volume = isMuted ? 0 : 1;
                return a;
            };

            // 2️⃣ Listen for opponent’s flip
            socket.on('coin_flip', ({ result }) => {
                //addGameLogEntry(`Opponent flipped a coin: ${result}`, false);
                showCentralCoin(result);
            });

            // 3️⃣ Update the dice-roll button handler
            document.getElementById("dice-btn").onclick = () => {
                const roll = Math.floor(Math.random() * 6) + 1;
                playSoundEffect('dice');
                addGameLogEntry(`${username} rolled a d6: ${roll}`);
                showCentralDice(roll);
                socket.emit('dice_roll', { gameId, roll });
            };

            // 4️⃣ Listen for opponent’s roll
            socket.on('dice_roll', ({ roll }) => {
                //addGameLogEntry(`Opponent rolled a d6: ${roll}`, false);
                showCentralDice(roll);
            });

            // ─────────────── Utility animation functions ────────────────

            // Coin flip: flash, expand, fade
            function showCentralCoin(result) {
            const container = document.createElement('div');
            const img = document.createElement('img');
            img.src = result === 'Heads' ? headsImgUrl : tailsImgUrl;
            Object.assign(container.style, {
                position: 'fixed',
                left: '50%', top: '50%',
                transform: 'translate(-50%,-50%)',
                zIndex: 200000,
                pointerEvents: 'none'
            });
            container.appendChild(img);
            document.body.appendChild(container);

            container.animate([
                { transform: 'translate(-50%,-50%) scale(0)', opacity: 0 },
                { transform: 'translate(-50%,-50%) scale(1.5)', opacity: 1 },
                { transform: 'translate(-50%,-50%) scale(0)', opacity: 0 }
            ], {
                duration: 1000,
                easing: 'ease-out',
                fill: 'forwards'
            }).finished.then(() => container.remove());
            }

            // Dice roll: cycle random faces, then show final
            function showCentralDice(finalRoll) {
            const container = document.createElement('div');
            const img = document.createElement('img');
            Object.assign(container.style, {
                position: 'fixed',
                left: '50%', top: '50%',
                transform: 'translate(-50%,-50%)',
                zIndex: 200000,
                pointerEvents: 'none'
            });
            img.style.width  = '120px';
            img.style.height = '120px';
            container.appendChild(img);
            document.body.appendChild(container);

            let ticks = 0;
            const maxTicks = 12;      // how many random faces to show
            const interval = setInterval(() => {
                const face = Math.floor(Math.random() * 6) + 1;
                img.src = `${diceImgPrefix}${face}.png`;
                ticks++;
                if (ticks >= maxTicks) {
                clearInterval(interval);
                img.src = `${diceImgPrefix}${finalRoll}.png`;
                // fade out
                container.animate([
                    { opacity: 1 },
                    { opacity: 0 }
                ], { duration: 500, fill: 'forwards' })
                .finished.then(() => container.remove());
                }
            }, 80);
            }


            function addGameLogEntry(message, broadcast = true) {
                const gameLog = document.getElementById("game-log-placeholder");
                if (!gameLog) return;

                const time = new Date().toLocaleTimeString();
                const entry = document.createElement("div");
                entry.textContent = `[${time}] ${message}`;
                gameLog.appendChild(entry);
                gameLog.scrollTop = gameLog.scrollHeight;

                if (broadcast && window.socket && gameId && username) {
                    socket.emit('game_log', { gameId, username, message });
                }
            }

            function triggerPhaseWaveEffect() {
                const tracker = document.getElementById("phase-tracker");
                if (!tracker) return;

                const wave = document.createElement("div");
                wave.classList.add("phase-wave-effect");
                tracker.appendChild(wave);

                setTimeout(() => {
                    wave.remove();
                }, 1000); // match animation duration
            }

            function findCardByUidOrId(id) {
                const zones = [
                    ...(gameState[username]["Zone (Champion)"] || []),
                    ...(gameState[username]["FaceDownZone"] || []),
                ];
                return zones.find(c => String(c.id) === String(id) || String(c.id) === String(id));
            }

            function detachDrawBox() {
                const draw    = document.getElementById('phase-Draw');      // the Draw square
                const tracker = document.getElementById('phase-tracker');   // row of phase boxes
                if (!draw || !tracker || draw.dataset.detached) return;     // already done?

                    const gapPx   = parseFloat(getComputedStyle(tracker).gap) || 0;

                    /* remember Draw’s offset *inside* the tracker plus one-box shift */
                    draw.dataset.offsetX = draw.offsetLeft - draw.offsetWidth - gapPx;
                draw.dataset.offsetY = draw.offsetTop;    // px from tracker’s top edge

                /* 2. move it out of the tracker’s stacking context (z-index 100 600) */
                tracker.removeChild(draw);
                document.body.appendChild(draw);
                draw.dataset.detached = 'true';

                /* 3. give it root-level positioning & a higher stacking order */
                Object.assign(draw.style, {
                position: 'fixed',
                zIndex:   '100950',      // now above playerReserveBox (100 900)
                opacity: '0',
                transition: 'opacity 0.6s ease-in-out'
                });

                repositionDrawBox();      // place it once for the current size
                syncOpacityWithTracker();     // **immediately match the current opacity**
                observeTrackerOpacity();      // **start watching for future changes**
            }

            /** Put the box back over the tracker using stored offsets */
            function repositionDrawBox() {
                const draw    = document.getElementById('phase-Draw');
                const tracker = document.getElementById('phase-tracker');
                if (!draw || !tracker || !draw.dataset.detached) return;

                const rect = tracker.getBoundingClientRect();   // new screen coords
                const dx   = parseFloat(draw.dataset.offsetX);
                const dy   = parseFloat(draw.dataset.offsetY);

                draw.style.left = `${rect.left + dx}px`;
                draw.style.top  = `${rect.top  + dy}px`;
            }

            function syncOpacityWithTracker() {
                const draw    = document.getElementById('phase-Draw');
                const tracker = document.getElementById('phase-tracker');
                if (!draw || !tracker) return;
                draw.style.opacity = getComputedStyle(tracker).opacity;
            }


            function observeTrackerOpacity() {
                const tracker = document.getElementById('phase-tracker');
                if (!tracker) return;

                new MutationObserver(syncOpacityWithTracker)
                .observe(tracker, { attributes: true, attributeFilter: ['style'] });
            }

            window.addEventListener('DOMContentLoaded', detachDrawBox); // run once
            window.addEventListener('resize',      repositionDrawBox);  // realign on scale

        function handsAreEqual(currentHand) {
        return (
            currentHand.length === previousHandIds.length &&
            currentHand.every((card, index) => card.id === previousHandIds[index])
        );
        }

        function isMainPhase(phase) {
            return ["Main 1", "Main 2"].includes(gameState?.turn?.currentPhase);
        }

        function playSoundEffect(effectName) {
            const params = new URLSearchParams(window.location.search);
            const gameId = params.get("gameId");

            if (!gameId) {
                console.warn("Cannot play sound — gameId missing.");
                return;
            }

            socket.emit("play_sound", {
                effect: effectName,
                gameId
            });
        }
        window.playSoundEffect = playSoundEffect;

        function updateOpponentDeckCount() {
            const opponent = gameState[gameState.player1 === username ? gameState.player2 : gameState.player1];
            const opponentDeck = opponent?.Deck || [];
            const deckBox = document.getElementById("opponentDeckBox");

            //if (deckBox) {
                //deckBox.innerHTML = ""; // Clear old content

                //const overlay = document.createElement("div");
                //overlay.innerText = `${opponentDeck.length}`;
                //overlay.style.color = "white";
                //overlay.style.fontSize = "1em";
                //overlay.style.textAlign = "center";
                //overlay.style.textShadow = "2px 2px 4px black";
                //deckBox.appendChild(overlay);
            //}
        }

        async function updateLocalFromGameState() {
            if (!username || !gameState || !gameState[username]) {
                console.warn("updateLocalFromGameState: player state not ready", {
                    username, keys: Object.keys(gameState || {})
                });
                return;                 // bail out quietly – we’ll try again later
            }

            function rehydrateZone(zone, cards) {
                return zone.map(card => {
                    const full = cards.find(c => String(c.id) === String(card.id));
                    if (!full) {
                    console.warn("⚠️ Failed to rehydrate card", card);
                    return card;
                    }
                    return {
                    ...card,
                    ...full
                    };
                });
            }

            gameState[username].Hand = rehydrateZone(gameState[username].Hand, cards);
            gameState[username].Tomb = rehydrateZone(gameState[username].Tomb, cards);

            // ✅ Now get the hydrated player object
            const player = gameState[username];
            const currentHand = player.Hand;

            const prevLength = previousHandIds.length;
            const newLength = currentHand.length;

            //console.log("✅ Rehydrated Hand:", gameState[username].Hand);

            if (!handsAreEqual(currentHand)) {
                drawnCardsArray = currentHand;
                //console.log("✅ drawnCardsArray just before render:", drawnCardsArray);
                renderDrawnCards();

                if (!hasDrawnInitialHand && newLength >= 5) {
                    hasDrawnInitialHand = true;
                    previousHandIds = currentHand.map(card => card.id);
                    return;
                }

                if (hasDrawnInitialHand && newLength > prevLength) {
                    const prevIds = new Set(previousHandIds);
                    const newCards = currentHand.filter(c => !prevIds.has(c.id));

                    const drawnCards = newCards.filter(c =>
                        ["Deck", "Tomb", "Void", "Reserve"].includes(c.lastBoardState)
                    );

                    if (drawnCards.length > 0) {
                        //animateCardDraw(false);
                    }
                }
                previousHandIds = currentHand.map(card => card.id);
            }

            remainingDeck = gameState[username].Deck;
            updateDeckText();

            // ✅ Add this:
            updateTurnDisplay(gameState.turn);
            updatePhaseDisplay(gameState.turn.currentPhase);
            renderLatestTombCard();
            renderLatestVoidCard();
            renderLatestOpponentTombCard();
            renderLatestOpponentVoidCard();
            //console.log("✅ drawnCardsArray just before render:", drawnCardsArray);
            renderDrawnCards();
            renderOpponentHand();
            updateOpponentDeckCount();

            if (gameState[username] && gameState[username].hasBasicRallied === undefined) {
                gameState[username].hasBasicRallied = false;
            }

            const zoneMappings = {
                "Zone (Champion)": "Champions",
                "Zone (Arsenal)": "Arsenal",
                "Reserve": "Reserve",
                "FaceDownZone": "FaceDown",
                "FaceDownArsenalZone": "FaceDownArsenal"
            };

            const opponent = gameState[ gameState.player1 === username ? gameState.player2 : gameState.player1 ];
            if (!hasInitializedOpponentState) {
                const opponent = gameState[ gameState.player1 === username ? gameState.player2 : gameState.player1 ];
                opponentHandRevealed = gameState[opponent]?.handRevealed ?? false;
                renderOpponentHand();
                hasInitializedOpponentState = true;
            }
            for (const [zoneKey, domSuffix] of Object.entries(zoneMappings)) {
                await renderCardZone( opponent[zoneKey], `opponent${domSuffix}Box` );
            }
            if (isRefresh) {
                const zoneMappings = {
                    "Zone (Champion)": "playerChampionsBox",
                    "Zone (Arsenal)": "playerArsenalBox",
                    "Reserve": "playerReserveBox",
                    "FaceDownZone": "playerFaceDownBox",
                    "FaceDownArsenalZone": "playerFaceDownArsenalBox"
                };

                for (const [zoneKey, domId] of Object.entries(zoneMappings)) {
                    const cards = gameState[username][zoneKey];
                    if (cards) await renderCardZone(cards, domId);
                }
            }
        }

        async function getUsername() {
            const res = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/me', { credentials: 'include' });
            const data = await res.json();
            if (data.loggedIn) {
                username = data.username;
            }
        }

        async function initGameClient() {
            await getUsername();
            if (!username) {
                alert("Could not retrieve username.");
                return; // ✅ This is now valid
            }
            const roomId = localStorage.getItem('roomId') || gameId;
            socket.emit('init', { username, roomId });

            socket.on('connect', () => {
                socket.emit('init', { username, roomId });
            });

            socket.on('room_joined', ({ roomId: joined }) => {
                socket.emit('join_game_room', { gameId });
            });
        }

        async function drawCards(deck, numCards = 5, { log = true } = {}) {
            //console.log("🔍 drawCards() called, drawing", numCards, "card(s). Current deck:", deck.length);

            const drawnCards = deck.splice(0, numCards);
            drawnCards.forEach(card => {
                card.lastBoardState = card.boardState;
                card.boardState = "Hand";
            });
            gameState[username].Hand.push(...drawnCards);

            await sendZoneUpdate(["Deck", "Hand"]);
            renderDrawnCards();
            updateDeckText();

            if (log) {
                addGameLogEntry(
                `${username} drew ${numCards} card${numCards > 1 ? "s" : ""}.`
                );
            }

            return drawnCards;
        }

        async function showRedrawPrompt() {
            return new Promise((resolve) => {
                const overlay = document.createElement("div");
                overlay.style.position = "fixed";
                overlay.style.top = "50%";
                overlay.style.left = "50%";
                overlay.style.transform = "translate(-50%, -50%)";
                overlay.style.width = "450px";
                overlay.style.padding = "30px 20px";
                overlay.style.backgroundColor = "rgba(0, 0, 0)";
                overlay.style.zIndex = 200000;
                overlay.style.display = "flex";
                overlay.style.flexDirection = "column";
                overlay.style.justifyContent = "center";
                overlay.style.alignItems = "center";
                overlay.style.borderRadius = "12px";
                overlay.style.boxShadow = "0 0 20px black";
                overlay.style.opacity = "0";
                overlay.style.transition = "opacity 1s ease-in-out";

                setTimeout(() => {
                    overlay.style.opacity = "0.8";
                }, 1000);

                const prompt = document.createElement("div");
                prompt.innerHTML = "<h2 style='color:white'>Would you like to redraw your opening hand?</h2>";
                prompt.style.marginBottom = "20px";

                const yesBtn = document.createElement("button");
                yesBtn.textContent = "Yes";
                yesBtn.style.marginRight = "10px";
                yesBtn.onclick = async () => {
                    if (!hasRedrawn) {
                        hasRedrawn = true;
                        const player = gameState[username];

                        // 1️⃣ Move original hand to bottom and sync that first
                        const oldHand = player.Hand.splice(0);
                        gameState[username].Deck.push(...oldHand);
                        addGameLogEntry(`${username} elected to redraw their Starting Hand.`);
                        await sendZoneUpdate(["Deck", "Hand"]);

                        // 2️⃣ Draw five new cards, one at a time
                        for (let i = 0; i < oldHand.length; i++) {
                            await drawCards(gameState[username].Deck, 1, { log: false });
                            await sendZoneUpdate(["Deck", "Hand"]);
                        }

                        // 3️⃣ Refresh your UI from the now-correct server state
                        await updateLocalFromGameState();
                    }

                    document.body.removeChild(overlay);
                    resolve();
                };

                const noBtn = document.createElement("button");
                noBtn.textContent = "No";
                noBtn.onclick = () => {
                document.body.removeChild(overlay);
                addGameLogEntry(`${username} elected not to redraw their Starting Hand.`);
                resolve();
                };

                const btnContainer = document.createElement("div");
                btnContainer.appendChild(yesBtn);
                btnContainer.appendChild(noBtn);
                overlay.appendChild(prompt);
                overlay.appendChild(btnContainer);

                document.body.appendChild(overlay);


            });
        }

        const isRefresh = sessionStorage.getItem(`visited_${gameId}`) === "true";
        sessionStorage.setItem(`visited_${gameId}`, "true");

        window.onload = () => {
            (async () => {
                await initGameClient();

                document.addEventListener("gameStateUpdated", () => {
                    console.log("gameStateUpdated event fired");
                    updateLocalFromGameState();
                });

                socket.emit("join_game_room", { gameId });
                //console.log("Joined game room", gameId);

                socket.on('game_log', ({ username: from, message }) => {
                    if (from !== username) addGameLogEntry(message, /*broadcast*/ false);
                });

                socket.on("match_next_game", (settings) => {
                    sessionStorage.setItem(matchId + "_gameNum", settings.gameNumber);
                    const me = username;                 // we already know who we are
                    const personalised = { ...settings };

                    // make sure *this* client is always playerUsername
                    if (personalised.playerUsername !== me) {
                        [personalised.playerUsername, personalised.opponentUsername] =
                            [me, personalised.playerUsername];

                        [personalised.playerDeck, personalised.opponentDeck] =
                            [personalised.opponentDeck, personalised.playerDeck];

                        if (personalised.turnOrder === "first") {
                            personalised.turnOrder = "second";
                        } else if (personalised.turnOrder === "second") {
                            personalised.turnOrder = "first";
                        }
                        personalised.goesFirst = personalised.turnOrder;
                    }
                    // settings is exactly the object the loser sent when creating the new game
                    const url = `game.html?${new URLSearchParams(personalised).toString()}`;
                    window.location.href = url;
                });

                socket.on('sync_zone', ({ owner, zone, cards }) => {
                    /* 1️⃣  trust the server – replace our copy of that zone */
                    if (cards) gameState[owner][zone] = cards;

                    /* 2️⃣  figure out which DOM box to repaint                */
                    const boxId = {
                        "Hand":                   owner === username ? "drawn-cards"              : "opponent-hand",
                        "Zone (Champion)":        owner === username ? "playerChampionsBox"       : "opponentChampionsBox",
                        "Zone (Arsenal)":         owner === username ? "playerArsenalBox"         : "opponentArsenalBox",
                        "Reserve":                owner === username ? "playerReserveBox"         : "opponentReserveBox",
                        "FaceDownZone":           owner === username ? "playerFaceDownBox"        : "opponentFaceDownBox",
                        "FaceDownArsenalZone":    owner === username ? "playerFaceDownArsenalBox" : "opponentFaceDownArsenalBox",
                        "Tomb":                   owner === username ? "playerTombBox"            : "opponentTombBox",
                        "Void":                   owner === username ? "playerVoidBox"            : "opponentVoidBox"
                    }[zone];

                    /* 3️⃣  repaint that box (or the hand helpers)              */
                    if (!boxId) return;
                    if (zone === "Hand") {
                        if (owner === username) {
                            drawnCardsArray = cards;        // for renderDrawnCards()
                            renderDrawnCards();
                        } else {
                            renderOpponentHand();
                        }
                    } else {
                        renderCardZone(cards, boxId);
                    }
                });

                socket.on('life_change', ({ player, life, from }) => {
                    if (from === username) return;

                    const original = gameState[player]?.life ?? life;
                    gameState[player].life = life;

                    const elem  = document.getElementById(
                                    player === username ? 'player-life' : 'opponent-life');
                    if (elem) animateLifeNumber(elem, original, life);
                });

                socket.on('card_targeted', ({ cardId }) => flashTargetRing(cardId));

                socket.on("phase_change", ({ phase, username: actor }) => {
                    gameState.turn.currentPhase = phase;
                    updatePhaseDisplay(phase);
                    triggerPhaseWaveEffect();
                    if (actor !== username) {
                        addGameLogEntry(`${actor} changed phase to ${phase}`);
                    }
                });

                socket.on("opponent_draw_card", ({ player, count }) => {
                    if (!username || player === username) return; // ignore self
                    for (let i = 0; i < count; i++) {
                        //animateCardDraw(true); // animate for opponent
                    }
                });
                socket.on("opponent_discard_card", ({ player, count }) => {
                    if (!username || player === username) return;
                    for (let i = 0; i < count; i++) {
                        //animateCardDiscard("opponent-hand", "opponentTombBox", true);
                    }
                });

                socket.on("game_over", async ({ winner, loser, draw, reason }) => {
                    /* ----------  score bookkeeping  ---------- */
                    const matchId = window.matchId;
                    let bannerMain, bannerReason = reason;

                    if (gameType === "match") {
                        const scores  = JSON.parse(sessionStorage.getItem(matchId) || "{}");

                        if (draw) {
                            scores.draws   = (scores.draws || 0) + 1;
                        } else {
                            scores[winner] = (scores[winner] || 0) + 1;
                        }
                        sessionStorage.setItem(matchId, JSON.stringify(scores));

                        if (draw) {
                            const params      = new URLSearchParams(window.location.search);
                            const opponent    = (params.get("playerUsername") === username)
                                                ? params.get("opponentUsername")
                                                : params.get("playerUsername");

                            const myWins      = scores[username]   || 0;
                            const oppWins     = scores[opponent]   || 0;
                            const draws       = scores.draws       || 0;

                            bannerMain   = "Draw";
                            bannerReason = `Current score: ${myWins}-${draws}-${oppWins}`;
                        } else if (scores[winner] >= 2) {
                            window.matchFinished = true;
                            const myWins   = scores[username] || 0;
                            const oppWins  = scores[winner === username ? loser : winner] || 0;
                            const draws    = scores.draws || 0;

                            bannerMain   = (winner === username) ? "MATCH VICTORY" : "MATCH DEFEAT";
                            bannerReason = `Final score: ${myWins}-${draws}-${oppWins}`;
                        } else {
                            bannerMain = (winner === username) ? "You Win" : "You Lose";
                        }
                    } else {
                        bannerMain = draw ? "Draw" : (winner === username ? "You Win" : "You Lose");
                    }

                    /* ----------  show the banner once  ---------- */
                    showBanner(bannerMain, bannerReason);

                    /* ----------  loser’s totem picker (only if match continues) ---------- */
                    if (gameType === "match" && !window.matchFinished && bannerMain === "You Lose") {
                        setTimeout(prepareTotemSelectionForNextGame, 3000);
                    }
                    /* ---------- DRAW: player who went second now builds the next game ---------- */
                    if (gameType === "match" && draw && !window.matchFinished) {
                        const params = new URLSearchParams(window.location.search);

                        const cameFirst = gameState.turn.firstPlayer;
                        // who was second last game?
                        const secondPlayer = (cameFirst === params.get("playerUsername"))
                            ? params.get("opponentUsername")
                            : params.get("playerUsername");

                        if (username === secondPlayer) {           // ← only this client prepares
                            const allTotems = Object.assign({}, ...totems);      // your totem dict
                            const used      = JSON.parse(sessionStorage.getItem(matchId+"_totems")||"[]");

                            // pick a random unused totem
                            let choices = Object.keys(allTotems).filter(t => !used.includes(t));
                            if (choices.length === 0) {            // all used once – reset
                                choices = Object.keys(allTotems);
                                used.length = 0;
                            }
                            const totem = choices[Math.floor(Math.random()*choices.length)];
                            used.push(totem);
                            sessionStorage.setItem(matchId+"_totems", JSON.stringify(used));

                            // flip who goes first
                            const nextTurn = (params.get("turnOrder") === "first") ? "second" : "first";

                            // build next-game settings
                            const newGameId = Math.random().toString(36).substr(2,9);
                            const gameNumber = (Number(sessionStorage.getItem(matchId+"_gameNum")) || 1) + 1;
                            sessionStorage.setItem(matchId + "_gameNum", gameNumber);

                            const settings = {
                                prevGameId: params.get("gameId"),
                                gameId:     newGameId,
                                matchId,
                                gameType:   "match",
                                totem,
                                totemText:  allTotems[totem],
                                turnOrder:  nextTurn,
                                goesFirst:  secondPlayer,
                                isSinglePlayer: params.get("isSinglePlayer")==="true",
                                playerUsername: params.get("playerUsername"),
                                opponentUsername: params.get("opponentUsername"),
                                playerDeck:  params.get("playerDeck"),
                                opponentDeck:params.get("opponentDeck"),
                                gameNumber
                            };

                            // start the game on the server and tell both clients
                            await fetch(serverUrl+"/startGame", {
                                method:"POST",
                                credentials:"include",
                                headers:{ "Content-Type":"application/json" },
                                body:JSON.stringify(settings)
                            });
                            await new Promise(res => socket.emit("match_next_game", settings, res));

                            window.location.href = `game.html?${new URLSearchParams(settings)}`;
                        }
                    }
                });

                if (!username) {
                    console.warn("Username not set after init.");
                    return;
                }

            const params = new URLSearchParams(window.location.search);
            const turnOrder = params.get("turnOrder");
            const matchId =
                    params.get("matchId")               // came from previous game ?
                || params.get("prevGameId")            // fall back: game-1’s id
                || localStorage.getItem("currentMatchId")
                || Math.random().toString(36).substr(2, 9);   // brand-new match


            if (turnOrder === "coinflip") {
                const container = document.getElementById("coin-flip-container");
                const coin = document.getElementById("coin");
                const resultText = document.getElementById("flip-result");
                container.style.display = "block";
                resultText.textContent = "";

                // Image paths
                const headsImg = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png";
                const tailsImg = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/tails.png";

                let positionY = window.innerHeight / 2;
                let velocity = -25;
                let gravity = 1;
                let flips = 0;

                function animateFlip() {
                    coin.src = Math.random() > 0.5 ? headsImg : tailsImg;

                    positionY += velocity;
                    velocity += gravity;

                    coin.style.top = `${positionY}px`;

                    if (velocity > 0 && positionY >= window.innerHeight / 2) {
                        clearInterval(interval);

                        const finalResult = Math.random() > 0.5 ? "Heads" : "Tails";
                        coin.src = finalResult === "Heads" ? headsImg : tailsImg;

                        if (finalResult === "Tails") {
                            resultText.textContent = "You are going second.";
                            resultText.style.display = "block";
                            resultText.style.fontSize = "2em";
                            resultText.style.marginTop = "10%";
                            resultText.style.textShadow ="2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black";
                            setTimeout(() => transitionToNextScreen("second"), 2000);
                        } else {
                            resultText.textContent = "You won the coin flip! Choose:";
                            resultText.style.display = "block";
                            resultText.style.fontSize = "2em";
                            resultText.style.marginTop = "10%";
                            resultText.style.textShadow = "2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black";

                            const buttonContainer = document.createElement("div");
                            buttonContainer.style.marginTop = "20px";

                            const goFirstButton = document.createElement("button");
                            goFirstButton.textContent = "Go First";
                            goFirstButton.style.marginRight = "10px";
                            goFirstButton.className = "button button";
                            goFirstButton.style.zIndex = "150000";
                            goFirstButton.onclick = () => {
                                goFirstButton.style.zIndex = "1";
                                goFirstButton.style.opacity = "0";
                                clearTimeout(autoSelectTimer); // Cancel timer if selected manually
                                transitionToNextScreen("first");
                            };

                            const goSecondButton = document.createElement("button");
                            goSecondButton.textContent = "Go Second";
                            goSecondButton.className = "button button";
                            goSecondButton.style.zIndex = "150000";
                            goSecondButton.onclick = () => {
                                goSecondButton.style.zIndex = "1";
                                goSecondButton.style.opacity = "0";
                                clearTimeout(autoSelectTimer); // Cancel timer if selected manually
                                transitionToNextScreen("second");
                            };

                            buttonContainer.appendChild(goFirstButton);
                            buttonContainer.appendChild(goSecondButton);
                            container.appendChild(buttonContainer);

                            // Start 3-second timer for automatic selection
                            const autoSelectTimer = setTimeout(() => {
                                goFirstButton.style.opacity = "0";
                                goSecondButton.style.opacity = "0";
                                goFirstButton.style.zIndex = "1";
                                goSecondButton.style.zIndex = "1";
                                const randomChoice = Math.random() < 0.5 ? "first" : "second"; // 50/50 chance
                                console.log(`Time expired! Automatically choosing: ${randomChoice}`);
                                transitionToNextScreen(randomChoice);
                            }, 3000); // 3 seconds
                        }

                    }
                }
                const interval = setInterval(animateFlip, 50);
            }
            else if (turnOrder === "first" || turnOrder === "second") {
                // Directly proceed to game setup
                transitionToNextScreen(turnOrder);
            }
            else {
                document.body.innerHTML = `
                    <h1>Game Configuration</h1>
                    <p>Player Deck: ${params.get("playerDeck")}</p>
                    <p>Opponent Deck: ${params.get("opponentDeck")}</p>
                    <p>Game Type: ${params.get("gameType")}</p>
                    <p>Totem: ${params.get("totem")}</p>
                    <p>Turn Order: ${turnOrder}</p>
                `;
            }
        })();
    };

        async function fetchLatestTurnState() {
            console.log("🔍 fetchLatestTurnState ▶ GET /getGameState/" + gameId);
            const res = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`, {
                credentials: "include"
            });
            if (!res.ok) {
                console.warn("❌ fetchLatestTurnState failed:", res.status);
                return null;
            }
            const state = await res.json();
            console.log("📥 fetchLatestTurnState ◀ state:", state);
            return state;
        }

        async function waitForGameState(retries = 10, delayMs = 500) {
            for (let i = 0; i < retries; i++) {
                const res = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`, {
                credentials: "include"
                });

                function ensureZones(p) {
                    [
                        "Hand","Deck","Tomb","Void","Reserve",
                        "Zone (Champion)","FaceDownZone",
                        "Zone (Arsenal)","FaceDownArsenalZone"
                    ].forEach(z => { if (!p[z]) p[z] = []; });
                }

                if (res.ok) {
                    const gameState = await res.json();
                    ensureZones(gameState[gameState.player1]);
                    ensureZones(gameState[gameState.player2]);
                    if (gameState && gameState.turn) return gameState;
                }

                console.warn(`Retry ${i + 1} of ${retries}... waiting for game state...`);
                await new Promise(resolve => setTimeout(resolve, delayMs));
            }

            throw new Error("Game state failed to initialize in time.");
        }

        async function fetchGameStateFromServer() {
            try {
                const response = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`, {
                    credentials: "include"
                });

                if (!response.ok) {
                console.warn("⚠️ Failed to fetch game state:", response.status);
                return; // Don't continue if response is bad
                }

                const newGameState = await response.json();
                if (!newGameState || !newGameState.turn) {
                    console.warn("⚠️ Game state or turn missing from server");
                    return;
                }

                gameState = newGameState;
                const currentTurn = gameState.turn.count;

                updateLocalFromGameState();
                const playerState = gameState[username];
            } catch (err) {
                console.error("💥 Error fetching game state:", err);
            }
        }
        window.fetchGameStateFromServer = fetchGameStateFromServer;
        window.toggleOpponentReveal = () => {
            opponentHandRevealed = !opponentHandRevealed;
            renderOpponentHand();
        };

        function showBanner(mainText, reasonText) {
            const banner = document.getElementById("win-loss-banner");
            document.getElementById("win-loss-main-text").textContent = mainText;
            document.getElementById("win-loss-reason-text").textContent = reasonText;
            banner.style.display = "block";

            // ✅ Add game log entry
            const result = `${mainText.toUpperCase()}`;
            addGameLogEntry(`Game Ended: ${result} – ${reasonText}`);

            // ✅ Block all game interactions
            const blocker = document.createElement("div");
            blocker.id = "game-interaction-blocker";
            Object.assign(blocker.style, {
                position: "fixed",
                top: 0,
                left: 0,
                width: "100vw",
                height: "100vh",
                backgroundColor: "rgba(0, 0, 0, 0.1)",
                zIndex: 130000,
                pointerEvents: "all"
            });
            document.body.appendChild(blocker);

            attachments = [];
            saveAttachments();
            document.querySelectorAll('.attachment-circle').forEach(el => el.remove());
            clearAttachmentLines();

            // Only the loser in a match sees the next‐game prompt
            if (gameType === "match" && mainText === "You Lose") {
                setTimeout(() => {
                    if (!window.matchFinished) {
                        prepareTotemSelectionForNextGame();
                    }
                }, 3000);
            }
        }

        function prepareTotemSelectionForNextGame() {
            const allTotems = Object.assign({}, ...totems); // Assuming `totems` is an array of objects
            const usedTotem = params.get("totem");
            const unusedTotems = Object.keys(allTotems).filter(name => name !== usedTotem);
            const randomChoices = unusedTotems.sort(() => 0.5 - Math.random()).slice(0, 3);

            const overlay = document.createElement("div");
            Object.assign(overlay.style, {
                position: "fixed",
                top: "50%",
                left: "50%",
                transform: "translate(-50%, -50%)",
                padding: "30px",
                backgroundColor: "#333",
                color: "white",
                border: "2px solid white",
                borderRadius: "10px",
                zIndex: 130001,
                textAlign: "center",
                boxShadow: "0 0 10px black"
            });

            overlay.innerHTML = `<p style="font-size: 1.2em;">You lost the last game.<br><strong>First, choose who goes first:</strong></p>`;

            const goFirstBtn = document.createElement("button");
            goFirstBtn.textContent = "Go First";
            goFirstBtn.style.margin = "10px";
            goFirstBtn.onclick = () => showTotemOptions("first");

            const goSecondBtn = document.createElement("button");
            goSecondBtn.textContent = "Go Second";
            goSecondBtn.style.margin = "10px";
            goSecondBtn.onclick = () => showTotemOptions("second");

            overlay.appendChild(goFirstBtn);
            overlay.appendChild(goSecondBtn);

            function showTotemOptions(turnOrder) {
                overlay.innerHTML = `<p style="font-size: 1.2em;">Now choose a Totem for Game ${gameNumber + 1}:</p>`;

                randomChoices.forEach(totem => {
                    const button = document.createElement("button");
                    button.textContent = totem;
                    button.style.margin = "10px";
                    button.onclick = async () => {
                        const newGameId = Math.random().toString(36).substr(2, 9);
                        const params       = new URLSearchParams(window.location.search);
                        const isSingle     = params.get("isSinglePlayer") === "true";
                        const opponentPull = params.get("opponentUsername");
                        const gameNumber = (Number(sessionStorage.getItem(matchId+"_gameNum")) || 1) + 1;
                        sessionStorage.setItem(matchId + "_gameNum", gameNumber);

                        const settings = {
                            prevGameId: params.get("gameId"),
                            gameId: newGameId,
                            playerDeck: params.get("playerDeck"),
                            opponentDeck: params.get("opponentDeck"),
                            gameType: "match",
                            totem,
                            totemText: allTotems[totem],
                            turnOrder,
                            isSinglePlayer: isSingle,
                            playerUsername: params.get("playerUsername"),
                            opponentUsername: params.get("opponentUsername"),
                            goesFirst: turnOrder,
                            matchId,
                            gameNumber
                        };

                        await fetch("https://geimon-app-833627ba44e0.herokuapp.com/startGame", {
                            method: "POST",
                            credentials: "include",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(settings)
                        });

                        socket.emit("match_next_game", settings);

                        const urlParams = new URLSearchParams(settings).toString();
                        window.location.href = `game.html?${urlParams}`;
                    };
                    overlay.appendChild(button);
                });
            }

            document.body.appendChild(overlay);
        }

        function updateTurnDisplay(turnData) {
            if (turnData && turnData.count) {
                document.getElementById("turn-counter").textContent = `Turn: ${turnData.count}`;

                const indicator = document.getElementById("turn-indicator");
                if (turnData.currentPlayer === username) {
                    indicator.textContent = "Your Turn";
                } else {
                    indicator.textContent = "Opponent's Turn";
                }
                    indicator.style.opacity = "1";

                const colorBox = document.getElementById("turn-color-box");
                if (colorBox) {
                    if (turnData.currentPlayer === username) {
                        colorBox.style.backgroundColor = "blue";
                    } else {
                        colorBox.style.backgroundColor = "red";
                    }
                }
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        document.querySelectorAll(".phase-box").forEach(box => {
            box.style.cursor = "pointer";
            box.addEventListener("click", () => {
            playSoundEffect('phase');

            const phase         = box.textContent.trim();
            const turnCount     = gameState.turn.count;
            const currentPhase  = gameState.turn.currentPhase;
            const player        = gameState.turn.currentPlayer;

            // 1) Must be your turn
            if (player !== username) return;

            // 2) Turn-1 restrictions
            if (turnCount === 1 && (phase === "Battle" || phase === "Main 2")) return;

            // 3) Phase-flow rules
            const allowed = {
                "Intermission": ["Draw"],
                "Draw":         ["Main 1"],
                "Main 1":       ["Battle","End"],
                "Battle":       ["Main 2"],
                "Main 2":       ["End"]
            };
            // allow re-clicking End when already in End
            if (!allowed[currentPhase]?.includes(phase) && !(currentPhase === "End" && phase === "End")) {
                console.error("Invalid transition:", currentPhase, "→", phase);
                return;
            }

            // 4) optimistic update
            updatePhaseDisplay(phase);
            triggerPhaseWaveEffect();
            if (phase === "End" && player === username) {
                showEndTurnButton();
            }

            // 5) fire over WebSocket instead of fetch()
            socket.emit(
                "phase_change_request",
                { gameId, username, phase },
                (ack) => {
                    if (ack.error) {
                        console.error("Phase change failed:", ack.error);
                        // rollback
                        updatePhaseDisplay(currentPhase);
                        return;
                    }

                    // if server corrected phase
                    if (ack.currentPhase !== phase) {
                        updatePhaseDisplay(ack.currentPhase);
                        triggerPhaseWaveEffect();
                    }

                    //addGameLogEntry(`${username} changed phase to ${ack.currentPhase}`);
                }
            );
            });
        });

        /* ───────────────────── HAND UTILITIES  ───────────────────── */
        let handRevealed   = false;          // my hand currently shown?
        let savedHandOrder = [];             // stores original DOM order for “Sort”

        // helper – apply or remove outline
        function updateHandOutline(){
            document.querySelectorAll('#drawn-cards .card')
                    .forEach(el => el.classList.toggle('revealed-card', handRevealed));
        }

        /* -------- SHUFFLE ------------ */
        document.getElementById('shuffle-hand-btn').onclick = () => {
            const hand = document.getElementById('drawn-cards');
            if (!hand) return;
            playSoundEffect('shuffle-hand');
            const cards = [...hand.children];
            savedHandOrder = cards.map(c => c);                // remember current order
            cards.sort(()=>Math.random() - 0.5);
            cards.forEach(c => hand.appendChild(c));
            addGameLogEntry(`${username} shuffled their hand.`);
        };

        /* -------- SORT --------------- */
        document.getElementById('sort-hand-btn').onclick = () => {
            const hand = document.getElementById('drawn-cards');
            if (!hand || savedHandOrder.length === 0) return;
            savedHandOrder.forEach(c => hand.appendChild(c));  // restore original order
            savedHandOrder = [];
            addGameLogEntry(`${username} sorted their hand.`);
        };

        /* -------- REVEAL / HIDE ------ */
        const revealBtn = document.getElementById('reveal-hand-btn');
        revealBtn.onclick = () => {
            handRevealed = !handRevealed;
            updateHandOutline();
            revealBtn.title = handRevealed ? 'Hide Hand' : 'Reveal Hand';
            revealBtn.src   = handRevealed
                                ? 'https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/eye-closed.png'
                                : 'https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/eye.png';
            socket.emit('hand_reveal', { gameId, from:username, reveal:handRevealed });
            addGameLogEntry(`${username} ${handRevealed ? 'revealed' : 'hid'} their hand.`);
        };

        /* receive opponent reveal */
        socket.on('hand_reveal', ({ from, reveal }) => {
            const params = new URLSearchParams(window.location.search);
            const username = params.get("playerUsername") || "You";
            const opponentUsernameParam = params.get("opponentUsername") || (params.get("isSinglePlayer") === "true" ? "Bot" : "Opponent");

            if (from === username) return;       // ignore our echo

            opponentHandRevealed = reveal;
            renderOpponentHand();
            const msg = `${from} ${reveal ? 'revealed' : 'hid'} their hand.`;
            addGameLogEntry(msg, false);
        });

        /* make sure outlines appear whenever we (re)render our hand */
        const origRenderDrawnCards = renderDrawnCards;
        renderDrawnCards = async function(...args){
            await origRenderDrawnCards.apply(this,args);
            updateHandOutline();
        };

        // TOKEN CREATION
        document.getElementById("token-btn").onclick = () => {
            const popup = document.createElement("div");
            Object.assign(popup.style, {
                position: "fixed",
                top: "50%",
                left: "50%",
                transform: "translate(-50%, -50%)",
                background: "#222",
                color: "white",
                padding: "20px",
                borderRadius: "10px",
                zIndex: 200000,
                textAlign: "center"
            });

            popup.innerHTML = `
                <label style="display:block; margin-bottom:5px;">Select Token Type:</label>
                <select id="token-select" style="width: 200px; margin-bottom: 10px;">
                    ${tokens
                        .slice()
                        .sort((a, b) => a.name.localeCompare(b.name))
                        .map(t => `<option value="${t.id}">${t.name}</option>`)
                        .join("")}
                </select>
                <br>
                <label>Quantity: <input id="token-qty" type="number" value="1" min="1" style="width: 60px;"></label>
                <br><br>
                <button id="confirm-token" style="margin-right:10px;">Confirm</button>
                <button id="cancel-token">Cancel</button>
            `;

            document.body.appendChild(popup);
            document.getElementById("cancel-token").onclick = () => popup.remove();

            document.getElementById("confirm-token").onclick = async () => {
                const tokenId = document.getElementById("token-select").value;
                const quantity = parseInt(document.getElementById("token-qty").value);
                const tokenCard = tokens.find(t => String(t.id) === String(tokenId));
                if (!tokenCard || isNaN(quantity) || quantity <= 0) return;

                const zoneKey = "Zone (Champion)";
                const renderTargetId = "playerChampionsBox";

                if (!gameState[username][zoneKey]) {
                    gameState[username][zoneKey] = [];
                }

                for (let i = 0; i < quantity; i++) {
                    const tokenCopy = {
                        ...tokenCard,
                        id: `${tokenCard.id}`, // 👈 predictable and parseable
                        boardState: "Zone (Champion)",
                        lastBoardState: "TokenCreate",
                        type: "Champion"
                    };
                    gameState[username]["Zone (Champion)"].push(tokenCopy);
                }

                await sendZoneUpdate(["Zone (Champion)"]);
                renderCardZone(gameState[username][zoneKey], renderTargetId);
                addGameLogEntry(`${username} created ${quantity} ${tokenCard.name} token${quantity > 1 ? "s" : ""} on their side.`);
                popup.remove();
            };
        };

        const ICON_PATH = 'https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/';
        const ICONS = [
            { file:'good.png',      title:'Thumbs-up'   },
            { file:'bad.png',       title:'Thumbs-down' },
            { file:'thinking.png',  title:'…'           },
            { file:'response.png',  title:'!'           },
        ];

        const reactBar = document.createElement('div');
        Object.assign(reactBar.style, {
            position:'absolute', left:'1910px', top:'30px',
            width:'100px', height:'100px',        // same footprint as profile pic
            display:'grid', gridTemplateColumns:'1fr 1fr', gap:'4px',
            zIndex:'1010', opacity: '0', transition:'opacity 1s ease',
        });
        document.body.appendChild(reactBar);
        setTimeout(() => {
            reactBar.style.opacity = "1";
        }, 6500);

        function flashIcon(src) {
            const img = document.createElement('img');
            Object.assign(img.style, {
                position:'fixed', left:'50%', top:'50%', transform:'translate(-50%,-50%)',
                width:'200px', pointerEvents:'none', zIndex:'200000', opacity:'0',
                transition:'opacity .5s ease',
            });
            img.src = src;
            document.body.appendChild(img);
            playSoundEffect('alert');
            requestAnimationFrame(() => (img.style.opacity = '1'));   // fade in
            setTimeout(() => {
                img.style.opacity = '0';
                img.addEventListener('transitionend', () => img.remove(), { once: true });
            }, 1500);
        }

        // 3) build the four buttons
        ICONS.forEach(({ file, title }) => {
            const btn = document.createElement('img');
            btn.src   = ICON_PATH + file;
            btn.title = title;
            Object.assign(btn.style, { width:'46px', height:'46px', cursor:'pointer' });
            btn.onclick = () => {
                const src = ICON_PATH + file;
                flashIcon(src);                                   // show on *my* screen
                socket.emit('signal_icon', { gameId, icon: src }); // broadcast to room
            };
            reactBar.appendChild(btn);
        });

        // 4) echo from the server → show on *their* screen
        socket.on('signal_icon', ({ icon }) => flashIcon(icon));

        /* ────────────────────────────  OFFER DRAW  ──────────────────────────────── */
        /* CSS for the modal overlay & box (inject once) */
        const styleTag = document.createElement('style');
        styleTag.textContent = `
        .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.5);display:flex;
                        align-items:center;justify-content:center;z-index:200000;}
        .modal-box    {background:#fff;padding:20px 28px;border-radius:10px;
                        box-shadow:0 4px 18px rgba(0,0,0,.36);text-align:center;}
        .modal-box h3 {margin-top:0;}
        .modal-box button{margin:8px 12px;min-width:80px;font-weight:bold;}
        .modal-box button:first-of-type{background:#4caf50;color:#fff;}
        .modal-box button:last-of-type{background:#d32f2f;color:#fff;}
        `;
        document.head.appendChild(styleTag);

        /* helper – returns Promise<boolean> */
        function confirmModal(title, msg, yesTxt = 'Yes', noTxt = 'No') {
        return new Promise(resolve => {
            const ov  = Object.assign(document.createElement('div'), { className:'modal-overlay' });
            const box = Object.assign(document.createElement('div'), { className:'modal-box' });
            box.innerHTML = `<h3>${title}</h3><p>${msg}</p>`;
            const ok  = Object.assign(document.createElement('button'), { textContent: yesTxt  });
            const no  = Object.assign(document.createElement('button'), { textContent: noTxt  });
            ok.onclick = () => { ov.remove(); resolve(true);  };
            no.onclick = () => { ov.remove(); resolve(false); };
            box.append(ok, no); ov.append(box); document.body.append(ov);
        });
        }

        /* button positioned just above opponent portrait (tweak coords if needed) */
        const drawBtn = document.createElement('button');
        drawBtn.textContent = 'Offer Draw';
        Object.assign(drawBtn.style, {
        position:'absolute', left:'1921px', top:'790px', zIndex:'1010',
        padding:'6px 10px', cursor:'pointer', fontWeight: 'bold',
        opacity: '0', transition:'opacity 1s ease',
        });
        document.body.appendChild(drawBtn);
        setTimeout(() => {
            drawBtn.style.opacity = "1";
        }, 6500);

        /* ─── 1) you click the button ────────────────────────────────────────────── */
        drawBtn.onclick = async () => {
        const ok = await confirmModal('Offer a Draw', 'Send a draw offer to your opponent?');
        if (!ok) return;
        socket.emit('draw_offer', { gameId, from: username });
        window.appendSystem('You offered a draw. Awaiting response…');
        };

        /* ─── 2) incoming draw offer ─────────────────────────────────────────────── */
        socket.on('draw_offer', async ({ from }) => {
        if (from === username) return;                            // ignore our echo
        const accept = await confirmModal('Draw Offer',
            `${from} offers a draw. Accept?`, 'Accept', 'Reject');
        socket.emit('draw_response', {
            gameId, from: username, response: accept ? 'accept' : 'reject'
        });
        });

        /* ─── 3) final result for both players ───────────────────────────────────── */
        socket.on('draw_result', ({ from, response }) => {
            const txt = response === 'accept'
                ? `${from} accepted the draw. The game is a draw.`
                : `${from} rejected the draw. Play continues.`;
            window.appendSystem(txt);

            /* show the end-game banner if accepted */
            if (response === "accept") {
                fetch("https://geimon-app-833627ba44e0.herokuapp.com/endGame", {
                    method:      "POST",
                    credentials: "include",
                    headers:     { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        gameId,
                        draw:   true,                 // ← key flag
                        reason: "Players agreed to a draw"
                    })
                }).catch(console.error);
            }
        });
        /* ─────────────────────────────────────────────────────────────────────────── */

        socket.on('attack_event', ({ cardId }) => {
            //console.log('👀 Received attack_event for', cardId);
            document.querySelectorAll(`[data-card-id="${cardId}"]`).forEach(el => {
                // if this element lives anywhere under the viewing-window, skip it
                if (el.closest('#viewing-window')) return;
                animateAttackToCenter(el, 800);
            });
        });

        socket.on('block_event', ({ cardId, isFaceDown }) => {
            //console.log('👀 Received block_event for', cardId);
            document.querySelectorAll(`[data-card-id="${cardId}"]`).forEach(el => {
                // skip the hover‐preview...
                if (el.closest('#viewing-window')) return;

                // find the wrapper <div class="card">
                const wrapper = el.classList.contains('card') 
                ? el 
                : el.closest('.card');
                if (!wrapper) return;

                animateBlock(wrapper, isFaceDown);
            });
        });

        // replay Declare flash for opponent
        socket.on('declare_event', ({ cardId }) => {
            document.querySelectorAll(`[data-card-id="${cardId}"]`).forEach(el => {
                flashDeclareEffect(el);
            });
        });

        function animateDeckShuffle(isOpponent = false) {
            // Determine which deck box to animate
            const deckBox = isOpponent ? opponentDeckBox : playerDeckBox;
            // Add the shuffle-animation class to trigger the CSS keyframes
            deckBox.classList.add('shuffle-animation');
            // Remove the class once the animation completes
            deckBox.addEventListener('animationend', () => {
                deckBox.classList.remove('shuffle-animation');
            }, { once: true });
        }

        function animateCardDraw(isOpponent = false) {
            const cardImg = document.createElement("img");
            const sleeveUrl = isOpponent
                ? opponentDeckBox?.style.backgroundImage?.slice(5, -2)
                : userSleeveURL;

            cardImg.src = sleeveUrl || "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site%20Assets/DefaultSleeve.png";
                cardImg.style.position = "fixed";
                cardImg.style.width = "173px";
                cardImg.style.height = "267px";
                cardImg.style.zIndex = "99999";
                cardImg.style.transition = "all 0.5s ease-in-out";
                cardImg.style.transform = "scale(0.8)";
                cardImg.style.outline = "2px solid white";

            // Determine start and end locations
            const startBox = isOpponent ? opponentDeckBox : playerDeckBox;
            const endBox = isOpponent ? document.getElementById("opponent-hand") : document.getElementById("drawn-cards");

            const startRect = startBox.getBoundingClientRect();
            const endRect = endBox.getBoundingClientRect();

            cardImg.style.left = `${startRect.left + startRect.width / 2 - 60}px`;
            cardImg.style.top = `${startRect.top + startRect.height / 2 - 105}px`;

            document.body.appendChild(cardImg);

            requestAnimationFrame(() => {
                if(!isOpponent) {
                    cardImg.style.left = `${endRect.left + endRect.width / 2 - 900}px`;
                    cardImg.style.top = `${endRect.top + endRect.height / 2 - 60}px`;
                } else {
                    cardImg.style.left = `${endRect.left + endRect.width / 2 - 0}px`;
                    cardImg.style.top = `${endRect.top + endRect.height / 2 - 120}px`;
                }
                cardImg.style.opacity = "0";
                cardImg.style.transform = "scale(0.5)";
            });

            setTimeout(() => cardImg.remove(), 1000);
        }

        function showEndTurnButton() {
            const button = document.getElementById("end-turn-button");
            button.style.display = "block";
            button.onclick = async () => {
                const res = await fetch(`${serverUrl}/endTurn`, {
                method: "POST",
                credentials: "include",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ gameId, username })
                });

                if (res.ok) {
                const data = await res.json();
                button.style.display = "none";
                await fetchGameStateFromServer();
                } else {
                alert("Failed to end turn.");
                }
            };
        }

        function flashDeclareEffect(cardEl) {
            if (cardEl.closest("#viewing-window")) return;
            // ensure we can position inside it
            cardEl.style.position = cardEl.style.position || 'relative';

            const flash = document.createElement('div');
            Object.assign(flash.style, {
                position:        'absolute',
                top:             '50%',
                left:            '50%',
                width:           '100%',
                height:          '100%',
                pointerEvents:   'none',
                borderRadius:    '8px',
                background:      'radial-gradient(circle, rgba(255,255,0,0.8) 0%, rgba(255,255,0,0) 80%)',
                transform:       'translate(-50%,-50%) scale(0)',
                opacity:         '0',
                zIndex:          '9999'
            });
            cardEl.appendChild(flash);

            flash.animate([
                { opacity: 0,   transform: 'translate(-50%,-50%) scale(0)' },
                { opacity: 1,   transform: 'translate(-50%,-50%) scale(1.5)' },
                { opacity: 0,   transform: 'translate(-50%,-50%) scale(2)' }
            ], {
                duration: 1000,
                easing:   'ease-out',
                fill:     'forwards'
            }).finished.then(() => flash.remove());
        }


        function animateCardDiscard(fromHandBoxId, toTombBoxId, isOpponent = false) {
            const handBox = document.getElementById(fromHandBoxId);
            const tombBox = document.getElementById(toTombBoxId);

            if (!handBox || !tombBox) return;

            const startRect = handBox.getBoundingClientRect();
            const endRect = tombBox.getBoundingClientRect();

            const sleeveUrl = isOpponent
                ? opponentDeckBox?.style.backgroundImage?.slice(5, -2)
                : userSleeveURL;

            const cardImg = document.createElement("img");
            cardImg.src = sleeveUrl || "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site%20Assets/DefaultSleeve.png";
                cardImg.style.position = "fixed";
                cardImg.style.width = "260px";
                cardImg.style.height = "400px";
                cardImg.style.left = `${startRect.left + startRect.width / 2 - 500}px`;
                cardImg.style.top = `${startRect.top + startRect.height / 2 - 35}px`;
                cardImg.style.transition = "all 0.5s ease-in-out";
                cardImg.style.zIndex = 99999;
                cardImg.style.opacity = "1";
                cardImg.style.outline = "2px solid white";

            document.body.appendChild(cardImg);

            requestAnimationFrame(() => {
                cardImg.style.left = `${endRect.left + endRect.width / 2 - 60}px`;
                cardImg.style.top = `${endRect.top + endRect.height / 2 - 220}px`;
                cardImg.style.opacity = "0.05";
                cardImg.style.transform = "scale(0.3)";
            });

            setTimeout(() => cardImg.remove(), 1000);
        }

        async function fetchOpponentData(opName) {
            try {
                const res = await fetch(`${serverUrl}/user-cosmetics/${opName}`, { credentials:'include' });
                if (!res.ok) throw new Error('bad response');
                return await res.json();     // { profilePic, deckSleeve, zoneArt }
            } catch (err) {
                console.warn('Failed to get opponent cosmetics:', err);
                return null;
            }
        }

        // 🔴 show the red ring for N ms (default 5000)
        const targetTimers = {};                 // cardId ➜ timeout handle

        function flashTargetRing(cardId, duration = 2500) {
            playSoundEffect('block');
            // 1️⃣  add / refresh the visual
            document.querySelectorAll(`.card[data-card-id="${cardId}"]`)
                .forEach(el => {
                    if (el.closest('.scaled-card') || el.closest('#viewing-window')) return;
                    el.classList.add('target-highlight');
                });

            // 2️⃣  clear any existing timer for this card
            clearTimeout(targetTimers[cardId]);

            // 3️⃣  schedule automatic removal
            targetTimers[cardId] = setTimeout(() => {
                document.querySelectorAll(`.card[data-card-id="${cardId}"]`)
                    .forEach(el => {
                        if (el.closest('.scaled-card') || el.closest('#viewing-window')) return;
                        el.classList.remove('target-highlight');
                    });
                    delete targetTimers[cardId];
            }, duration);
        }

        function wrapCardButton(btn, containerId) {
            const id      = btn.dataset.cardId;
            const cardData = cards.find(c => String(c.id) === id);
            if (!cardData) return;

            const isOpp = containerId.startsWith("opponent");
            if (isOpp) {
                attachTargetOverlay(btn, cardData);
            } else {
                attachHoverMenu(btn, cardData);
            }
        }

        const observer = new MutationObserver(muts => {
            muts.forEach(m => {
                m.addedNodes.forEach(node => {
                if (node.nodeType !== 1) return;

                // helper to find the enclosing zone’s id
                const findZoneId = el => el.closest(".card-zone")?.id || "";

                if (node.classList.contains("card-button")) {
                    const zoneId = findZoneId(node);
                    wrapCardButton(node, zoneId);
                } else {
                    node.querySelectorAll?.(".card-button").forEach(btn => {
                    const zoneId = findZoneId(btn);
                    wrapCardButton(btn, zoneId);
                    });
                }
                });
            });
        });
        observer.observe(document.body, { childList: true, subtree: true });

        function renderOpponentHand() {
            const container = document.getElementById("opponent-hand");
            if (!container || !gameState) return;

            const opponent = gameState[gameState.player1 === username ? gameState.player2 : gameState.player1];
            let opponentHand = opponent?.Hand || [];

            // Sort hand by type priority
            const typePriority = {
                "Champion": 6,
                "Action": 5,
                "Equipment": 4,
                "Obelisk": 3,
                "Rush": 2,
                "Reflex": 1
            };
            opponentHand = opponentHand.slice().sort((a, b) => {
                const fullA = cards.find(c => String(c.id) === String(a.id));
                const fullB = cards.find(c => String(c.id) === String(b.id));

                const typeA = typePriority[fullA?.type] || 99;
                const typeB = typePriority[fullB?.type] || 99;

                if (typeA !== typeB) {
                    return typeA - typeB;
                }

                // Reverse alphabetical comparison within type
                const nameA = fullA?.name?.toLowerCase() || "";
                const nameB = fullB?.name?.toLowerCase() || "";
                return nameB.localeCompare(nameA);
            });

            container.innerHTML = "";
            container.style.overflowX = "visible";
            container.style.flexWrap = "nowrap";

            opponentHand.forEach(cardData => {
                const isFaceUp = opponentHandRevealed ||
                    tempRevealedIds.has(String(cardData.id));
                const cardEl = document.createElement("div");
                cardEl.classList.add("card");
                cardEl.style.width = "260px";
                cardEl.style.height = "400px";
                cardEl.style.transform = "scale(0.48)";
                cardEl.style.marginLeft = "-200px";
                cardEl.style.top = "10px";
                cardEl.style.position = "relative";
                cardEl.style.overflow = "visible";
                cardEl.style.boxSizing = "border-box";
                cardEl.style.border = "none";
                cardEl.style.outline = "none";
                cardEl.style.boxShadow = "0 30px 40px rgba(0, 0, 0, 0.5)";

                if (isFaceUp) {
                    const fullCard = cards.find(c => String(c.id) === String(cardData.id));
                    if (fullCard) {
                        const renderedCard = renderCard(fullCard);
                            renderedCard.style.transformOrigin = "center center";
                            renderedCard.style.transform       = "rotate(180deg)";
                            renderedCard.style.position        = "absolute";
                            renderedCard.style.top             = "-25px";
                            renderedCard.style.left            = "125px";
                            renderedCard.style.width           = "100%";
                            renderedCard.style.height          = "100%";
                        renderedCard.dataset.cardId       = String(cardData.id);
                        cardEl.appendChild(renderedCard);

                        cardEl.addEventListener("mouseenter", () => {
                            const scaled = document.querySelector("#viewing-window .scaled-card");
                            if (!scaled) return;
                            scaled.innerHTML = "";                           // clear old card
                            const preview = renderCard(fullCard);            // new big card
                            preview.style.width  = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop  = "7%";
                            scaled.appendChild(preview);
                        });

                        addTooltipListeners(cardEl);
                        addTokenTooltipListeners(cardEl);
                    }
                } else {
                    const sleeveUrl = opponentDeckBox?.style.backgroundImage?.slice(5, -2) || "";
                    const sleeveImg = document.createElement("img");
                    sleeveImg.src = sleeveUrl;
                    sleeveImg.style.display = "block";
                    sleeveImg.style.width = "100%";
                    sleeveImg.style.height = "100%";
                    sleeveImg.style.objectFit = "cover";
                    sleeveImg.style.border = "4px solid white";
                    sleeveImg.style.outline = "none";
                    sleeveImg.style.boxShadow = "none";
                    sleeveImg.style.transform = "rotate(180deg)";
                    cardEl.appendChild(sleeveImg);

                    cardEl.onmouseenter = null;
                    cardEl.onmousemove = null;
                    cardEl.onmouseleave = null;
                }

                /* 🔴 1 – tag the DIV with its real ID so toggleTargetRing/flashTargetRing can find it */
                cardEl.dataset.cardId = String(cardData.id);

                /* 🔴 2 – drop an invisible click-catching overlay identical to your own-hand cards */
                const btn = document.createElement("button");
                btn.className = "card-button";
                Object.assign(btn.style, {
                    position: "absolute",
                    top:      "0",
                    left:     "0",
                    width:    "100%",
                    height:   "100%",
                    border:   "none",
                    background:"transparent",
                    opacity:  "0",
                    cursor:   "pointer",
                    //pointerEvents: isFaceUp ? "none" : "auto",
                    pointerEvents: "auto",
                    zIndex:   100100
                });
                //if (!isFaceUp) {
                    cardEl.appendChild(btn);
                    if (typeof wrapCardButton === "function") wrapCardButton(btn, container.id);
                    attachTargetOverlay(btn, cardData);
                //}

                container.appendChild(cardEl);
            });
        }

        function renderLatestTombCard() {
            const tombCards = gameState?.[username]?.Tomb || [];
            const tombTop   = tombCards[tombCards.length - 1];

            // 1) hide the box to prevent any flicker
            playerTombBox.style.visibility = 'hidden';

            // 2) clear & rebuild
            playerTombBox.innerHTML = "";

            // overlay
            const tombTextOverlay = document.createElement("div");
            tombTextOverlay.innerText = "Tomb";
            Object.assign(tombTextOverlay.style, {
                position: "absolute",
                zIndex:   "110000",
                left:     "45%",
                top:      "3%",
                transform:"translate(-50%, -50%)",
                fontSize: "1em",
                color:    "white",
                textShadow: `
                -2px -2px 4px black,
                2px -2px 4px black,
                -2px  2px 4px black,
                2px  2px 4px black`
            });
            playerTombBox.appendChild(tombTextOverlay);

            playerTombBox.onmouseenter = () => {
                tombTextOverlay.innerText = `${tombCards.length}`;
            };
            playerTombBox.onmouseleave = () => {
                tombTextOverlay.innerText = "Tomb";
            };

            // mini-card
            if (tombTop) {
                const card = cards.find(c => String(c.id) === String(tombTop.id));
                if (card) {
                const miniCard = renderCard(card);
                Object.assign(miniCard.style, {
                    transform:       "scale(0.3)",
                    transformOrigin: "top left",
                    marginTop:       "-8%",
                    marginLeft:      "0%",
                    pointerEvents:   "none"
                });
                playerTombBox.appendChild(miniCard);
                }
            }

            // 3) reveal & flash in the next frame
            requestAnimationFrame(() => {
                playerTombBox.style.visibility = '';
                playerTombBox.classList.add('flash');
                // remove flash class after your animation ends (200ms here as example)
                setTimeout(() => playerTombBox.classList.remove('flash'), 200);
            });
        }


        function renderLatestVoidCard() {
            const voidCards = gameState?.[username]?.Void || [];
            const voidTop   = voidCards[voidCards.length - 1];

            playerVoidBox.style.visibility = 'hidden';
            playerVoidBox.innerHTML       = "";

            const voidTextOverlay = document.createElement("div");
            voidTextOverlay.innerText = "Void";
            Object.assign(voidTextOverlay.style, {
                position: "absolute",
                zIndex:   "110000",
                left:     "45%",
                top:      "3%",
                transform:"translate(-50%, -50%)",
                fontSize: "1em",
                color:    "white",
                textShadow: `
                -2px -2px 4px black,
                2px -2px 4px black,
                -2px  2px 4px black,
                2px  2px 4px black`
            });
            playerVoidBox.appendChild(voidTextOverlay);

            playerVoidBox.onmouseenter = () => {
                voidTextOverlay.innerText = `${voidCards.length}`;
            };
            playerVoidBox.onmouseleave = () => {
                voidTextOverlay.innerText = "Void";
            };

            if (voidTop) {
                const card = cards.find(c => String(c.id) === String(voidTop.id));
                if (card) {
                const miniCard = renderCard(card);
                Object.assign(miniCard.style, {
                    transform:       "rotate(270deg) scale(0.3)",
                    transformOrigin: "top left",
                    marginTop:       "85px",
                    marginLeft:      "9px",
                    pointerEvents:   "none"
                });
                playerVoidBox.appendChild(miniCard);
                }
            }

            requestAnimationFrame(() => {
                playerVoidBox.style.visibility = '';
                playerVoidBox.classList.add('flash');
                setTimeout(() => playerVoidBox.classList.remove('flash'), 200);
            });
        }

        function renderLatestOpponentTombCard() {
            const tombCards = gameState?.[opponentName]?.Tomb || [];
            const tombTop   = tombCards[tombCards.length - 1];

            opponentTombBox.style.visibility = 'hidden';
            opponentTombBox.innerHTML       = "";

            const tombTextOverlay = document.createElement("div");
            tombTextOverlay.innerText = "Tomb";
            Object.assign(tombTextOverlay.style, {
                position: "absolute",
                zIndex:   "120500",
                left:     "45%",
                top:      "3%",
                transform:"translate(-50%, -50%)",
                fontSize: "1em",
                color:    "white",
                textShadow: `
                -2px -2px 4px black,
                2px -2px 4px black,
                -2px  2px 4px black,
                2px  2px 4px black`
            });
            opponentTombBox.appendChild(tombTextOverlay);

            opponentTombBox.onmouseenter = () => {
                tombTextOverlay.innerText = `${tombCards.length}`;
            };
            opponentTombBox.onmouseleave = () => {
                tombTextOverlay.innerText = "Tomb";
            };

            if (tombTop) {
                const card = cards.find(c => String(c.id) === String(tombTop.id));
                if (card) {
                const miniCard = renderCard(card);
                Object.assign(miniCard.style, {
                    transform:       "scale(0.3) rotate(180deg)",
                    transformOrigin: "top left",
                    marginTop:       "140%",
                    marginLeft:      "95.5%",
                    pointerEvents:   "none"
                });
                opponentTombBox.appendChild(miniCard);
                }
            }

            requestAnimationFrame(() => {
                opponentTombBox.style.visibility = '';
                opponentTombBox.classList.add('flash');
                setTimeout(() => opponentTombBox.classList.remove('flash'), 200);
            });
        }

        function renderLatestOpponentVoidCard() {
            const voidCards = gameState?.[opponentName]?.Void || [];
            const voidTop   = voidCards[voidCards.length - 1];

            opponentVoidBox.style.visibility = 'hidden';
            opponentVoidBox.innerHTML       = "";

            const voidTextOverlay = document.createElement("div");
            voidTextOverlay.innerText = "Void";
            Object.assign(voidTextOverlay.style, {
                position: "absolute",
                zIndex:   "110000",
                left:     "45%",
                top:      "3%",
                transform:"translate(-50%, -50%)",
                fontSize: "1em",
                color:    "white",
                textShadow: `
                -2px -2px 4px black,
                2px -2px 4px black,
                -2px  2px 4px black,
                2px  2px 4px black`
            });
            opponentVoidBox.appendChild(voidTextOverlay);

            opponentVoidBox.onmouseenter = () => {
                voidTextOverlay.innerText = `${voidCards.length}`;
            };
            opponentVoidBox.onmouseleave = () => {
                voidTextOverlay.innerText = "Void";
            };

            if (voidTop) {
                const card = cards.find(c => String(c.id) === String(voidTop.id));
                if (card) {
                const miniCard = renderCard(card);
                Object.assign(miniCard.style, {
                    transform:       "rotate(90deg) scale(0.3)",
                    transformOrigin: "top left",
                    marginTop:       "5%",
                    marginLeft:      "95.5%",
                    pointerEvents:   "none"
                });
                opponentVoidBox.appendChild(miniCard);
                }
            }

            requestAnimationFrame(() => {
                opponentVoidBox.style.visibility = '';
                opponentVoidBox.classList.add('flash');
                setTimeout(() => opponentVoidBox.classList.remove('flash'), 200);
            });
        }

        function getRandomBotSleeve() {
            return fetch("https://geimon-app-833627ba44e0.herokuapp.com/sleeve-images")
            .then(res => res.json())
            .then(sleeves => {
            if (Array.isArray(sleeves) && sleeves.length > 0) {
                const randomIndex = Math.floor(Math.random() * sleeves.length);
                return sleeves[randomIndex];
            } else {
                console.warn("No sleeves returned");
                return "DefaultSleeve.png";
            }
            })
            .catch(err => {
            console.error("Failed to fetch sleeves:", err);
            return "DefaultSleeve.png";
            });
        }

        function getRandomBotProfilePic() {
            return fetch("https://geimon-app-833627ba44e0.herokuapp.com/profile-images")
            .then(res => res.json())
            .then(images => {
            if (Array.isArray(images) && images.length > 0) {
                const randomIndex = Math.floor(Math.random() * images.length);
                return images[randomIndex];
            } else {
                console.warn("No profile images found.");
                return "Sharpshooter-Square.png";
            }
            })
            .catch(err => {
            console.error("Failed to fetch profile images:", err);
            return "Sharpshooter-Square.png";
            });
        }
        function getRandomBotZoneArt() {
            return fetch("https://geimon-app-833627ba44e0.herokuapp.com/zone-images")
                .then(res => res.json())
                .then(images => {
                    if (Array.isArray(images) && images.length > 0) {
                        const randomIndex = Math.floor(Math.random() * images.length);
                        return images[randomIndex];
                    } else {
                        console.warn("No zone images found.");
                        return "DefaultZone.png";
                    }
                })
                .catch(err => {
                    console.error("Failed to fetch zone images:", err);
                    return "DefaultZone.png";
                });
        }

        async function transitionToNextScreen(choice) {
            const params = new URLSearchParams(window.location.search);
            const playerUsernameParam   = params.get("playerUsername")     || username;
            const opponentUsernameParam = params.get("opponentUsername")           || (params.get("isSinglePlayer")==="true" ? "Bot" : (params.get("otherUser") || username));
            const gameTypeParam         = params.get("gameType")           || "single";
            const isSinglePlayerParam   = params.get("isSinglePlayer")==="true";
            const turnOrderParam        = params.get("turnOrder")          || "first";
            const rpsWinnerParam = params.get("rpsWinner");
            // Fetch deck and start game
            const playerDeckName = new URLSearchParams(window.location.search).get("playerDeck");
            const opponentDeckName = new URLSearchParams(window.location.search).get("opponentDeck");

            //console.log("→ fetching deck", playerDeckName, "owned by", playerUsernameParam);
            const playerDeckResult = await fetchDeckCards(playerDeckName, playerUsernameParam);
            const opponentDeckResult = await fetchDeckCards(opponentDeckName, opponentUsernameParam);
            const playerDeckCardIds   = await getDeckFromParam("playerDeck");
            if (playerDeckCardIds.length === 0) {
                return alert(`Could not load your deck "${playerDeckName}" (owner: ${playerUsernameParam}).`);
            }
            const opponentDeckCardIds = await getDeckFromParam("opponentDeck");
            if (opponentDeckCardIds.length === 0) {
                return alert(`Could not load opponent’s deck "${opponentDeckName}" (owner: ${opponentUsernameParam}).`);
            }
            // Keep the background image visible
            const bgImage = document.querySelector(".bg-image");

            // Create a semi-transparent overlay
            const overlay = document.createElement("div");
                overlay.style.position = "absolute";
                overlay.style.top = "0";
                overlay.style.left = "0";
                overlay.style.width = "100%";
                overlay.style.height = "100%";
                overlay.style.backgroundColor = "rgba(0, 0, 0, 0.4)"; // Dark transparency
                overlay.style.zIndex = "10";

            // Main container for the structured design
            const mainContainer = document.createElement("div");
                mainContainer.style.position = "absolute";
                mainContainer.style.top = "24px";
                mainContainer.style.left = "45px";
                mainContainer.style.width = "1920px";
                mainContainer.style.height = "903px";
                mainContainer.style.display = "flex";
                mainContainer.style.flexDirection = "column";
                mainContainer.style.justifyContent = "center";
                mainContainer.style.alignItems = "center";
                mainContainer.style.gap = "10px";
                mainContainer.style.padding = "20px";
                mainContainer.style.backgroundColor = "rgba(0, 0, 0)";
                mainContainer.style.borderRadius = "20px";
                mainContainer.style.zIndex = "20";
                mainContainer.style.opacity = "0"; // Start fully invisible
                mainContainer.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
                mainContainer.style.transform = "scale(0.8)  translate(100px,-50px)";

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                mainContainer.style.opacity = "1";
            }, 50);

            const actualFirstPlayer = turnOrderParam === "first" ? playerUsernameParam : opponentUsernameParam;
            const isRpsWinner = username === rpsWinnerParam;
            let isMyTurn;
            if (isRpsWinner) {
                // I made the choice, so "first" means I go first
                isMyTurn = turnOrderParam === "first";
            } else {
                // I didn't make the choice, so I get the opposite
                isMyTurn = turnOrderParam !== "first";
            }
            // Main board container
            const board = document.createElement("div");
                board.style.position = "absolute";
                board.style.top = "2%";
                board.style.left = "2%";
                board.style.width = "96%";
                board.style.height = "94%";
                board.style.backgroundColor = "black";
                board.style.zIndex = "20";
                board.style.borderRadius = "20px";
                board.style.opacity = "0"; // Start fully invisible
                board.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                board.style.opacity = "1";
            }, 50);

            const turnBox = document.createElement("div");
                turnBox.id = "turn-color-box";
                turnBox.style.position = "absolute";
                turnBox.style.left = "1343px";
                turnBox.style.top = "435px";
                turnBox.style.width = "305px";
                turnBox.style.height = "40px";
                turnBox.style.zIndex = "30";
                turnBox.style.border = "0px solid white";
                turnBox.style.borderRadius = "4px";
                turnBox.style.transition = "background-color 1s ease";
                turnBox.style.opacity = "0";
            document.body.appendChild(turnBox);

            setTimeout(() => {
                turnBox.style.opacity = "1"; // Fades out smoothly
            }, 2700);

            const championBox = document.getElementById("playerChampionsBox");
                championBox.style.position = "fixed";
                championBox.style.left = "695px";
                championBox.style.top = "525px";
                championBox.style.width = "525px";
                championBox.style.height = "128px";
                championBox.style.zIndex = "110000"; // ensure it's above the board
                championBox.style.pointerEvents = "auto";
                championBox.style.backgroundColor = "rgba(255, 0, 0, 0)"; // debug transparent background
                championBox.style.display        = "flex";
                championBox.style.justifyContent = "flex-start";
                championBox.style.alignItems     = "center";
                championBox.style.gap            = "0px";
                championBox.style.flexWrap       = "nowrap";

            const facedownBox = document.getElementById("playerFaceDownBox");
                facedownBox.style.position = "fixed";
                facedownBox.style.left = "1250px";
                facedownBox.style.top = "685px";
                facedownBox.style.width = "492px";
                facedownBox.style.height = "128px";
                facedownBox.style.zIndex = "110000";
                facedownBox.style.pointerEvents = "auto";
                facedownBox.style.backgroundColor = "rgba(0, 255, 0, 0)";
                facedownBox.style.display        = "flex";
                facedownBox.style.justifyContent = "flex-end";
                facedownBox.style.alignItems     = "center";
                facedownBox.style.gap            = "0px";
                facedownBox.style.flexWrap       = "nowrap";

            const arsenalBox = document.getElementById("playerArsenalBox");
                arsenalBox.style.position = "fixed";
                arsenalBox.style.left = "695px";
                arsenalBox.style.top = "674.5px";
                arsenalBox.style.width = "525px";
                arsenalBox.style.height = "128px";
                arsenalBox.style.zIndex = "110010"; // ensure it's above the board
                arsenalBox.style.pointerEvents = "auto";
                arsenalBox.style.backgroundColor = "rgba(255, 0, 0, 0)"; // debug transparent background
                arsenalBox.style.display        = "flex";
                arsenalBox.style.justifyContent = "flex-start";
                arsenalBox.style.alignItems     = "center";
                arsenalBox.style.gap            = "0px";
                arsenalBox.style.flexWrap       = "nowrap";

            const facedownArsenalBox = document.getElementById("playerFaceDownArsenalBox");
                facedownArsenalBox.style.position = "fixed";
                facedownArsenalBox.style.left = "1342.5px";
                facedownArsenalBox.style.top = "832.5px";
                facedownArsenalBox.style.width = "492px";
                facedownArsenalBox.style.height = "128px";
                facedownArsenalBox.style.zIndex = "110010";
                facedownArsenalBox.style.pointerEvents = "auto";
                facedownArsenalBox.style.backgroundColor = "rgba(0, 255, 0, 0)";
                facedownArsenalBox.style.display        = "flex";
                facedownArsenalBox.style.justifyContent = "flex-end";
                facedownArsenalBox.style.alignItems     = "center";
                facedownArsenalBox.style.gap            = "0px";
                facedownArsenalBox.style.flexWrap       = "nowrap";

            const reserveBox = document.getElementById("playerReserveBox");
                reserveBox.className = "card-zone";
                reserveBox.style.position = "absolute";
                reserveBox.style.left = "523.5px";
                reserveBox.style.top = "900px";
                reserveBox.style.width = "310px";
                reserveBox.style.height = "275px";
                reserveBox.style.zIndex = "100900";
                reserveBox.style.pointerEvents = "auto";
                reserveBox.style.backgroundColor = "rgba(255, 0, 0, 0)";
                reserveBox.style.display        = "flex";
                reserveBox.style.justifyContent = "flex-start";
                reserveBox.style.alignItems     = "center";
                reserveBox.style.gap            = "0px";

            fetchUserData().then(async userData => {
                if (userData && userData.zoneArt) {
                    const zoneArtContainer = document.createElement("div");
                        zoneArtContainer.style.position = "absolute";
                        zoneArtContainer.style.left = "0";
                        zoneArtContainer.style.bottom = "-18px";
                        zoneArtContainer.style.width = "100%";
                        zoneArtContainer.style.height = "51%";
                        zoneArtContainer.style.overflow = "hidden";

                    const zoneArtImage = document.createElement("img");
                        zoneArtImage.src = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Zones/${userData.zoneArt}`;
                        zoneArtImage.style.position = "absolute";
                        zoneArtImage.style.width = "100%";
                        zoneArtImage.style.height = "200%"; // Double height so top half is offscreen
                        zoneArtImage.style.top = "0%"; // Shift to crop top, show only bottom half
                        zoneArtImage.style.left = "0";
                        zoneArtImage.style.zIndex = "10";
                        zoneArtImage.style.border = "6px solid black";
                        zoneArtImage.style.objectFit = "cover";
                        zoneArtImage.style.opacity = "0.65";
                    zoneArtContainer.appendChild(zoneArtImage);
                    board.appendChild(zoneArtContainer);
                }
                // Opponent side zone art
                const opponentZoneArtContainer = document.createElement("div");
                    opponentZoneArtContainer.style.position = "absolute";
                    opponentZoneArtContainer.style.left = "0";
                    opponentZoneArtContainer.style.top = "0";
                    opponentZoneArtContainer.style.width = "100%";
                    opponentZoneArtContainer.style.height = "51%";
                    opponentZoneArtContainer.style.overflow = "hidden";
                    opponentZoneArtContainer.style.zIndex = "9"; // Slightly behind player’s zone art

                const opponentZoneArtImage = document.createElement("img");
                    opponentZoneArtImage.style.position = "absolute";
                    opponentZoneArtImage.style.width = "100%";
                    opponentZoneArtImage.style.height = "200%"; // Still double height
                    opponentZoneArtImage.style.bottom = "0"; // To keep bottom half showing
                    opponentZoneArtImage.style.left = "0";
                    opponentZoneArtImage.style.objectFit = "cover";
                    opponentZoneArtImage.style.border = "6px solid black";
                    opponentZoneArtImage.style.transform = "rotate(180deg)"; // Flip for opponent perspective
                    opponentZoneArtImage.style.opacity = "0.65";

                if (isSinglePlayer) {
                    getRandomBotZoneArt().then(zoneArtFile => {
                        opponentZoneArtImage.src = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Zones/${zoneArtFile}`;
                        opponentZoneArtContainer.appendChild(opponentZoneArtImage);
                        board.appendChild(opponentZoneArtContainer);
                    });
                } else {
                    const opponentData = isSinglePlayer ? null : await fetchOpponentData(opponentUsernameParam);
                    if (opponentData?.zoneArt) {
                        opponentZoneArtImage.src =
                            `${serverUrl}/Public/Images/Zones/${opponentData.zoneArt}`;
                        opponentZoneArtContainer.appendChild(opponentZoneArtImage);
                        board.appendChild(opponentZoneArtContainer);
                    }
                }
                const scale = window.innerWidth / 1920;
                if (userData && userData.profilePic) {
                    const playerProfilePic = document.createElement("div");
                    playerProfilePic.style.position = "absolute";
                    playerProfilePic.style.left = `1965px`;
                    playerProfilePic.style.top = `750px`;
                    playerProfilePic.style.width = `100px`;
                    playerProfilePic.style.height = `100px`;
                    playerProfilePic.style.zIndex = "100";
                    playerProfilePic.style.overflow = "hidden";

                    const profilePicImage = document.createElement("img");
                    profilePicImage.src = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Profile Pictures/${userData.profilePic}`;
                    profilePicImage.style.width = "100%";
                    profilePicImage.style.height = "100%";
                    profilePicImage.style.zIndex = "1100";
                    profilePicImage.style.border = "6px solid black";
                    profilePicImage.style.boxSizing = "border-box";
                    profilePicImage.style.objectFit = "cover";

                    playerProfilePic.appendChild(profilePicImage);
                    board.appendChild(playerProfilePic);
                }
                if (isSinglePlayer) {
                    getRandomBotProfilePic().then(profilePic => {
                        const scale = window.innerWidth / 1920;

                        const opponentProfilePic = document.createElement("div");
                        opponentProfilePic.style.position = "absolute";
                        opponentProfilePic.style.left = `1960px`;
                        opponentProfilePic.style.top = `70px`;  // Opponent zone
                        opponentProfilePic.style.width = `100px`;
                        opponentProfilePic.style.height = `100px`;
                        opponentProfilePic.style.zIndex = "100";
                        opponentProfilePic.style.overflow = "hidden";

                        const profilePicImage = document.createElement("img");
                        profilePicImage.src = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Profile Pictures/${profilePic}`;
                        profilePicImage.style.width = "100%";
                        profilePicImage.style.height = "100%";
                        profilePicImage.style.zIndex = "1100";
                        profilePicImage.style.border = "6px solid black";
                        profilePicImage.style.boxSizing = "border-box";
                        profilePicImage.style.objectFit = "cover";

                        opponentProfilePic.appendChild(profilePicImage);
                        board.appendChild(opponentProfilePic);
                    });
                } else {
                    const opponentData = await fetchOpponentData(opponentUsernameParam);
                    const opponentProfilePic = document.createElement("div");
                    Object.assign(opponentProfilePic.style, {
                        position:"absolute", left:"1960px", top:"70px",
                        width:"100px", height:"100px", zIndex:"100", overflow:"hidden"
                    });
                    const img = document.createElement("img");
                    img.src = `${serverUrl}/Public/Images/Profile Pictures/${opponentData.profilePic}`;
                    Object.assign(img.style, {
                        width:"100%", height:"100%", border:"6px solid black",
                        boxSizing:"border-box", objectFit:"cover"
                    });
                    opponentProfilePic.appendChild(img);
                    board.appendChild(opponentProfilePic);
                }
            });

            // After all elements like playerDeckBox and deckText are added
            fetchUserData().then(async userData => {
                if (userData && userData.deckSleeve) {
                    playerDeckBox.style.backgroundImage = `url(https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Sleeves/${userData.deckSleeve})`;
                    playerDeckBox.style.backgroundSize = "cover";
                    playerDeckBox.style.backgroundPosition = "center";
                    playerDeckBox.style.backgroundRepeat = "no-repeat";
                }
                if (isSinglePlayer) {
                    getRandomBotSleeve().then(sleeve => {
                        opponentDeckBox.style.backgroundImage = `url(https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Sleeves/${sleeve})`;
                        opponentDeckBox.style.backgroundSize = "cover";
                        opponentDeckBox.style.backgroundPosition = "center";
                        opponentDeckBox.style.backgroundRepeat = "no-repeat";
                    });
                } else {
                    const opponentData = await fetchOpponentData(opponentUsernameParam);
                    if (opponentData?.deckSleeve) {
                        opponentDeckBox.style.backgroundImage =
                        `url(${serverUrl}/Public/Images/Sleeves/${opponentData.deckSleeve})`;
                        opponentDeckBox.style.backgroundSize = "cover";
                        opponentDeckBox.style.backgroundPosition = "center";
                        opponentDeckBox.style.backgroundRepeat = "no-repeat";
                    }
                }
            });

            // Function to add a box
            function addBox(x, y, w, h, color="green", backColor="black", opa="0.5") {
                const box = document.createElement("div");
                    box.style.position = "absolute";
                    box.style.left = x;
                    box.style.top = y;
                    box.style.width = w;
                    box.style.height = h;
                    box.style.border = `4px solid ${color}`;
                    box.style.backgroundColor = `${backColor}`;
                    box.style.opacity = `${opa}`;
                    box.style.zIndex = "30";
                board.appendChild(box);
            }

            // Reproduce visual layout from image (values are approximate %)
            addBox("1%", "1%", "6%", "19%", "lightsalmon");     // Opponent Deck
            addBox("9%", "1%", "68%", "19%", "lightsalmon");    // Opponent Arsenal

            addBox("79%", "1%", "20%", "40%", "lightsalmon");   // Opponent Reserve

            addBox("1%", "22%", "6%", "19%", "lightsalmon");    // Opponent Tomb
            addBox("9%", "22%", "68%", "19%", "lightsalmon");   // Opponent Champions

            addBox("1%", "44%", "10%", "14%", "lightsalmon");    // Opponent Void

            addBox("14%", "47%", "72%", "7%", "lightgreen");    // Path
            //addBox("65.8%", "48%", "19.75%", "5%", "white","","1"); // Back of turn count, player turn

            addBox("89%", "44%", "10%", "14%", "lightblue");   // Player Void

            addBox("1%", "60%", "20%", "40%", "lightblue");   // Player Reserve

            addBox("23%", "60%", "68%", "19%", "lightblue");  // Player Champions
            addBox("93%", "60%", "6%", "19%", "lightblue");  // Player Tomb

            addBox("23%", "81%", "68%", "19%", "lightblue");  // Player Arsenal
            addBox("93%", "81%", "6%", "19%", "lightblue");  // Player Deck

            document.body.appendChild(overlay);
            document.body.appendChild(mainContainer);
            mainContainer.appendChild(board);

            // Function to fetch user data from the session
            async function fetchUserData() {
                try {
                    const res = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/me', {
                        credentials: 'include'
                    });
                    if (!res.ok) throw new Error('Response error');

                    const data = await res.json();
                    if (!data.loggedIn) return null;

                    if (data && data.deckSleeve) {
                        userSleeveURL = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Sleeves/${data.deckSleeve}`;
                    }

                    return data;
                } catch (err) {
                    console.error('Failed to fetch user data:', err);
                    return null;
                }
            }

            if (!playerDeckResult.success || !opponentDeckResult.success) {
                console.error("Deck fetch failed");
                return;
            }

            const playerDeck = playerDeckResult.card_ids;
            shuffleDeck(playerDeck);

            const opponentDeck = opponentDeckResult.card_ids;
            shuffleDeck(opponentDeck);

            const selectedTotem = params.get("totem");
            const selectedTotemText = params.get("totemText");

            const totemElement = document.createElement("p");
                totemElement.innerHTML = `${selectedTotem}`;
                totemElement.style.color = "goldenrod";
            const totemTextElement = document.createElement("p");
                totemTextElement.innerHTML = `<strong>Description:</strong> ${selectedTotemText}`;
            document.getElementById("game-log-placeholder").appendChild(totemElement);
            document.getElementById("game-log-placeholder").appendChild(totemTextElement);

            await getUsername();
            document.getElementById("player-name")  .textContent = playerUsernameParam;
            document.getElementById("opponent-name").textContent = opponentUsernameParam;
            //const totemSpan = document.getElementById("totem");
            //if (totemSpan) {
                //totemSpan.textContent = `${selectedTotem}: ${selectedTotemText}`;
            //}

            opponentName = opponentUsernameParam;
            const goesFirst = (turnOrderParam === "first") ? playerUsernameParam : opponentUsernameParam;

            if (playerDeckResult.success && opponentDeckResult.success) {
                if (gameType === "match" || username === rpsWinnerParam) {
                    await fetch('https://geimon-app-833627ba44e0.herokuapp.com/startGame', {
                        method: 'POST',
                        credentials: 'include',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            gameId,
                            playerUsername: username,
                            opponentUsername: isSinglePlayerParam ? "Bot" : opponentUsernameParam,
                            playerDeck: playerDeck,
                            opponentDeck: opponentDeck,
                            isSinglePlayer: isSinglePlayerParam,
                            goesFirst,
                            totem: selectedTotem
                        })
                    });
                }

                gameState = await waitForGameState();

                if (gameState[username].Hand.length === 0) {
                    for (let i = 0; i < 5; i++) {
                        if (!isRefresh) {
                            await drawCards(gameState[username].Deck, 1);
                        } else {
                            document.getElementById("viewing-window").style.opacity = "1";
                            document.getElementById("context-window").style.opacity = "1";
                            document.getElementById("player-life-window").style.opacity = "1";
                            document.getElementById("player-life").textContent = gameState[username].life;
                            document.getElementById("opponent-life-window").style.opacity = "1";
                            document.getElementById("opponent-life").textContent = gameState[opponentUsernameParam].life;
                            document.getElementById("phase-tracker").style.opacity = "1";
                            document.getElementById("turn-counter").style.opacity = "1";
                        }
                    }
                    await sendZoneUpdate(["Deck", "Hand"]);
                }
                document.getElementById("viewing-window").style.opacity = "1";
                document.getElementById("context-window").style.opacity = "1";
                document.getElementById("player-life-window").style.opacity = "1";
                document.getElementById("player-life").textContent = gameState[username].life;
                document.getElementById("opponent-life-window").style.opacity = "1";
                document.getElementById("opponent-life").textContent = gameState[opponentUsernameParam].life;
                document.getElementById("phase-tracker").style.opacity = "1";
                document.getElementById("turn-counter").style.opacity = "1";
                drawnCardsArray = gameState[username].Hand; // ✅ Set the global array
                previousHandIds = drawnCardsArray.map(card => card.id); // ✅ Track previous IDs
                await renderDrawnCards();
                if (!isRefresh) {
                    await showRedrawPrompt(); // Pause here and show redraw
                }
                hasDrawnInitialHand = true;

                updateDeckText();
                await updateLocalFromGameState();

                if (!intervalId) {
                intervalId = setInterval(async () => {
                    isFetchingGameState = true;
                    try {
                        await fetchGameStateFromServer();
                    } catch (error) {
                        console.error("Error fetching game state:", error);
                    } finally {
                        isFetchingGameState = false;
                    }
                }, 10000);
            }

            const totemBox = document.createElement("div");
                totemBox.style.position = "absolute";
                totemBox.style.top = "46%";
                totemBox.style.left = "53%";
                totemBox.style.transform = "translate(-50%, -50%)";
                totemBox.style.padding = "16px 32px";
                totemBox.style.backgroundColor = "goldenrod";
                totemBox.style.color = "white";
                totemBox.style.fontSize = "1.5em";
                totemBox.style.borderRadius = "10px";
                totemBox.style.textAlign = "center";
                totemBox.style.opacity = "0"; // Start invisible
                totemBox.style.transition = "opacity 1s ease-in-out";
                totemBox.style.zIndex = "150900";
                totemBox.style.boxShadow = "0 0 20px black";
                totemBox.textContent = `Selected Totem: ${selectedTotem} - ${selectedTotemText}`;

                // Add to document
                document.body.appendChild(totemBox);

                // Trigger fade-in
                setTimeout(() => {
                    if (!isRefresh) {
                        totemBox.style.opacity = "1";
                    }
                }, 1000); // Slight delay after result box

                setTimeout(() => {
                    totemBox.style.opacity = "0";
                    totemBox.style.zIndex = "10";
                    window.totemFullyFaded = true;
                }, 4000);

                document.getElementById("player-name").textContent = username;
                document.getElementById("player-life").textContent = gameState[username].life;

                opponentName = isSinglePlayer ? "Bot" : opponentUsernameParam;
                //console.log("Creating game for", username, "vs", isSinglePlayer ? "Bot" : opponentUsernameParam);
                document.getElementById("opponent-name").textContent = opponentUsernameParam;
                //console.log("Opponent Name: ", opponentUsernameParam);
                document.getElementById("opponent-life").textContent = gameState[opponentUsernameParam].life;
                //console.log("Opponent Life: ", gameState[opponentUsernameParam].life);

                if (!gameReady) {
                    await fetchGameStateFromServer();
                    gameReady = true;
                }
                if (!gameState || !gameState[username]) {
                    alert("Game could not be started.");
                    return;
                }
            } else {
                console.error("Deck loading failed:", playerDeckResult.message);
            }
        }

        async function fetchDeckCards(deckName, ownerUsername) {
            if (deckName === "Random") {
                // Generate a random deck locally
                const cardPool = cards.map(card => card.id); // Extract all IDs
                const deckSize = Math.floor(Math.random() * 41) + 60; // Random between 60–100
                const shuffled = cardPool.sort(() => 0.5 - Math.random());
                const card_ids = shuffled.slice(0, deckSize);

                deckCount = `${card_ids.length}`;
                if (playerDeckBox) {
                    //playerDeckBox.innerText = "Deck";
                }

                return { success: true, card_ids };
            }

            // Fallback to real server call for named decks
            try {
                const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                    method: "POST",
                    credentials: 'include',
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ deck_name: deckName, owner: ownerUsername })
                });

                const data = await response.json();

                if (data.success) {
                    deckCount = `${data.card_ids.length}`;
                    if (playerDeckBox) {
                        //playerDeckBox.innerText = "Deck";
                    }
                } else {
                    deckCount = data.message;
                }

                return data;
            } catch (error) {
                console.error("Error fetching deck cards:", error);
                return { success: false, message: 'Fetch error' };
            }
        }

    // Select the existing Player Deck box after it's created
    const playerDeckBox = document.createElement("div");
        playerDeckBox.id = "playerDeckBox";
        playerDeckBox.style.position = "absolute";
        playerDeckBox.style.left = "1759px";
        playerDeckBox.style.top = "676px";
        playerDeckBox.style.width = "82px";
        playerDeckBox.style.height = "126px";
        //playerDeckBox.style.backgroundColor = "lightblue";
        playerDeckBox.style.outline = "1px solid white"; // Bright white outline for debugging
        playerDeckBox.style.display = "block"; // Ensure it's always visible
        //playerDeckBox.style.zIndex = "1000"; // Bring it to the front layer
        playerDeckBox.style.opacity = "0"; // Start fully invisible
        playerDeckBox.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
        playerDeckBox.style.textAlign = "center"; // Ensures proper alignment
        playerDeckBox.style.fontWeight = "bold";
        playerDeckBox.style.fontSize = "1.2em";
        playerDeckBox.style.color = "white";
        playerDeckBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;
    document.body.appendChild(playerDeckBox); // Add to the document

    // Create the text span element separately
    const deckText = document.createElement("span");
        deckText.id = "deckText";
        deckText.textContent = "Deck";
        Object.assign(deckText.style, {
            position:      "absolute",
            left:          "50%",
            top:           "10%",
            transform:     "translate(-50%, -50%)",
            pointerEvents: "none",
        });
    playerDeckBox.appendChild(deckText);

    const opponentDeckBox = document.createElement("div");
        opponentDeckBox.id = "opponentDeckBox";
        opponentDeckBox.style.position = "absolute";
        opponentDeckBox.style.left = "375px";
        opponentDeckBox.style.top = "108px";
        opponentDeckBox.style.width = "82px";
        opponentDeckBox.style.height = "126px";
        opponentDeckBox.style.outline = "0px solid white";
        opponentDeckBox.style.display = "block";
        opponentDeckBox.style.zIndex = "1000";
        opponentDeckBox.style.opacity = "0";
        opponentDeckBox.style.outline = "1px solid white";
        opponentDeckBox.style.transition = "opacity 1s ease-in-out";
        opponentDeckBox.style.textAlign = "center";
        opponentDeckBox.style.fontWeight = "bold";
        opponentDeckBox.style.fontSize = "1.2em";
        opponentDeckBox.style.color = "white";
        opponentDeckBox.style.transform = "rotate(180deg)";
        opponentDeckBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

    const opponentDeckText = document.createElement("span");
        opponentDeckText.innerText = "Deck";
        opponentDeckText.style.position = "absolute";
        opponentDeckText.style.left = "50%";
        opponentDeckText.style.top = "92%";
        opponentDeckText.style.transform = "translate(-50%, -50%) rotate(180deg)";
    opponentDeckBox.appendChild(opponentDeckText);
    document.body.appendChild(opponentDeckBox);

    setTimeout(() => {
        opponentDeckBox.style.opacity = "1";
    }, 6500);

    //Start of Tomb Box Stuff
    const playerTombBox = document.createElement("div");
        playerTombBox.id = "playerTombBox";
        playerTombBox.style.position = "absolute";
        playerTombBox.style.left = "1762px";  // Same X as Deck
        playerTombBox.style.top = "532px";   // Directly above the Deck
        playerTombBox.style.width = "88px";
        playerTombBox.style.height = "126px";
        playerTombBox.style.outline = "none";//"4px solid white";
        playerTombBox.style.zIndex = "1000";
        //playerTombBox.style.backgroundColor = "rgba(255, 0, 0)";
        playerTombBox.style.opacity = "0";
        playerTombBox.style.transition = "opacity 1s ease-in-out";
        playerTombBox.style.textAlign = "center";
        playerTombBox.style.fontWeight = "bold";
        playerTombBox.style.fontSize = "1.2em";
        playerTombBox.style.color = "white";
        playerTombBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

        const tombText = document.createElement("span");
            tombText.innerText = "Tomb";
            tombText.style.position = "absolute";
            tombText.style.left = "43%";
            tombText.style.top = "2%";
            tombText.style.transform = "translate(-50%, -50%)";
        playerTombBox.appendChild(tombText);
        document.body.appendChild(playerTombBox);

        setTimeout(() => {
            playerTombBox.style.opacity = "1";
        }, 6500);

        function updateTombText() {
            if (gameState && gameState[username]) {
                const count = gameState[username].Tomb.length;
                tombText.innerText = `${count}`;
                tombText.style.position = "absolute";
                tombText.style.left = "43%";
                tombText.style.top = "2%";
                tombText.style.transform = "translate(-50%, -50%)";
            }
        }

        playerTombBox.addEventListener("mouseenter", updateTombText);
        playerTombBox.addEventListener("mouseleave", () => {
            tombText.innerText = "Tomb";
            tombText.style.position = "absolute";
            tombText.style.left = "45%";
            tombText.style.top = "2%";
            tombText.style.transform = "translate(-50%, -50%)";
        });

    // Create Tomb Button Overlay
    const tombButton = document.createElement("button");
        tombButton.style.position = "absolute";
        tombButton.style.left = "1758px";
        tombButton.style.top = "540px";
        tombButton.style.width = "85px";
        tombButton.style.height = "113px"; //addBox("93%", "60%", "6%", "19%", "lightblue");  // Player Tomb
        tombButton.style.backgroundColor = "rgba(0, 255, 0)";
        tombButton.style.opacity = "0";
        tombButton.style.border = "none";
        tombButton.style.zIndex = "110800";
        tombButton.style.cursor = "pointer";
        tombButton.title = "Tomb";

        // Add event listener for click
        tombButton.addEventListener("click", () => {
            const popup = document.createElement("div");
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.maxWidth = "min(90%, 800px)";
                popup.style.overflowY = "auto";
                popup.style.maxHeight = "unset";
                popup.style.height = "auto";
                popup.style.overflow = "visible";
                popup.style.padding = "10px 20px";
                popup.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
                popup.style.border = "3px solid white";
                popup.style.borderRadius = "12px";
                popup.style.zIndex = "120900";
                popup.style.display = "flex";
                popup.style.flexDirection = "column";
                popup.style.alignItems = "center";
                popup.style.gap = "20px";

            const title = document.createElement("div");
                title.textContent = "Tomb";
                title.style.color = "white";
                title.style.fontSize = "2em";
                title.style.textAlign = "center";
            popup.appendChild(title);

            const tombCards = gameState?.[username]?.Tomb || [];

            if (tombCards.length === 0) {
                const none = document.createElement("div");
                none.textContent = "Tomb is empty.";
                none.style.color = "white";
                popup.appendChild(none);
            } else {
                const cardContainer = document.createElement("div");
                    cardContainer.style.display = "flex";
                    cardContainer.style.flexWrap = "wrap";
                    cardContainer.style.justifyContent = "center";
                    cardContainer.style.gap = "10px";
                    cardContainer.style.marginRight = "10px";
                    cardContainer.style.maxWidth = "100%";
                    cardContainer.style.overflow = "visible";

                const scale = 0.3;
                const cardWidth = 240;
                const cardHeight = 420;

                tombCards.forEach(cardData => {
                    const card = cards.find(c => String(c.id) === String(cardData.id));
                    if (!card) return;

                    const scale = 0.3;
                    const scaledCard = renderCard(card);
                        scaledCard.style.transform = `scale(${scale})`;
                        scaledCard.style.transformOrigin = "top left";
                        scaledCard.style.margin = "5px";
                        scaledCard.style.position = "relative";
                    scaledCard.dataset.zone = "Tomb";
                    attachHoverMenu(scaledCard, cardData);

                    const wrapper = document.createElement("div");
                        wrapper.style.width = `${260 * scale}px`;
                        wrapper.style.height = `${400 * scale}px`;
                        wrapper.style.overflow = "visible";
                        wrapper.style.position = "relative";

                    // Tomb card click overlay
                    const overlay = document.createElement("button");
                        overlay.style.position = "absolute";
                        overlay.style.top = "0";
                        overlay.style.left = "0";
                        overlay.style.width = "100%";
                        overlay.style.height = "100%";
                        overlay.style.opacity = "0";
                        overlay.style.border = "none";
                        overlay.style.background = "transparent";
                        overlay.style.cursor = "pointer";
                    overlay.onclick = () => alert(`Card in Tomb Clicked: ${card.name}`);

                    wrapper.appendChild(scaledCard);
                    wrapper.appendChild(overlay);

                    // Hover preview
                    wrapper.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                            scaled.innerHTML = "";
                        const preview = renderCard(card);
                            preview.style.width = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop = "7%";
                        scaled.appendChild(preview);
                    });

                    cardContainer.appendChild(wrapper);
                });
                popup.appendChild(cardContainer);
            }

            const closeBtn = document.createElement("button");
                closeBtn.textContent = "Close";
                closeBtn.style.marginTop = "10px";
                closeBtn.style.padding = "10px 20px";
                closeBtn.style.fontSize = "1.2em";
                closeBtn.style.cursor = "pointer";
                closeBtn.style.zIndex = "120000";
            closeBtn.onclick = () => popup.remove();
            popup.appendChild(closeBtn);

            document.body.appendChild(popup);
    });

    document.body.appendChild(tombButton);
    //End of Tomb Creation Stuff

    //Start of Void Box Stuff
    const playerVoidBox = document.createElement("div");
        playerVoidBox.id = "playerVoidBox";
        playerVoidBox.style.position = "absolute";
        playerVoidBox.style.left = "1697px";  // Same X as Deck
        playerVoidBox.style.top = "415px";   // Directly above the Deck
        playerVoidBox.style.width = "147px";
        playerVoidBox.style.height = "90px";
        playerVoidBox.style.outline = "none";//"4px solid white";
        playerVoidBox.style.zIndex = "1000";
        //playerVoidBox.style.backgroundColor = "rgba(255, 0, 0)";
        playerVoidBox.style.opacity = "0";
        playerVoidBox.style.transition = "opacity 1s ease-in-out";
        playerVoidBox.style.textAlign = "center";
        playerVoidBox.style.fontWeight = "bold";
        playerVoidBox.style.fontSize = "1.2em";
        playerVoidBox.style.color = "white";
        playerVoidBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

        const voidText = document.createElement("span");
            voidText.innerText = "Void";
            voidText.style.position = "absolute";
            voidText.style.left = "50%";
            voidText.style.top = "5%";
            voidText.style.transform = "translate(-50%, -50%)";

        playerVoidBox.appendChild(voidText);
        document.body.appendChild(playerVoidBox);

        setTimeout(() => {
            playerVoidBox.style.opacity = "1";
        }, 6500);

        function updateVoidText() {
            if (gameState && gameState[username]) {
                const count = gameState[username].Void.length;
                voidText.innerText = `${count}`;
            }
        }

        playerVoidBox.addEventListener("mouseenter", updateVoidText);
        playerVoidBox.addEventListener("mouseleave", () => {
            voidText.innerText = "Void";
        });

    // Create Void Button Overlay
    const voidButton = document.createElement("button");
        voidButton.style.position = "absolute";
        voidButton.style.left = "1697px";
        voidButton.style.top = "425px";
        voidButton.style.width = "149px";
        voidButton.style.height = "80px"; //addBox("89%", "44%", "10%", "14%", "lightblue");   // Player Void
        voidButton.style.backgroundColor = "rgba(255, 0, 0)";
        voidButton.style.opacity = "0";
        voidButton.style.border = "none";
        voidButton.style.zIndex = "100800";
        voidButton.style.cursor = "pointer";
        voidButton.title = "Void";

        // Add event listener for click
        voidButton.addEventListener("click", () => {
            const popup = document.createElement("div");
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.maxWidth = "min(90%, 800px)";
                popup.style.overflowY = "auto";
                popup.style.maxHeight = "unset";
                popup.style.height = "auto";
                popup.style.overflow = "visible";
                popup.style.padding = "10px 20px";
                popup.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
                popup.style.border = "3px solid white";
                popup.style.borderRadius = "12px";
                popup.style.zIndex = "120900";
                popup.style.display = "flex";
                popup.style.flexDirection = "column";
                popup.style.alignItems = "center";
                popup.style.gap = "20px";

            const title = document.createElement("div");
                title.textContent = "Void";
                title.style.color = "white";
                title.style.fontSize = "2em";
                title.style.textAlign = "center";
            popup.appendChild(title);

            const voidCards = gameState?.[username]?.Void || [];

            if (voidCards.length === 0) {
                const none = document.createElement("div");
                none.textContent = "Void is empty.";
                none.style.color = "white";
                popup.appendChild(none);
            } else {
                const cardContainer = document.createElement("div");
                    cardContainer.style.display = "flex";
                    cardContainer.style.flexWrap = "wrap";
                    cardContainer.style.justifyContent = "center";
                    cardContainer.style.gap = "10px";
                    cardContainer.style.marginRight = "19px";
                    cardContainer.style.maxWidth = "100%";
                    cardContainer.style.overflow = "visible";

                const scale = 0.3;
                const cardWidth = 240;
                const cardHeight = 420;

                voidCards.forEach(cardData => {
                    const card = cards.find(c => String(c.id) === String(cardData.id));
                    if (!card) return;

                    const scale = 0.3;
                    const scaledCard = renderCard(card);
                        scaledCard.style.transform = `scale(${scale})`;
                        scaledCard.style.transformOrigin = "top left";
                        scaledCard.style.margin = "5px";
                        scaledCard.style.position = "relative";
                    scaledCard.dataset.zone = "Void";
                    attachHoverMenu(scaledCard, cardData);

                    const wrapper = document.createElement("div");
                        wrapper.style.width = `${240 * scale}px`;
                        wrapper.style.height = `${420 * scale}px`;
                        wrapper.style.overflow = "visible";
                        wrapper.style.position = "relative";

                    // Void card click overlay
                    const overlay = document.createElement("button");
                        overlay.style.position = "absolute";
                        overlay.style.top = "0";
                        overlay.style.left = "0";
                        overlay.style.width = "100%";
                        overlay.style.height = "100%";
                        overlay.style.opacity = "0";
                        overlay.style.border = "none";
                        overlay.style.background = "transparent";
                        overlay.style.cursor = "pointer";
                    overlay.onclick = () => alert(`Card in Void Clicked: ${card.name}`);

                    wrapper.appendChild(scaledCard);
                    wrapper.appendChild(overlay);

                    // Hover preview
                    wrapper.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                            scaled.innerHTML = "";
                        const preview = renderCard(card);
                            preview.style.width = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop = "7%";
                        scaled.appendChild(preview);
                    });

                    cardContainer.appendChild(wrapper);
                });
                popup.appendChild(cardContainer);
            }

            const closeBtn = document.createElement("button");
                closeBtn.textContent = "Close";
                closeBtn.style.marginTop = "10px";
                closeBtn.style.padding = "10px 20px";
                closeBtn.style.fontSize = "1.2em";
                closeBtn.style.cursor = "pointer";
                closeBtn.style.zIndex = "120000";
            closeBtn.onclick = () => popup.remove();
            popup.appendChild(closeBtn);

            document.body.appendChild(popup);
    });

    document.body.appendChild(voidButton);
    //End of Void Stack Creation

    //Start of Opponent Tomb Box Stuff
    const opponentTombBox = document.createElement("div");
        opponentTombBox.id = "opponentTombBox";
        opponentTombBox.style.position = "absolute";
        opponentTombBox.style.left = "372px";  // Same X as Deck
        opponentTombBox.style.top = "260px";   // Directly above the Deck
        opponentTombBox.style.width = "88px";
        opponentTombBox.style.height = "126px";
        opponentTombBox.style.outline = "none";//"4px solid white";
        opponentTombBox.style.zIndex = "1000";
        //opponentTombBox.style.backgroundColor = "rgba(255, 0, 0)";
        opponentTombBox.style.opacity = "0";
        opponentTombBox.style.transition = "opacity 1s ease-in-out";
        opponentTombBox.style.textAlign = "center";
        opponentTombBox.style.fontWeight = "bold";
        opponentTombBox.style.fontSize = "1.2em";
        opponentTombBox.style.color = "white";
        opponentTombBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

        const opponentTombText = document.createElement("span");
            opponentTombText.innerText = "Tomb";
            opponentTombText.style.position = "absolute";
            opponentTombText.style.zIndex = "110500";
            opponentTombText.style.left = "50%";
            opponentTombText.style.top = "2%";
            opponentTombText.style.transform = "translate(-50%, -50%)";
        opponentTombBox.appendChild(opponentTombText);
        document.body.appendChild(opponentTombBox);

        setTimeout(() => {
            opponentTombBox.style.opacity = "1";
        }, 6500);

        function updateOpponentTombText() {
            if (gameState && gameState[opponentName]) {
                const count = gameState[opponentName].Tomb.length;
                opponentTombText.innerText = `${count}`;
                opponentTombText.style.position = "absolute";
                opponentTombText.style.zIndex = "110500";
                opponentTombText.style.left = "50%";
                opponentTombText.style.top = "2%";
                opponentTombText.style.transform = "translate(-50%, -50%)";
            }
        }

        opponentTombBox.addEventListener("mouseenter", updateOpponentTombText);
        opponentTombBox.addEventListener("mouseleave", () => {
            opponentTombText.innerText = "Tomb";
            opponentTombText.style.position = "absolute";
            opponentTombText.style.zIndex = "110500";
            opponentTombText.style.left = "50%";
            opponentTombText.style.top = "2%";
            opponentTombText.style.transform = "translate(-50%, -50%)";
        });

    // Create Tomb Button Overlay
    const opponentTombButton = document.createElement("button");
        opponentTombButton.style.position = "absolute";
        opponentTombButton.style.left = "380px";
        opponentTombButton.style.top = "290px";
        opponentTombButton.style.width = "71px";
        opponentTombButton.style.height = "95px";
        opponentTombButton.style.backgroundColor = "rgba(0, 255, 0)";
        opponentTombButton.style.opacity = "0";
        opponentTombButton.style.border = "none";
        opponentTombButton.style.zIndex = "100800";
        opponentTombButton.style.cursor = "pointer";
        opponentTombButton.title = "Tomb";

        // Add event listener for click
        opponentTombButton.addEventListener("click", () => {
            const popup = document.createElement("div");
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.maxWidth = "min(90%, 800px)";
                popup.style.overflowY = "auto";
                popup.style.maxHeight = "unset";
                popup.style.height = "auto";
                popup.style.overflow = "visible";
                popup.style.padding = "10px 20px";
                popup.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
                popup.style.border = "3px solid white";
                popup.style.borderRadius = "12px";
                popup.style.zIndex = "120900";
                popup.style.display = "flex";
                popup.style.flexDirection = "column";
                popup.style.alignItems = "center";
                popup.style.gap = "20px";

            const title = document.createElement("div");
                title.textContent = "Opponent's Tomb";
                title.style.color = "white";
                title.style.fontSize = "2em";
                title.style.textAlign = "center";
            popup.appendChild(title);

            const tombCards = gameState?.[opponentName]?.Tomb || [];

            if (tombCards.length === 0) {
                const none = document.createElement("div");
                none.textContent = "Opponent's Tomb is empty.";
                none.style.color = "white";
                popup.appendChild(none);
            } else {
                const cardContainer = document.createElement("div");
                    cardContainer.style.display = "flex";
                    cardContainer.style.flexWrap = "wrap";
                    cardContainer.style.justifyContent = "center";
                    cardContainer.style.gap = "10px";
                    cardContainer.style.marginRight = "10px";
                    cardContainer.style.maxWidth = "100%";
                    cardContainer.style.overflow = "visible";

                const scale = 0.3;
                const cardWidth = 240;
                const cardHeight = 420;

                tombCards.forEach(cardData => {
                    const card = cards.find(c => String(c.id) === String(cardData.id));
                    if (!card) return;

                    const scale = 0.3;
                    const scaledCard = renderCard(card);
                        scaledCard.style.transform = `scale(${scale})`;
                        scaledCard.style.transformOrigin = "top left";
                        scaledCard.style.margin = "5px";
                        scaledCard.style.position = "relative";
                    scaledCard.dataset.zone = "Tomb";
                    attachHoverMenu(scaledCard, cardData);

                    const wrapper = document.createElement("div");
                        wrapper.style.width = `${260 * scale}px`;
                        wrapper.style.height = `${400 * scale}px`;
                        wrapper.style.overflow = "visible";
                        wrapper.style.position = "relative";

                    // Tomb card click overlay
                    const overlay = document.createElement("button");
                        overlay.style.position = "absolute";
                        overlay.style.top = "0";
                        overlay.style.left = "0";
                        overlay.style.width = "100%";
                        overlay.style.height = "100%";
                        overlay.style.opacity = "0";
                        overlay.style.border = "none";
                        overlay.style.background = "transparent";
                        overlay.style.cursor = "pointer";
                    overlay.onclick = () => alert(`Card in Tomb Clicked: ${card.name}`);

                    wrapper.appendChild(scaledCard);
                    wrapper.appendChild(overlay);

                    // Hover preview
                    wrapper.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                            scaled.innerHTML = "";
                        const preview = renderCard(card);
                            preview.style.width = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop = "7%";
                        scaled.appendChild(preview);
                    });

                    cardContainer.appendChild(wrapper);
                });
                popup.appendChild(cardContainer);
            }

            const closeBtn = document.createElement("button");
                closeBtn.textContent = "Close";
                closeBtn.style.marginTop = "10px";
                closeBtn.style.padding = "10px 20px";
                closeBtn.style.fontSize = "1.2em";
                closeBtn.style.cursor = "pointer";
                closeBtn.style.zIndex = "120000";
            closeBtn.onclick = () => popup.remove();
            popup.appendChild(closeBtn);

            document.body.appendChild(popup);
    });

    document.body.appendChild(opponentTombButton);
    //End of Opponent Tomb Creation Stuff

    //Start of Opponent Void Box Stuff
    const opponentVoidBox = document.createElement("div");
        opponentVoidBox.id = "opponentVoidBox";
        opponentVoidBox.style.position = "absolute";
        opponentVoidBox.style.left = "372px";  // Same X as Deck
        opponentVoidBox.style.top = "415px";   // Directly above the Deck
        opponentVoidBox.style.width = "147px";
        opponentVoidBox.style.height = "90px";
        opponentVoidBox.style.outline = "none";//"4px solid white";
        opponentVoidBox.style.zIndex = "1000";
        //opponentVoidBox.style.backgroundColor = "rgba(255, 0, 0)";
        opponentVoidBox.style.opacity = "0";
        opponentVoidBox.style.transition = "opacity 1s ease-in-out";
        opponentVoidBox.style.textAlign = "center";
        opponentVoidBox.style.fontWeight = "bold";
        opponentVoidBox.style.fontSize = "1.2em";
        opponentVoidBox.style.color = "white";
        opponentVoidBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

        const opponentVoidText = document.createElement("span");
            opponentVoidText.innerText = "Void";
            opponentVoidText.style.position = "absolute";
            opponentVoidText.style.zIndex = "110000";
            opponentVoidText.style.left = "50%";
            opponentVoidText.style.top = "5%";
            opponentVoidText.style.transform = "translate(-50%, -50%)";

        opponentVoidBox.appendChild(opponentVoidText);
        document.body.appendChild(opponentVoidBox);

        setTimeout(() => {
            opponentVoidBox.style.opacity = "1";
        }, 6500);

        function updateOpponentVoidText() {
            if (gameState && gameState[opponentName]) {
                const count = gameState[opponentName].Void.length;
                opponentVoidText.innerText = `${count}`;
                opponentVoidText.style.zIndex = "110000";
            }
        }

        opponentVoidBox.addEventListener("mouseenter", updateOpponentVoidText);
        opponentVoidBox.addEventListener("mouseleave", () => {
            opponentVoidText.innerText = "Void";
            opponentVoidText.style.zIndex = "110000";
        });

    // Create Void Button Overlay
    const opponentVoidButton = document.createElement("button");
        opponentVoidButton.style.position = "absolute";
        opponentVoidButton.style.left = "372px";
        opponentVoidButton.style.top = "425px";
        opponentVoidButton.style.width = "148px";
        opponentVoidButton.style.height = "81px";
        opponentVoidButton.style.backgroundColor = "rgba(255, 0, 0)";
        opponentVoidButton.style.opacity = "0";
        opponentVoidButton.style.border = "none";
        opponentVoidButton.style.zIndex = "100800";
        opponentVoidButton.style.cursor = "pointer";
        opponentVoidButton.title = "Void";

        // Add event listener for click
        opponentVoidButton.addEventListener("click", () => {
            const popup = document.createElement("div");
                popup.style.position = "fixed";
                popup.style.top = "50%";
                popup.style.left = "50%";
                popup.style.transform = "translate(-50%, -50%)";
                popup.style.maxWidth = "min(90%, 800px)";
                popup.style.overflowY = "auto";
                popup.style.maxHeight = "unset";
                popup.style.height = "auto";
                popup.style.overflow = "visible";
                popup.style.padding = "10px 20px";
                popup.style.backgroundColor = "rgba(0, 0, 0, 0.85)";
                popup.style.border = "3px solid white";
                popup.style.borderRadius = "12px";
                popup.style.zIndex = "120900";
                popup.style.display = "flex";
                popup.style.flexDirection = "column";
                popup.style.alignItems = "center";
                popup.style.gap = "20px";

            const title = document.createElement("div");
                title.textContent = "Opponent's Void";
                title.style.color = "white";
                title.style.fontSize = "2em";
                title.style.textAlign = "center";
            popup.appendChild(title);

            const voidCards = gameState?.[opponentName]?.Void || [];

            if (voidCards.length === 0) {
                const none = document.createElement("div");
                none.textContent = "Opponent's Void is empty.";
                none.style.color = "white";
                popup.appendChild(none);
            } else {
                const cardContainer = document.createElement("div");
                    cardContainer.style.display = "flex";
                    cardContainer.style.flexWrap = "wrap";
                    cardContainer.style.justifyContent = "center";
                    cardContainer.style.gap = "10px";
                    cardContainer.style.marginRight = "10px";
                    cardContainer.style.maxWidth = "100%";
                    cardContainer.style.overflow = "visible";

                const scale = 0.3;
                const cardWidth = 240;
                const cardHeight = 420;

                voidCards.forEach(cardData => {
                    const card = cards.find(c => String(c.id) === String(cardData.id));
                    if (!card) return;

                    const scale = 0.3;
                    const scaledCard = renderCard(card);
                        scaledCard.style.transform = `scale(${scale})`;
                        scaledCard.style.transformOrigin = "top left";
                        scaledCard.style.margin = "5px";
                        scaledCard.style.position = "relative";
                    scaledCard.dataset.zone = "Void";
                    //attachHoverMenu(scaledCard, cardData);
                    attachTargetOverlay(scaledCard, cardData);

                    const wrapper = document.createElement("div");
                        wrapper.style.width = `${240 * scale}px`;
                        wrapper.style.height = `${420 * scale}px`;
                        wrapper.style.overflow = "visible";
                        wrapper.style.position = "relative";

                    // Void card click overlay
                    const overlay = document.createElement("button");
                        overlay.style.position = "absolute";
                        overlay.style.top = "0";
                        overlay.style.left = "0";
                        overlay.style.width = "100%";
                        overlay.style.height = "100%";
                        overlay.style.opacity = "0";
                        overlay.style.border = "none";
                        overlay.style.background = "transparent";
                        overlay.style.cursor = "pointer";
                    overlay.onclick = () => alert(`Card in Void Clicked: ${card.name}`);

                    wrapper.appendChild(scaledCard);
                    wrapper.appendChild(overlay);

                    // Hover preview
                    wrapper.addEventListener("mouseenter", () => {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                            scaled.innerHTML = "";
                        const preview = renderCard(card);
                            preview.style.width = "240px";
                            preview.style.height = "420px";
                            preview.style.transform = "scale(1.2)";
                            preview.style.marginLeft = "-15%";
                            preview.style.marginTop = "7%";
                        scaled.appendChild(preview);
                    });

                    cardContainer.appendChild(wrapper);
                });
                popup.appendChild(cardContainer);
            }

            const closeBtn = document.createElement("button");
                closeBtn.textContent = "Close";
                closeBtn.style.marginTop = "10px";
                closeBtn.style.padding = "10px 20px";
                closeBtn.style.fontSize = "1.2em";
                closeBtn.style.cursor = "pointer";
                closeBtn.style.zIndex = "120000";
            closeBtn.onclick = () => popup.remove();
            popup.appendChild(closeBtn);

            document.body.appendChild(popup);
    });

    document.body.appendChild(opponentVoidButton);
    //End of Opponent Void Stack Creation

    // Opponent zones
    const oppChampionBox = document.getElementById("opponentChampionsBox");
        oppChampionBox.style.position       = "fixed";
        oppChampionBox.style.left           = "1033px";
        oppChampionBox.style.top            = "255px";
        oppChampionBox.style.width          = "525px";
        oppChampionBox.style.height         = "128px";
        oppChampionBox.style.zIndex         = "100300";
        oppChampionBox.style.pointerEvents  = "none";
        oppChampionBox.style.backgroundColor= "rgba(255,0,0,0)";
        oppChampionBox.style.display        = "flex";
        oppChampionBox.style.justifyContent = "flex-end";
        oppChampionBox.style.alignItems     = "center";
        oppChampionBox.style.transform      = "none";
        oppChampionBox.style.gap            = "0px";
        oppChampionBox.style.flexWrap       = "nowrap";

    const overlapCSS = document.createElement('style');
        overlapCSS.innerHTML = `
        #opponentChampionsBox .card {
            flex-shrink: 0 !important;
            margin-left: -152.5px !important;
        }
        `;
    document.head.appendChild(overlapCSS);

    const oppFaceDownBox = document.getElementById("opponentFaceDownBox");
        oppFaceDownBox.className = "card-zone";
        oppFaceDownBox.style.position = "fixed";
        oppFaceDownBox.style.left     = "651px";
        oppFaceDownBox.style.top      = "458px";
        oppFaceDownBox.style.width    = "470px";
        oppFaceDownBox.style.height   = "128px";
        oppFaceDownBox.style.zIndex   = "100300";
        oppFaceDownBox.style.pointerEvents = "none";
        oppFaceDownBox.style.backgroundColor = "rgba(0,255,0,0)";
        oppFaceDownBox.style.display        = "flex";
        oppFaceDownBox.style.justifyContent = "flex-start";
        oppFaceDownBox.style.alignItems     = "center";
        oppFaceDownBox.style.transform      = "none";
        oppFaceDownBox.style.gap            = "0px";
        oppFaceDownBox.style.flexWrap       = "nowrap";

    const oppArsenalBox = document.getElementById("opponentArsenalBox");
        oppArsenalBox.style.position = "fixed";
        oppArsenalBox.style.left     = "1033px";
        oppArsenalBox.style.top      = "107px";
        oppArsenalBox.style.width    = "525px";
        oppArsenalBox.style.height   = "128px";
        oppArsenalBox.style.zIndex   = "100300";
        oppArsenalBox.style.pointerEvents = "none";
        oppArsenalBox.style.backgroundColor = "rgba(0,0,255,0)";
        oppArsenalBox.style.display        = "flex";
        oppArsenalBox.style.justifyContent = "flex-end";
        oppArsenalBox.style.alignItems     = "center";
        oppArsenalBox.style.transform      = "none";
        oppArsenalBox.style.gap            = "0px";
        oppArsenalBox.style.flexWrap       = "nowrap";

    const overlapArsenalCSS = document.createElement('style');
        overlapArsenalCSS.innerHTML = `
        #opponentArsenalBox .card {
            flex-shrink: 0 !important;
            margin-left: -150px !important;
            transform: rotate(180deg) scale(1) !important;
            transform-origin: center center !important;
        }
        `;
    document.head.appendChild(overlapArsenalCSS);

    const oppFaceDownArsenalBox = document.getElementById("opponentFaceDownArsenalBox");
        oppFaceDownArsenalBox.className = "card-zone";
        oppFaceDownArsenalBox.style.position = "fixed";
        oppFaceDownArsenalBox.style.left     = "612px";
        oppFaceDownArsenalBox.style.top      = "390px";
        oppFaceDownArsenalBox.style.width    = "565px";
        oppFaceDownArsenalBox.style.height   = "128px";
        oppFaceDownArsenalBox.style.zIndex   = "100300";
        oppFaceDownArsenalBox.style.pointerEvents = "none";
        oppFaceDownArsenalBox.style.backgroundColor = "rgba(255,255,0,0)";
        oppFaceDownArsenalBox.style.display        = "flex";
        oppFaceDownArsenalBox.style.justifyContent = "flex-start";
        oppFaceDownArsenalBox.style.alignItems     = "center";
        oppFaceDownArsenalBox.style.transform      = "none";
        oppFaceDownArsenalBox.style.gap            = "0px";
        oppFaceDownArsenalBox.style.flexWrap       = "nowrap";

    const oppReserveBox = document.getElementById("opponentReserveBox");
        oppReserveBox.className = "card-zone";
        oppReserveBox.style.position = "absolute";
        oppReserveBox.style.left = "1593.5px";
        oppReserveBox.style.top = "-30px";
        oppReserveBox.style.width = "310px";
        oppReserveBox.style.height = "275px";
        oppReserveBox.style.zIndex = "100900";
        oppReserveBox.style.pointerEvents = "auto";
        oppReserveBox.style.backgroundColor = "rgba(255, 0, 0, 0)";
        oppReserveBox.style.display        = "flex";
        oppReserveBox.style.justifyContent = "flex-end";
        oppReserveBox.style.alignItems     = "center";
        oppReserveBox.style.gap            = "0px";
    // End of opponent field stuff

    // Create Surrender Button Overlay
    const surrenderButton = document.createElement("button");
        surrenderButton.style.position = "absolute";
        surrenderButton.style.left = "1758px";
        surrenderButton.style.top = "690px";
        surrenderButton.style.width = "85px";
        surrenderButton.style.height = "113px";//addBox("93%", "81%", "6%", "19%", "lightblue");  // Player Deck
        surrenderButton.style.backgroundColor = "rgba(255, 0, 0)";
        surrenderButton.style.opacity = "0";
        surrenderButton.style.border = "none";
        surrenderButton.style.zIndex = "200100";
        surrenderButton.style.cursor = "pointer";
        surrenderButton.title = "Surrender";

    const toolButtons = document.getElementById("tool-buttons");
    const lifeAdjustBox = document.getElementById("life-adjust-box");
    setTimeout(() => {
        toolButtons.style.opacity = "1";
        muteBtn.style.opacity = "1";
        lifeAdjustBox.style.opacity = "1";
        playerDeckBox.style.opacity = "1";
        playerDeckBox.style.zIndex = "200000";
        playerDeckBox.style.pointerEvents = "auto";
        attachDeckHoverMenu();
    }, 6500);
    let deckCount = "Deck";

        // Ensure it exists before adding event listeners
        if (opponentDeckBox) {
            opponentDeckBox.style.display = "block";
            opponentDeckBox.style.outline = "1px solid white";
            //opponentDeckBox.style.position = "relative"; // ensure positioning context

            // Create or reuse the inner rotated span
            let textSpan = opponentDeckBox.querySelector(".rotated-text");
            if (!textSpan) {
                textSpan = document.createElement("span");
                textSpan.className = "rotated-text";
                textSpan.innerText = "Deck";

                // Styling for top-aligned, centered, rotated text
                textSpan.style.position = "absolute";
                textSpan.style.top = "100%";
                textSpan.style.left = "50%";
                textSpan.style.transform = "translateX(-50%) rotate(180deg)";
                textSpan.style.transformOrigin = "top center";
                textSpan.style.width = "100%";
                textSpan.style.textAlign = "center";
                textSpan.style.pointerEvents = "none"; // optional: avoid blocking hover

                opponentDeckBox.innerHTML = ""; // clear anything inside
                opponentDeckBox.appendChild(textSpan);
            }

            opponentDeckBox.addEventListener("mouseenter", () => {
                const opponentName = gameState.player1 === username ? gameState.player2 : gameState.player1;
                const opponentDeck = gameState?.[opponentName]?.Deck || [];
                textSpan.innerText = `${opponentDeck.length}`;
            });

            opponentDeckBox.addEventListener("mouseleave", () => {
                textSpan.innerText = "Deck";
            });
        }

        async function getDeckFromParam(paramName) {
            const urlParams = new URLSearchParams(window.location.search);
            const playerUsernameParam   = urlParams.get("playerUsername")    || username;
            const opponentUsernameParam = urlParams.get("opponentUsername")  || (isSinglePlayer ? "Bot" : username);
            const paramValue = urlParams.get(paramName);

            // 1) If the param is already a JSON array of IDs, use it directly
            try {
                const parsed = JSON.parse(paramValue);
                if (Array.isArray(parsed)) {
                    return parsed;
                }
            } catch (e) {
            // not JSON → continue to fetch by name
            }

            // 2) Decide whose deck we’re fetching
            const isOpponent = paramName === "opponentDeck";
            const owner      = isOpponent ? opponentUsernameParam : playerUsernameParam;

            // 3) Fetch from the server, passing the owner
            try {
                const data = await fetchDeckCards(paramValue, owner);
                if (data.success && Array.isArray(data.card_ids)) {
                    return data.card_ids;
                } else {
                    console.error(`Deck fetch failed for '${paramName}':`, data.message);
                    return [];
                }
            } catch (err) {
                console.error(`Failed to load deck '${paramName}':`, err.message);
                return [];
            }
        }

        let remainingDeck = []; // Store shuffled deck globally
        let drawnCardsArray = []; // Track drawn cards separately
        let initialDeckSize = 0; // Store starting deck size globally
        Object.defineProperty(window, 'gameState', {
            configurable: true,
            enumerable: true,
            get() {
                return window._gameState;
            },
            set(value) {
                //console.trace("🧠 gameState updated:", value);
                if (value === undefined) {
                    console.warn("⚠️ gameState was set to undefined!");
                }
                window._gameState = value;
            }
        });

        // Initialize to empty object or null to avoid undefined errors
        window._gameState = {};


        // Function to update deck text dynamically
        function updateDeckText() {
            if (deckText) {
                deckText.innerText = `Deck`; // Correct dynamic update
            }
        }

        // Function to shuffle the deck using Fisher-Yates algorithm
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        const CHAMPION_ZONE = "Zone (Champion)";
        const FACEDOWN_ZONE = "FaceDownZone";

        const ARSENAL_ZONE = "Zone (Arsenal)";
        const FACEDOWN_ARSENAL_ZONE = "FaceDownArsenalZone";

        async function renderDrawnCards() {
            if (renderingHand) return; // ✅ prevent double render
                renderingHand = true;

            try {
                const drawnCardsContainer = document.getElementById("drawn-cards");
                const scaledCardContainer = document.getElementById("scaled-card");
                const viewingWindow = document.getElementById("viewing-window");
                const contextWindow = document.getElementById("context-window");
                const playerLifeWindow = document.getElementById("player-life-window");
                const opponentLifeWindow = document.getElementById("opponent-life-window");
                const playerProfilePic = document.getElementById("player-profile-pic");
                const opponentProfilePic = document.getElementById("opponent-profile-pic");
                const phaseTracker = document.getElementById("phase-tracker");
                const turnCounter = document.getElementById("turn-counter");
                const currentPhase = gameState?.turn?.currentPhase;

                drawnCardsContainer.innerHTML = ""; // Clear previous renders

                if (drawnCardsArray.length === 0) {
                    //console.log("No cards have been drawn yet.");
                    return;
                }
                //console.log("drawnCardsArray length:", drawnCardsArray.length);

                // Sort drawn cards (optional, as you had)
                drawnCardsArray.sort((a, b) => {
                    const cardA = cards.find(c => String(c.id) === String(a.id));
                    const cardB = cards.find(c => String(c.id) === String(b.id));
                    if (!cardA || !cardB) return 0;

                    const typeOrder = ["Champion", "Action", "Equipment", "Obelisk", "Rush", "Reflex"];
                    const indexA = typeOrder.indexOf(cardA.type);
                    const indexB = typeOrder.indexOf(cardB.type);

                    if (indexA !== indexB) return indexA - indexB;
                    return cardA.name.localeCompare(cardB.name);
                });

                // --- Now render each drawn card ---
                for (const cardObj of drawnCardsArray) {
                    const scale = Math.min(window.innerWidth/1920, window.innerHeight/1080, 1);
                    const overlap = MIN_OVERLAP + (MAX_OVERLAP - MIN_OVERLAP) * scale;
                    const card = cards.find(c => String(c.id) === String(cardObj.id));
                    if (!card) return;

                    const cardElement = renderCard(card);
                    cardElement.dataset.boardState = cardObj.boardState;
                    cardElement.dataset.lastBoardState = cardObj.lastBoardState;
                    cardElement.dataset.cardId = String(card.id); // Ensure this is set for lookup!
                    cardElement.style.transform = "scale(0.5)";
                    cardElement.style.position = "relative";
                    cardElement.style.marginLeft = `${-overlap}%`;
                    cardElement.style.opacity = "1";
                    cardElement.style.transition = "opacity 1s ease-in-out";

                    // Invisible button to capture clicks
                    const cardButton = document.createElement("button");
                    cardButton.classList.add("card-button");
                    cardButton.style.position = "absolute";
                    cardButton.style.top = "0";
                    cardButton.style.right = "0";
                    cardButton.style.width = "100%";
                    cardButton.style.height = "100%";
                    cardButton.style.opacity = "0";
                    cardButton.style.background = "transparent";
                    cardButton.style.border = "none";
                    cardButton.style.pointerEvents = "auto";
                    cardButton.style.padding = "5px";
                    cardButton.style.zIndex = "100100";
                    cardButton.style.cursor = "pointer";

                    cardButton.onclick = () => {
                        const parentCard = cardButton.closest(".card");
                        const cardId = parentCard?.dataset.cardId;

                        if (!cardId) {
                            console.warn("❌ No cardId found on clicked card");
                            return;
                        }

                        const fullCard = cards.find(c => String(c.id) === String(cardId));
                        if (!fullCard) {
                            console.warn("❌ Card not found in cards array:", cardId);
                            return;
                        }
                    };

                    cardButton._originalHandler = cardButton.onclick;

                    // Hover effect for preview
                    cardElement.addEventListener("mouseenter", () => {
                        scaledCardContainer.innerHTML = "";
                        const clone = cardElement.cloneNode(true);
                        clone.querySelectorAll('.sleeve-overlay, .card-button, .target-overlay').forEach(el => el.remove());
                        clone.removeAttribute('data-card-id');
                        clone.style.transform = "scale(1.2)";
                        clone.style.width = "100%";
                        clone.style.position = "relative";
                        scaledCardContainer.appendChild(clone);
                        addTooltipListeners(clone);
                        addTokenTooltipListeners(clone);
                    });

                    cardElement.appendChild(cardButton);
                    drawnCardsContainer.appendChild(cardElement);
                    if (cardObj.counters) {
                        updateCounterOverlay(cardElement, cardObj);
                    }
                    if (cardObj.damage !== undefined || cardObj.damageThreshold !== undefined) {
                        refreshCardFace(cardElement, cardObj);
                    }
                    cardElement.dataset.zone     = cardObj.boardState;
                    cardElement.dataset.facedown = (cardObj.boardState.includes("FaceDown") || card.faceDown) ? "true" : "false";
                    attachHoverMenu(cardElement, card);

                    const fullCard = cards.find(c => String(c.id) === String(card.id));

                    // Fade in after render
                    setTimeout(() => {
                        cardElement.style.opacity = "1";
                        cardButton.style.opacity = "1";
                        cardButton.style.cursor = "pointer";
                    }, 1500);
                }
                updateHandSpacing();

                // Fade in UI overlays
                if (window.totemFullyFaded && !window.totemFadeDoneEmitted) {
                    window.totemFadeDoneEmitted = true; // prevent multiple emits
                    setTimeout(() => {
                        viewingWindow.style.opacity = "1";
                        contextWindow.style.opacity = "1";
                        playerLifeWindow.style.opacity = "1";
                        opponentLifeWindow.style.opacity = "1";
                        phaseTracker.style.opacity = "1";
                        turnCounter.style.opacity = "1";
                    }, 0);
                    socket.emit("totem_fade_done", { gameId });
                }
            } finally {
                renderingHand = false;
            }
            applyHoverMenus();
        }

        async function updatePhaseDisplay(currentPhase) {
            const turnCount = gameState?.turn?.count || 0;
            const currentPlayer = gameState?.turn?.currentPlayer;
            const isPlayerTurn = currentPlayer === username;

            // Define valid transitions
            const allowedTransitions = {
                "Intermission": ["Draw"],
                "Draw": ["Main 1"],
                "Main 1": ["Battle", "End"],
                "Battle": ["Main 2"],
                "Main 2": ["End"]
            };

            document.querySelectorAll('.phase-box').forEach(box => {
                const phase = box.textContent.trim();
                box.classList.remove('active');
                if (turnCount === 1 && (phase === "Battle" || phase === "Main 2")) {
                    box.style.backgroundColor = "darkred";
                    box.style.cursor = "not-allowed";
                    return;
                }
                if (!isPlayerTurn) {
                    box.style.cursor = "not-allowed";
                    box.style.backgroundColor = "dimgray";
                    return;
                }
                const validNextPhases = allowedTransitions[currentPhase] || [];
                if (validNextPhases.includes(phase)) {
                    box.style.cursor = "pointer";
                    box.style.backgroundColor = "lightgray";
                } else {
                    box.style.cursor = "not-allowed";
                    box.style.backgroundColor = "dimgray";
                }
            });

            const activeBox = document.getElementById(`phase-${currentPhase}`);
            if (activeBox) {
                activeBox.classList.add('active');
                activeBox.style.backgroundColor = "lightgreen";
            }

            const turnNum = gameState.turn?.count;

            if (
                currentPhase === "Intermission" &&
                isPlayerTurn &&
                turnNum !== lastLoggedIntermissionTurn
            ) {
                addGameLogEntry(`${username}'s turn. Turn #${turnNum}`);
                addGameLogEntry(`${username} changed phase to Intermission`);
            }
        }

        async function sendZoneSpecificUpdate({ owner, zone, cards }) {
            const updatedZones = { [zone]: cards };

            const res = await fetch(`${serverUrl}/updateGameState`, {
                method: "POST",
                credentials: "include",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ gameId, owner, updatedZones })
            });

            const data = await res.json();
            if (data.updatedPlayerZone) gameState[owner] = data.updatedPlayerZone;
            return data;
        }

        async function sendZoneUpdate(zones) {
            const updatedZones = {};
            zones.forEach(z => updatedZones[z] = gameState[username][z]);
            //console.log("🔧 sendZoneUpdate ▶ payload:", updatedZones);

            const res = await fetch(`${serverUrl}/updateGameState`, {
                method: "POST",
                credentials: "include",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ gameId, owner: username, updatedZones })
            });

            const data = await res.json();
            //console.log("📜 sendZoneUpdate ◀ response:", data);

            // merge server copy back into local
            if (data.updatedPlayerZone) {
                gameState[username] = data.updatedPlayerZone;
                //console.log("🔄 state synced → Arsenal:", gameState[username]["Zone (Arsenal)"].map(c=>c.id), "Tomb:", gameState[username].Tomb.map(c=>c.id));
            }

            return data;
        }

        function updateCounterOverlay(cardElement, cardData) {
            // 1️⃣  normalise the backing number
            if (typeof cardData.counters !== "number") cardData.counters = 0;

            // 2️⃣  find or create the overlay badge
            let badge = cardElement.querySelector(".counter-overlay");
            if (!badge && cardData.counters > 0) {
                badge = document.createElement("div");
                badge.className = "counter-overlay";
                Object.assign(badge.style, {
                    position:       "absolute",
                    top:            "50%",
                    left:           "50%",
                    transform:      "translate(-50%, -50%)",
                    width:          "64px",
                    height:         "64px",
                    borderRadius:   "50%",
                    background:     "#000",
                    color:          "#fff",
                    fontSize:       "2.6em",
                    fontWeight:     "600",
                    display:        "flex",
                    alignItems:     "center",
                    justifyContent: "center",
                    pointerEvents:  "none",
                    zIndex:         "125000"
                });
                cardElement.appendChild(badge);
            }

            // 3️⃣  update or remove it
            if (badge) {
                if (cardData.counters > 0) {
                    badge.textContent = cardData.counters;
                } else {
                    badge.remove();
                }
            }
        }

        async function refreshCardFace(cardEl, card) {
            const dmg  = cardEl.querySelector(".damage");
            const life = cardEl.querySelector(".life");
            let thr = cardEl.querySelector(".damageThreshold");
            if (!thr) {
                thr = document.createElement("div");
                thr.className = "damageThreshold";
                const bottomBar = cardEl.querySelector(".bottom-bar");
                if (bottomBar) {
                    bottomBar.appendChild(thr);
                } else {
                    //console.warn("No .bottom-bar on this card, skipping threshold badge");
                }
            }

            if (dmg)  dmg.textContent  = card.damage;
            if (life) life.textContent = card.life;
            thr.textContent = card.damageThreshold;   // card.threshold if you renamed it
        }
        window.refreshCardFace = refreshCardFace;

        /* show a small modal, update cardData + DOM on “Save” */
        async function showChangeStatsPrompt(cardElement, cardData) {
            // ── overlay ─────────────────────────────────────────────────
            const overlay = document.createElement("div");
            Object.assign(overlay.style, {
                position: "fixed", inset: 0, background: "rgba(0,0,0,.6)",
                display: "flex", alignItems: "center", justifyContent: "center",
                zIndex: 200000
            });

            // ── popup panel ─────────────────────────────────────────────
            const panel = document.createElement("div");
            panel.style.cssText =
                "background:#222;color:#fff;padding:20px 24px;border-radius:8px;" +
                "box-shadow:0 0 10px #000;font-size:18px;width:260px;text-align:center";

            panel.innerHTML = `
                <h3 style="margin-top:0;font-size:1.1em">Change Stats</h3>
                <label>Damage<br>
                <input id="dmg" type="number" min="0" step="1"
                        style="width:70px" value="${cardData.damage}">
                </label><br><br>
                <label>Life<br>
                <input id="life" type="number" min="0" step="1"
                        style="width:70px" value="${cardData.life}">
                </label><br><br>
                <label>Threshold<br>
                <input id="th" type="number" min="0" step="1"
                        style="width:70px" value="${cardData.damageThreshold}">
                </label><br><br>
                <button id="saveStats" style="margin-right:10px">Save</button>
                <button id="cancelStats">Cancel</button>
            `;
            overlay.appendChild(panel);
            document.body.appendChild(overlay);

            // ── button wiring ───────────────────────────────────────────
            panel.querySelector("#saveStats").onclick = async () => {
                playSoundEffect('tomb');
                cardData.damage           = +panel.querySelector("#dmg").value || 0;
                cardData.life             = +panel.querySelector("#life").value || 0;
                cardData.damageThreshold  = +panel.querySelector("#th").value || 0;

                refreshCardFace(cardElement, cardData);

                const zoneName = cardData.boardState;
                const zoneArray = gameState[username][zoneName];
                const index = zoneArray.findIndex(c => String(c.id) === String(cardData.id));
                if (index !== -1) {
                    zoneArray[index] = cardData;
                }

                await sendZoneUpdate([ zoneName ]);
                addGameLogEntry(
                    `${cardData.name}'s stats set to ` +
                    `${cardData.damage}/${cardData.life} (${cardData.damageThreshold}).`);
                overlay.remove();
            };
            panel.querySelector("#cancelStats").onclick = () => overlay.remove();
        }

        function getOpponentUsername(username, gameState) {
            return Object.keys(gameState).find(name => name !== username);
        }

        async function animateBlock(cardElement, isFaceDown = false) {
            // 1) Capture the existing transform (rotate/scale) so we can re-apply it
            const cs = getComputedStyle(cardElement).transform;
            const originalTransform = cs === 'none' ? '' : cs;

            // 2) Compute how far the card’s center is from the viewport center
            const rect   = cardElement.getBoundingClientRect();
            const deltaX = window.innerWidth  / 2 - (rect.left + rect.width  / 2);
            const deltaY = window.innerHeight / 2 - (rect.top  + rect.height / 2);

            // 3) Detect opponent’s face-down blockers in the proper container
            const isOppFaceDown = isFaceDown && !!cardElement.closest('#opponentFaceDownBox');

            if (isOppFaceDown) {
                // ── Opponent face-down: translate in screen coords BEFORE re-applying rotate/scale ──
                cardElement.style.transformOrigin = 'top center';

                // move first (screen-space), then re-apply the original (rotate/scale)
                const move   = `translate(${1*deltaX}px, ${1*deltaY}px)`;
                const target = `${move} ${originalTransform}`;

                cardElement.style.transition = 'transform 0.3s ease-in-out';
                cardElement.style.setProperty(
                    'transform',
                    target,
                    'important'
                );
                await new Promise(r => setTimeout(r, 400));

                // move back to original
                cardElement.style.transform = originalTransform;
                await new Promise(r => setTimeout(r, 400));
                cardElement.style.transition = '';

            } else {
                const inOppChampBox = !!cardElement.closest('#opponentChampionsBox');
                // ── All other cases (your player or any face-up blocks) use existing logic ─────────
                const move   = isFaceDown
                    ? `translate(${-deltaY}px, ${2 * deltaX}px)`
                    : inOppChampBox
                        ? `translate(${deltaX * -5}px, ${deltaY * -3}px)`
                        : `translate(${deltaX * 5}px, ${deltaY * 3}px)`;
                const rotate = isFaceDown ? '' : ' rotate(90deg)';
                const target = `${originalTransform} ${move}${rotate}`.trim();

                cardElement.style.transition = 'transform 0.3s ease-in-out';
                cardElement.style.transform  = target;
                await new Promise(r => setTimeout(r, 400));

                cardElement.style.transform = originalTransform;
                await new Promise(r => setTimeout(r, 400));
                cardElement.style.transition = '';
            }
        }

        /**
         * Turn the TOP of the card to face the viewport center,
         * move it straight in, then return—while preserving ANY existing transforms.
         */
        function animateAttackToCenter(cardEl, duration = 800) {
            // 1) Remember any inline transform you’d set before
            const origInline = cardEl.style.transform || '';

            // 2) Grab the true “start” matrix (including CSS rules, scale, etc.)
            const cs = getComputedStyle(cardEl).transform;
            const startMatrix = (cs === 'none') ? '' : cs;

            // 3) Figure out where “center of viewport” is relative to the card’s center
            const r  = cardEl.getBoundingClientRect();
            const cx = r.left + r.width  / 2;
            const cy = r.top  + r.height / 2;
            const vx = window.innerWidth  / 2;
            const vy = window.innerHeight / 2;
            const dx = vx - cx;
            const dy = vy - cy;

            // ── OPTION 2: opponent’s champion attack animation ─────────────────────────────
            const inOppChampBox = !!cardEl.closest('#opponentChampionsBox');
            if (inOppChampBox) {
                const drop = 100;
                // a) Move straight down (towards vertical center), then b) diagonally into center
                const kfOpp = [
                    { transform: startMatrix },
                    { transform: `translateY(${drop}px) rotate(15deg) ${startMatrix}` },
                    { transform: `translate(${dx}px, ${drop}px) rotate(15deg) ${startMatrix}` },
                    { transform: startMatrix }
                ];

                const animOpp = cardEl.animate(kfOpp, {
                    duration,
                    easing: 'ease-in-out',
                    fill: 'forwards'
                });

                animOpp.finished.then(() => {
                    // restore any inline transform you had before
                    cardEl.style.transform = origInline;
                });

                return animOpp;
            }

            // ── DEFAULT: your existing pivot + rotate + center animation ────────────────────

            // 4) Compute the angle so the TOP edge points at (dx,dy)
            const angle = Math.atan2(dy, dx) * 180/Math.PI + 90;

            // 5) Build our “pivot” translations
            const px = r.width  / 2;  // bottom-center X in local coords
            const py = r.height;      // bottom-center Y
            const toPivot   = `translate(${ px * 20 }px, ${ -px * 10 }px)`;
            const fromPivot = `translate(${-px }px, ${-py }px)`;

            // 6) Keyframes: start → tilt only → tilt+move → back
            const kf = [
                { transform: startMatrix },
                { transform: `${startMatrix} ${toPivot} rotate(${angle}deg) ${fromPivot}` },
                { transform: `${startMatrix} ${toPivot} rotate(${angle}deg) ${fromPivot} translate(${dx}px, ${dy}px)` },
                { transform: startMatrix }
            ];

            // 7) Fire it with the Web Animations API
            const anim = cardEl.animate(kf, {
                duration,
                easing:   'ease-in-out',
                fill:     'forwards'
            });

            // 8) When done, restore your original inline transform
            anim.finished.then(() => {
                cardEl.style.transform = origInline;
            });

            return anim;
        }

        function findCardOwnerAndZone(cardId) {
            for (const [player, zones] of Object.entries(gameState)) {
                for (const [zoneName, cards] of Object.entries(zones)) {
                    if (Array.isArray(cards)) {
                        const found = cards.find(c => String(c.id) === String(cardId));
                        if (found) return { owner: player, zoneName };
                    }
                }
            }
            return null;
        }

        async function attachHoverMenu(cardElement, cardData) {
            let ownerInfo = findCardOwnerAndZone(cardData.id);
            const isOppToken = ownerInfo?.owner !== username
                            && cardData.tags?.includes("Token");
              if (isOppToken) {
                attachTargetOverlay(cardElement, cardData);
                return;
            }

            const inOppTombOrVoid =
                !!cardElement.closest('#opponentTombBox') ||
                !!cardElement.closest('#opponentVoidBox');

            if (cardElement.closest('#viewing-window') ||
                cardElement.closest('.scaled-card')) {
                return;
            }

            if (cardElement.dataset.hoverMenuAttached) return;

            cardElement.dataset.hoverMenuAttached = "true";
            cardElement.style.position = "relative";

            let hideTimer;
            let hoverMenu;

            function showMenu() {
                clearTimeout(hideTimer);
                cardElement.style.zIndex = "120000";
                cardElement.style.outline = "4px solid yellow";
                if (zone === "Zone (Champion)" || zone === "Deck") {
                    hoverMenu.style.display = "grid";
                }
                else {
                    hoverMenu.style.display = "flex";
                }

                if (isFaceDown) {
                    // do your preview here
                    const real = cards.find(c => String(c.id) === String(cardData.id));
                    if (real) {
                        const scaled = document.querySelector("#viewing-window .scaled-card");
                        scaled.innerHTML = "";
                        const preview = renderCard(real);
                        Object.assign(preview.style,{
                            width:"240px", height:"420px", transform:"scale(1.2)",
                            marginLeft:"-15%", marginTop:"7%"
                        });
                        scaled.appendChild(preview);
                    }
                }

                // force initial state
                void hoverMenu.offsetWidth;
                if (isFaceDown) {
                    hoverMenu.style.transform = "translateX(0) translateY(-50%) rotate(90deg)";
                    hoverMenu.style.opacity   = "1";
                } else {
                    hoverMenu.style.transform = "translate(-50%, 0)";
                    hoverMenu.style.opacity   = "1";
                }
            }

            // 5) hide menu
            function hideMenu() {
                if (isFaceDown) {
                    hoverMenu.style.transform = "translateX(-10px) translateY(-50%) rotate(90deg)";
                } else {
                    hoverMenu.style.transform = "translate(-50%, 10px)";
                }
                hoverMenu.style.opacity = "0";
                setTimeout(() => {
                    hoverMenu.style.display   = "none";
                    cardElement.style.zIndex  = "";
                    cardElement.style.outline = "";
                }, 150);
            }

            if (!cardElement.closest('#viewing-window')) {
                const targetOverlay = document.createElement('div');
                targetOverlay.classList.add('target-overlay');
                Object.assign(targetOverlay.style, {
                    position:   'absolute',
                    top:        '0',
                    left:       '0',
                    width:      '100%',
                    height:     '100%',
                    background: 'transparent',
                    cursor:     'pointer',
                    zIndex:     '220000'
                });
                // forward hover to show/hide your menu
                if (!inOppTombOrVoid) {
                    targetOverlay.addEventListener('mouseenter', showMenu);
                    targetOverlay.addEventListener('mouseleave', () => hideTimer = setTimeout(hideMenu, 150));
                }
                // handle “target” clicks
                targetOverlay.addEventListener('click', e => {
                    e.stopPropagation();
                    //flashTargetRing(cardData.id);
                    socket.emit('toggle_target', { gameId, cardId: cardData.id });
                });
                cardElement.appendChild(targetOverlay);
            }

            // ─── helper to move card in state + UI + server ───────────────────────────
            async function doMove(fromZone, toZoneKey, containerId, faceDown, placeOnTop = false) {
                // 0) Update local gameState arrays
                const zoneArr = gameState[username][fromZone];
                const idx     = zoneArr.findIndex(c => String(c.id) === String(cardData.id));
                if (idx < 0) return;
                const [moved] = zoneArr.splice(idx, 1);
                moved.boardState = toZoneKey;
                moved.faceDown   = faceDown;
                const targetArr = gameState[username][toZoneKey];
                if (toZoneKey === "Deck" && placeOnTop) {
                    targetArr.unshift(moved);
                } else {
                    targetArr.push(moved);
                }

                const container = document.getElementById(containerId);
                if (toZoneKey !== "Deck") {
                    const container = document.getElementById(containerId);
                    if (toZoneKey === "Deck" && placeOnTop) {
                        container.prepend(cardElement);
                    } else {
                        container.appendChild(cardElement);
                    }
                }
                cardElement.dataset.zone     = toZoneKey;
                cardElement.dataset.facedown = faceDown ? "true" : "false";

                const oldMenu = cardElement.querySelector(".hover-menu");
                if (oldMenu) oldMenu.remove();               // throw away the Hand menu
                delete cardElement.dataset.hoverMenuAttached; // let attachHoverMenu run again
                attachHoverMenu(cardElement, moved);         // moved == card’s live data object

                // 2) Apply visual transforms
                //    always shrink
                const transforms = ["scale(0.3)"];
                if (
                    !faceDown ||               // we’re no longer face-down
                    (containerId !== "playerFaceDownBox" &&
                    containerId !== "playerFaceDownArsenalBox")
                ) {
                    const straySleeve = cardElement.querySelector(".sleeve-overlay");
                    if (straySleeve) straySleeve.remove();
                }
                //    if facedown-champion, also rotate + sleeve overlay
                if (containerId === "playerFaceDownBox") {
                    transforms.push("rotate(90deg)");

                    // remove any previous sleeve overlay
                    const oldSleeve = cardElement.querySelector(".sleeve-overlay");
                    if (oldSleeve) oldSleeve.remove();

                    // add one sleeve overlay
                    const sleeve = document.createElement("img");
                    sleeve.src       = userSleeveURL;
                    sleeve.className = "sleeve-overlay";
                    Object.assign(sleeve.style, {
                        position:        "absolute",
                        top:             "0",
                        left:            "0",
                        width:           "260px",
                        height:          "420px",
                        transform:       "rotate(180deg)",
                        transformOrigin: "center center",
                        pointerEvents:   "none",
                        zIndex:          "110000",
                    });
                    cardElement.appendChild(sleeve);
                } if (containerId === "playerFaceDownArsenalBox") {
                    const oldSleeve = cardElement.querySelector(".sleeve-overlay");
                    if (oldSleeve) oldSleeve.remove();

                    // add one sleeve overlay
                    const sleeve = document.createElement("img");
                    sleeve.src       = userSleeveURL;
                    sleeve.className = "sleeve-overlay";
                    Object.assign(sleeve.style, {
                        position:        "absolute",
                        top:             "0",
                        left:            "0",
                        width:           "260px",
                        height:          "420px",
                        transformOrigin: "center center",
                        pointerEvents:   "none",
                        zIndex:          "110000",
                    });
                    cardElement.appendChild(sleeve);
                } if (containerId === "playerReserveBox") {
                    transforms.push("scale(0.3)");
                }

                cardElement.style.transform       = transforms.join(" ");
                cardElement.style.transformOrigin = "center center";
                cardElement.style.marginLeft = "";

                // 3) Persist change to server
                await sendZoneUpdate([fromZone, toZoneKey]);
                const mainZones = [
                  { name: "Zone (Champion)",         container: "playerChampionsBox"       },
                  { name: "FaceDownZone",            container: "playerFaceDownBox"        },
                  { name: "Zone (Arsenal)",          container: "playerArsenalBox"         },
                  { name: "FaceDownArsenalZone",     container: "playerFaceDownArsenalBox" },
                  { name: "Reserve",                 container: "playerReserveBox"         },
                ];
                mainZones.forEach(({ name, container }) => {
                  if (fromZone === name || toZoneKey === name) {
                    renderCardZone(gameState[username][name], container);
                  }
                });

                // 4) Re-render zones so spacing/layout updates
                renderDrawnCards();
                renderLatestTombCard();
                renderLatestVoidCard();
            }
            // ────────────────────────────────────────────────────────────────────────────

            const zone = cardElement.dataset.zone;
            const isFaceDown = (zone === "FaceDownZone");

            if (!inOppTombOrVoid) {
                // build the hover menu
                hoverMenu = document.createElement("div");
                hoverMenu.className = "hover-menu";
                Object.assign(hoverMenu.style, {
                    position:       "absolute",
                    transform:      "translateX(-50%) scale(1)",
                    marginBottom:   "0em",
                    backgroundColor:"#111",
                    color:          "white",
                    border:         "6px solid yellow",
                    padding:        "6px",
                    display:        "none",
                    zIndex:         "550000",
                    flexDirection:  "column",
                    fontSize:       "2em",
                    whiteSpace:     "nowrap",
                    boxShadow:      "0 0 5px black",

                    // position + transform: choose based on face-down
                    bottom:   isFaceDown ? ""       : "100%",
                    left:     isFaceDown ? ""       : "50%",
                    top:      isFaceDown ? "50%"    : "",
                    right:    isFaceDown ? "-200%"   : "",
                    transform: isFaceDown
                        ? "translateY(-50%) scale(1) rotate(90deg)"
                        : "translateX(-50%) scale(1)",
                    marginBottom:   "0em",
                });

                ownerInfo = findCardOwnerAndZone(cardData.id);

                if (ownerInfo?.owner !== username && (zone === "Tomb" || zone === "Void")) {
                    return;
                }

                let opts = [];

                if (cardData.tags?.includes("Token")) {
                    opts = [
                        "Change Control",
                        "Add 1 Counter",
                        "Remove 1 Counter",
                        "Change Stats",
                        "Declare",
                        "Attack",
                        "Block",
                        "Remove"
                    ];
                } else {
                    if (zone === "Hand") {
                        opts = [
                        "Change Control","Reveal","Declare",
                        "To Champion (Face-Up)","To Champion (Face-Down)",
                        "To Arsenal (Face-Up)","To Arsenal (Face-Down)",
                        "To Reserve","To Tomb","To Void",
                        "To Top of Deck","To Bottom of Deck"
                        ];
                    } else if (zone === "Tomb" || zone === "Void") {
                        hoverMenu.style.fontSize = "3em";
                        opts = [
                            zone === "Tomb" ? "To Void" : "To Tomb",
                            "To Hand",
                            "To Top of Deck",
                            "To Bottom of Deck",
                            "To Reserve",
                            "To Champion (Face-Up)",
                            "To Champion (Face-Down)",
                            "To Arsenal (Face-Up)",
                            "To Arsenal (Face-Down)",
                            "Declare"
                        ];
                    } else if (zone === "Deck") {
                        hoverMenu.style.fontSize = "3em";
                        hoverMenu.style.gridTemplateColumns = "repeat(2,max-content)";
                        hoverMenu.style.gridGap = "4px 8px";
                        hoverMenu.style.justifyContent = "center";
                        hoverMenu.style.flexDirection = "";
                        hoverMenu.style.columnCount = "";
                        hoverMenu.style.bottom = "90%";
                        opts = [
                            "To Hand",
                            "To Tomb",
                            "To Void",
                            "To Top of Deck",
                            "To Bottom of Deck",
                            "To Reserve",
                            "To Champion (Face-Up)",
                            "To Champion (Face-Down)",
                            "To Arsenal (Face-Up)",
                            "To Arsenal (Face-Down)"
                        ];
                    } else if (zone === "Zone (Champion)") {
                        hoverMenu.style.fontSize = "3em";
                        hoverMenu.style.gridTemplateColumns = "repeat(2,max-content)";
                        hoverMenu.style.gridGap = "4px 8px";
                        hoverMenu.style.justifyContent = "center";
                        hoverMenu.style.flexDirection = "";
                        hoverMenu.style.columnCount = "";
                        hoverMenu.style.bottom = "90%";
                        opts = [
                            "Change Control",
                            "Add 1 Counter",
                            //"Add 5 Counters",
                            "To Tomb",
                            "Remove 1 Counter",
                            "To Void",
                            //"Remove All Counters",
                            "To Hand",
                            "To Top of Deck",
                            "To Bottom of Deck",
                            "To Reserve",
                            "To Champion (Face-Down)",
                            "To Arsenal (Face-Up)",
                            "To Arsenal (Face-Down)",
                            "Change Stats",
                            "Declare",
                            "Attack",
                            "Block"
                        ];
                    } else if (zone === "Zone (Arsenal)") {
                        hoverMenu.style.fontSize = "3.5em";
                        opts = [
                            "Change Control",
                            "Add 1 Counter",
                            "Add 5 Counters",
                            "Remove 1 Counter",
                            "Remove All Counters",
                            "To Hand",
                            "To Tomb",
                            "To Void",
                            "To Top of Deck",
                            "To Bottom of Deck",
                            "To Reserve",
                            "To Champion (Face-Up)",
                            "To Champion (Face-Down)",
                            "To Arsenal (Face-Down)",
                            "Declare"
                        ];
                        const hasAttachment = attachments.some(a => a.sourceId === cardData.id);
                        if (hasAttachment) {
                            opts.unshift("Remove Attachment");
                        } else {
                            opts.unshift("Attach / Mount");
                        }
                    } else if (zone === "Reserve") {
                        hoverMenu.style.fontSize = "3.5em";
                        opts = [
                            "Change Control",
                            "Add 1 Counter",
                            "Add 5 Counters",
                            "Remove 1 Counter",
                            "Remove All Counters",
                            "To Hand",
                            "To Tomb",
                            "To Void",
                            "To Top of Deck",
                            "To Bottom of Deck",
                            "To Champion (Face-Up)",
                            "To Champion (Face-Down)",
                            "To Arsenal (Face-Up)",
                            "To Arsenal (Face-Down)",
                            "Declare"
                        ];
                    } else if (zone === "FaceDownZone") {
                        hoverMenu.style.fontSize = "3.5em";
                        opts = [
                            "Change Control",
                            "To Hand",
                            "To Tomb",
                            "To Void",
                            "To Top of Deck",
                            "To Bottom of Deck",
                            "To Reserve",
                            "To Champion (Face-Up)",
                            "To Arsenal (Face-Up)",
                            "To Arsenal (Face-Down)",
                            "Block"
                        ];
                    } else if (zone === "FaceDownArsenalZone") {
                        hoverMenu.style.fontSize = "3.5em";
                        opts = [
                            "Change Control",
                            "To Hand",
                            "To Tomb",
                            "To Void",
                            "To Top of Deck",
                            "To Bottom of Deck",
                            "To Reserve",
                            "To Champion (Face-Up)",
                            "To Champion (Face-Down)",
                            "To Arsenal (Face-Up)"
                        ];
                    }
                }

                // populate buttons
                opts.forEach(text => {
                    const btn = document.createElement("div");
                    btn.textContent = text;
                    Object.assign(btn.style, { padding:"2px 5px", cursor:"pointer" });
                    btn.addEventListener("click", async e => {
                    e.stopPropagation();
                    hoverMenu.style.display = "none";
                    switch (text) {
                        case "To Champion (Face-Up)":
                            playSoundEffect('activate');
                            await doMove(zone,           "Zone (Champion)",         "playerChampionsBox",        false);
                            //addGameLogEntry(`${username} rallied ${cardData.name}.`);
                            break;
                        case "To Champion (Face-Down)":
                            playSoundEffect('set');
                            await doMove(zone,           "FaceDownZone",            "playerFaceDownBox",         true);
                            break;
                        case "To Arsenal (Face-Up)":
                            playSoundEffect('activate');
                            await doMove(zone,           "Zone (Arsenal)",          "playerArsenalBox",          false);
                            break;
                        case "To Arsenal (Face-Down)":
                            playSoundEffect('set');
                            await doMove(zone,           "FaceDownArsenalZone",     "playerFaceDownArsenalBox",  true);
                            break;
                        case "To Reserve":
                            playSoundEffect('reserve');
                            await doMove(zone, "Reserve", "playerReserveBox", false);
                            break;
                        case "To Hand":
                            playSoundEffect('draw');
                            await doMove(zone, "Hand", "drawn-cards", false);
                            break;
                        case "To Tomb":
                            playSoundEffect('tomb');
                            await doMove(zone, "Tomb", "playerTombBox", false);
                            break;
                        case "To Void":
                            playSoundEffect('tomb');
                            await doMove(zone, "Void", "playerVoidBox", false);
                            break;
                        case "To Top of Deck":
                            playSoundEffect('set');
                            await doMove(zone, "Deck", "playerDeckBox", false, true);
                            break;
                        case "To Bottom of Deck":
                            playSoundEffect('set');
                            await doMove(zone, "Deck", "playerDeckBox", false, false);
                            break;
                        case "Declare":
                            playSoundEffect('declare');
                            // play the glow‐flash locally
                            flashDeclareEffect(cardElement);

                            // log & broadcast so your opponent sees it too
                            addGameLogEntry(`${cardData.name}'s effect was declared from the ${zone}.`);
                            socket.emit('declare_event', { gameId, cardId: cardData.id });
                            if (zone === "Hand") {
                                socket.emit('temp_reveal_card', { gameId, from: username, cardId: cardData.id });
                            }
                            break;
                        case "Reveal":
                            playSoundEffect('set');
                            addGameLogEntry(`${cardData.name} was revealed from the ${zone}.`);
                            if (zone === "Hand") {
                                socket.emit('temp_reveal_card', { gameId, from: username, cardId: cardData.id });
                            }
                            break;
                        case "Change Stats":
                            showChangeStatsPrompt(cardElement, cardData);
                            break;
                        case "Change Control": {
                            playSoundEffect('set');
                            const opponent = getOpponentUsername(username, gameState);

                            /* 1️⃣  Tell the server to transfer ownership */
                            socket.emit("change_control", {
                                gameId,
                                cardId: cardData.id,
                                from:   username,          // current owner
                                to:     opponent,          // new owner
                                zone:   zone               // e.g. "FaceDownZone"
                            });

                            /* 2️⃣  Log immediately; the re-render comes back via sync event */
                            addGameLogEntry(`${cardData.name} changed control to the opponent.`);
                            break;
                        }
                        case "Attack": {
                            playSoundEffect('attack');
                            animateAttackToCenter(cardElement, 800)
                                .finished.then(() => {
                                // 1) Log locally and broadcast to room
                                addGameLogEntry(`${cardData.name} declared an attack.`);
                                socket.emit('attack_event', { gameId, cardId: cardData.id });
                                });
                            break;
                        }
                        case "Block": {
                            playSoundEffect('block');
                            const isFaceDown = cardData.boardState === 'FaceDownZone';
                            animateBlock(cardElement, isFaceDown)
                                .then(() => {
                                addGameLogEntry(`${cardData.name} was declared as a blocker.`);
                                socket.emit('block_event', { gameId, cardId: cardData.id, isFaceDown });
                                });
                            break;
                        }
                        case "Add 1 Counter": {
                            playSoundEffect('tomb');

                            const cardId = cardData.id;
                            const info = findCardOwnerAndZone(cardId);
                            if (!info) break;
                            const { owner, zoneName } = info;

                            const zone = gameState[owner][zoneName];
                            const cardIndex = zone.findIndex(c => String(c.id) === String(cardId));

                            let card = cardData;
                            if (cardIndex !== -1) {
                                card = zone[cardIndex];
                                card.counters = (card.counters || 0) + 1;
                            }

                            updateCounterOverlay(cardElement, card);
                            const name = card.name || `Card ${card.id}`;
                            addGameLogEntry(`${name} gains 1 counter (now ${card.counters}).`);

                            zone[cardIndex] = card; // make sure the updated card is in the zone array
                            await sendZoneSpecificUpdate({ owner, zone: zoneName, cards: zone });
                            break;
                        }
                        case "Add 5 Counters": {
                            playSoundEffect('tomb');

                            const cardId = cardData.id;
                            const info = findCardOwnerAndZone(cardId);
                            if (!info) break;
                            const { owner, zoneName } = info;

                            const zone = gameState[owner][zoneName];
                            const cardIndex = zone.findIndex(c => String(c.id) === String(cardId));

                            let card = cardData;
                            if (cardIndex !== -1) {
                                card = zone[cardIndex];
                                card.counters = (card.counters || 0) + 5;
                            }

                            updateCounterOverlay(cardElement, card);
                            const name = card.name || `Card ${card.id}`;
                            addGameLogEntry(`${name} gains 5 counters (now ${card.counters}).`);

                            zone[cardIndex] = card; // make sure the updated card is in the zone array
                            await sendZoneSpecificUpdate({ owner, zone: zoneName, cards: zone });
                            break;
                        }
                        case "Remove 1 Counter": {
                            playSoundEffect('tomb');

                            const cardId = cardData.id;
                            const info = findCardOwnerAndZone(cardId);
                            if (!info) break;
                            const { owner, zoneName } = info;

                            const zone = gameState[owner][zoneName];
                            const cardIndex = zone.findIndex(c => String(c.id) === String(cardId));

                            let card = cardData;
                            if (cardIndex !== -1) {
                                card = zone[cardIndex];
                                card.counters = Math.max(0, (card.counters || 0) - 1);
                            }

                            updateCounterOverlay(cardElement, card);
                            const name = card.name || `Card ${card.id}`;
                            addGameLogEntry(`${name} loses 1 counter (now ${card.counters}).`);

                            zone[cardIndex] = card; // make sure the updated card is in the zone array
                            await sendZoneSpecificUpdate({ owner, zone: zoneName, cards: zone });
                            break;
                        }
                        case "Remove All Counters": {
                            playSoundEffect('tomb');

                            const cardId = cardData.id;
                            const info = findCardOwnerAndZone(cardId);
                            if (!info) break;
                            const { owner, zoneName } = info;

                            const zone = gameState[owner][zoneName];
                            const cardIndex = zone.findIndex(c => String(c.id) === String(cardId));

                            let card = cardData;
                            if (cardIndex !== -1) {
                                card = zone[cardIndex];
                                card.counters = 0;
                            }

                            updateCounterOverlay(cardElement, card);
                            const name = card.name || `Card ${card.id}`;
                            addGameLogEntry(`${name} loses all counters.`);

                            zone[cardIndex] = card; // make sure the updated card is in the zone array
                            await sendZoneSpecificUpdate({ owner, zone: zoneName, cards: zone });
                            break;
                        }
                        case "Attach / Mount": {
                            const colors = ['#e6194b','#3cb44b','#ffe119','#4363d8','#f58231','#911eb4'];
                            const color = colors[Math.floor(Math.random() * colors.length)];
                            placeCircle(cardData.id, color);

                            // Create draggable circle for cursor
                            const drag = document.createElement("div");
                            drag.className = "attachment-drag";
                            Object.assign(drag.style, {
                                position: "fixed",
                                width: "16px",
                                height: "16px",
                                backgroundColor: `${color}`,
                                border: `2px solid ${color}`,
                                borderRadius: "50%",
                                pointerEvents: "none",
                                zIndex: 300000
                            });
                            document.body.appendChild(drag);
                            document.body.style.cursor = "none";

                            function onMove(e) {
                                drag.style.top = `${e.clientY - 8}px`;
                                drag.style.left = `${e.clientX - 8}px`;
                            }
                            document.addEventListener("mousemove", onMove);

                            // Modal builder with restored cursor over popup
                            function showModal(message, onConfirm, onCancel) {
                                const overlay = document.createElement("div");
                                Object.assign(overlay.style, {
                                position: "fixed",
                                top: 0,
                                left: 0,
                                width: "100%",
                                height: "100%",
                                background: "rgba(0,0,0,0.5)",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                zIndex: 400000,
                                cursor: "auto"  // show cursor over overlay
                                });
                                const box = document.createElement("div");
                                Object.assign(box.style, {
                                background: "#fff",
                                padding: "20px",
                                borderRadius: "8px",
                                textAlign: "center",
                                maxWidth: "300px",
                                cursor: "auto"  // ensure cursor is visible on modal
                                });
                                const msg = document.createElement("p");
                                msg.textContent = message;
                                const btnConfirm = document.createElement("button");
                                btnConfirm.textContent = "Confirm";
                                const btnCancel = document.createElement("button");
                                btnCancel.textContent = "Cancel";
                                btnConfirm.style.margin = btnCancel.style.margin = "8px";
                                box.append(msg, btnConfirm, btnCancel);
                                overlay.appendChild(box);
                                document.body.appendChild(overlay);

                                btnConfirm.addEventListener("click", () => {
                                onConfirm();
                                cleanup();
                                });
                                btnCancel.addEventListener("click", () => {
                                onCancel();
                                cleanup();
                                });

                                function cleanup() {
                                overlay.remove();
                                document.removeEventListener("click", clickHandler, true);
                                document.removeEventListener("mousemove", onMove);
                                drag.remove();
                                document.body.style.cursor = "";
                                }
                            }

                            // Only intercept clicks on cards; modal buttons will still receive events
                            const clickHandler = ev => {
                                const tgt = ev.target.closest(".card");
                                if (!tgt) return;
                                ev.stopPropagation();
                                ev.preventDefault();
                                const tgtId = tgt.dataset.cardId;
                                const name = tgt.dataset.cardName || tgt.querySelector(".card-name")?.innerText || `#${tgtId}`;
                                showModal(
                                `Attach "${cardData.name}" to "${name}"?`,
                                () => {
                                    socket.emit('attach_card', { gameId, sourceId: cardData.id, targetId: tgtId, color });
                                    // now update this card’s menu text:
                                    const menuBtn = document.querySelector(
                                        `.card[data-card-id="${cardData.id}"] .hover-menu button[ data-action="Attach / Mount" ]`
                                    );
                                    if (menuBtn) menuBtn.textContent = 'Remove Attachment';
                                },
                                () => { /* cancel: allow re-pick */ }
                                );
                            };

                            document.addEventListener("click", clickHandler, true);
                        } break;
                        case "Remove Attachment": {
                            // find your attachment
                            const att = attachments.find(a=>a.sourceId==cardData.id);
                            if (!att) break;
                            const { targetId, color } = att;
                            socket.emit('remove_attachment', { gameId, sourceId:cardData.id, targetId, color });
                            // swap menu entry back
                            text = "Attach / Mount";
                        } break;
                        case "Remove": {
                            playSoundEffect('tomb');
                            /* remove the Token from its current zone and refresh that zone */

                            const zoneArr = gameState[username][zone] || [];
                            const idx     = zoneArr.findIndex(c => String(c.id) === String(cardData.id));
                            if (idx > -1) zoneArr.splice(idx, 1);        // take it out of state

                            /* map the zone name to its DOM box so we can re-render it */
                            const boxId = {
                                "Hand":                   "drawn-cards",
                                "Zone (Champion)":        "playerChampionsBox",
                                "Zone (Arsenal)":         "playerArsenalBox",
                                "Reserve":                "playerReserveBox",
                                "FaceDownZone":           "playerFaceDownBox",
                                "FaceDownArsenalZone":    "playerFaceDownArsenalBox",
                                "Tomb":                   "playerTombBox",
                                "Void":                   "playerVoidBox"
                            }[zone];

                            /* tell the server, then update the UI */
                            await sendZoneUpdate([zone]);
                            if (boxId) renderCardZone(zoneArr, boxId);

                            addGameLogEntry(`${cardData.name} was removed from ${zone}.`);
                            break;
                        }
                        default:
                            console.warn("Unhandled action:", text);
                    }
                    });
                    btn.addEventListener("mouseenter", () => btn.style.background = "#333");
                    btn.addEventListener("mouseleave", () => btn.style.background = "transparent");
                    hoverMenu.appendChild(btn);
                });

                cardElement.appendChild(hoverMenu);

                Object.assign(hoverMenu.style, {
                    transform:  isFaceDown
                        ? "translateX(10px) translateY(-50%) rotate(90deg)"
                        : "translate(-50%, 10px)",
                    opacity:    "0",
                    transition: "transform 150ms ease, opacity 150ms ease"
                });

                // 6) event wiring
                hoverMenu.addEventListener("mouseenter", () => clearTimeout(hideTimer));
                hoverMenu.addEventListener("mouseleave", () => hideTimer = setTimeout(hideMenu, 150));
            }
        }

        function applyHoverMenus() {
            document.querySelectorAll('.card:not(#viewing-window .card)').forEach(el => {
                const cardData = el._card || { name: el.dataset.zone };
                attachHoverMenu(el, cardData);
            });
        }

        function changeLife(player, amount, gameState, username, gameId) {
            if (!gameState[player]) return;

            if (gameState.invertHealingAndDamage) {
                amount = -amount;
            }

            const originalLife = gameState[player].life;
            let newLife = originalLife + amount;
            if (newLife < 0) newLife = 0;

            gameState[player].life = newLife;

            const isSelf = player === username;
            const lifeElem = document.getElementById(isSelf ? "player-life" : "opponent-life");
            const screenHalf = document.getElementById(isSelf ? "player-side" : "opponent-side");

            if (lifeElem && screenHalf) {
                animateLifeNumber(lifeElem, originalLife, newLife);

                const flash = document.createElement("div");
                flash.className = `life-flash ${amount > 0 ? "heal" : "damage"} ${isSelf ? "bottom" : "top"}`;
                if (amount > 0) {
                    playSoundEffect('heal');
                } else {
                    playSoundEffect('damage');
                }
                screenHalf.appendChild(flash);

                setTimeout(() => flash.classList.add("active"), 10);
                setTimeout(() => flash.remove(), 700);
            }

            sendLifeUpdate(gameId, gameState, player);
            window.socket?.emit('life_change', {
                gameId,
                player,
                life: newLife,
                delta: newLife - originalLife,
                from: username
            });

            if (newLife <= 0) {
                // Dispatch a custom event to trigger game loss
                document.dispatchEvent(new CustomEvent("playerLifeReachedZero", {
                    detail: { player }
                }));
            }

            // Return true if this reduced the player's life to 0
            return newLife <= 0;
        }

        function animateLifeNumber(element, start, end) {
            const duration = 500;
            const stepTime = 30;
            const steps = Math.floor(duration / stepTime);
            let currentStep = 0;

            const step = () => {
                currentStep++;
                const progress = currentStep / steps;
                const value = Math.round(start + (end - start) * progress);
                element.textContent = value;

                if (currentStep < steps) {
                    setTimeout(step, stepTime);
                } else {
                    element.textContent = end;
                }
            };
            step();
        }

        async function sendLifeUpdate(gameId, gameState, player) {
            await fetch('https://geimon-app-833627ba44e0.herokuapp.com/updateGameState', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    gameId,
                    updatedZones: {
                        life: gameState[player].life
                    },
                    owner: player
                })
            });
        }

        document.getElementById('confirm-life-change').addEventListener('click', () => {
            const amt = parseInt(document.getElementById('life-amount').value, 10);
            if (isNaN(amt) || amt <= 0) return alert('Enter a positive number');
            const increase = document.getElementById('increase-life').classList.contains('active');

            changeLife(
                username,
                increase ? amt : -amt,
                gameState,
                username,
                gameId
            );

            document.getElementById('life-amount').value = '';
        });

        document.querySelectorAll('#increase-life, #decrease-life').forEach(btn => {
            btn.addEventListener('click', () => {
                document.getElementById('increase-life').classList.remove('active');
                document.getElementById('decrease-life').classList.remove('active');
                btn.classList.add('active');
            });
        });

        async function attachDeckHoverMenu() {
            const deckBox = document.getElementById("playerDeckBox");
                deckBox.style.position = "relative";
                deckBox.style.zIndex   = "200000";
                deckBox.style.overflow       = "visible";
                deckBox.style.pointerEvents  = "auto";

            if (!deckBox) {
                console.error("   ❌ No #playerDeckBox in DOM");
                return;
            }

            if (deckBox.dataset.hoverMenuAttached) {
                console.log("   ℹ️ hover menu already attached, bailing");
                return;
            }
            deckBox.dataset.hoverMenuAttached = "true";

            const menu = document.createElement("div");
            menu.className = "hover-menu";
            Object.assign(menu.style, {
                position:       "fixed",
                display:        "none",
                backgroundColor:"#111",
                color:          "white",
                border:         "1px solid #ccc",
                padding:        "6px",
                zIndex:         "300000",
                flexDirection:  "column",
                fontSize:       "0.8em",
                whiteSpace:     "nowrap",
                boxShadow:      "0 0 5px black",
                pointerEvents:  "auto"
            });

            const options = [
                "Surrender",
                "Obliterate Mill",
                "Mill",
                "View",
                "Shuffle",
                "Draw"
            ];

            options.forEach(text => {
                const btn = document.createElement("div");
                btn.textContent = text;
                Object.assign(btn.style, { padding:"2px 5px", cursor:"pointer" });

                btn.addEventListener("click", async e => {
                e.stopPropagation();
                menu.style.display = "none";

                switch (text) {
                    case "Shuffle":
                        playSoundEffect('shuffle');
                        animateDeckShuffle();
                        // Fisher–Yates shuffle (exists in your code)
                        shuffleDeck(gameState[username].Deck);
                        await sendZoneUpdate(["Deck"]);       // persist new deck order
                        updateDeckText();                     // update count display
                        addGameLogEntry(`${username} shuffled their deck.`);
                        break;

                    case "Draw":
                        // use your drawCards helper
                        playSoundEffect('draw'); // example usage of playing a sound for both players
                        await drawCards(gameState[username].Deck, 1);
                        break;

                    case "Mill":
                        playSoundEffect('tomb');
                        if (gameState[username].Deck.length === 0) return;
                        {
                            const [card] = gameState[username].Deck.splice(0,1);
                            card.boardState = "Tomb";
                            gameState[username].Tomb.push(card);
                            await sendZoneUpdate(["Deck","Tomb"]);
                            renderLatestTombCard();
                            updateDeckText();
                            addGameLogEntry(`${username} milled the top card of their deck.`);
                        }
                        break;

                    case "Obliterate Mill":
                        playSoundEffect('tomb');
                        if (gameState[username].Deck.length === 0) return;
                        {
                            const [card] = gameState[username].Deck.splice(0,1);
                            card.boardState = "Void";
                            gameState[username].Void.push(card);
                            await sendZoneUpdate(["Deck","Void"]);
                            renderLatestVoidCard();
                            updateDeckText();
                            addGameLogEntry(`${username} obliterated the top card of their deck.`);
                        }
                        break;

                    case "Surrender": {
                        const confirmBox = document.createElement("div");
                        Object.assign(confirmBox.style, {
                            position: "fixed",
                            top:      "50%",
                            left:     "50%",
                            transform:"translate(-50%, -50%)",
                            padding:  "20px",
                            backgroundColor: "#333",
                            color:         "white",
                            border:        "2px solid red",
                            borderRadius:  "10px",
                            zIndex:        "100900",
                            textAlign:     "center",
                            boxShadow:     "0 0 10px black"
                        });
                        confirmBox.innerHTML = `
                            <p style="margin-bottom: 20px;">Are you sure you'd like to surrender?</p>
                            <button id="confirm-surrender" style="margin-right: 10px;">Surrender</button>
                            <button id="cancel-surrender">Cancel</button>
                        `;
                        document.body.appendChild(confirmBox);

                        document.getElementById("confirm-surrender").onclick = async () => {
                            try {
                                await fetch("https://geimon-app-833627ba44e0.herokuapp.com/endGame", {
                                    method:      "POST",
                                    credentials: "include",
                                    headers: { "Content-Type": "application/json" },
                                    body:    JSON.stringify({
                                        gameId,
                                        loser:  username,
                                        reason: "Surrendered"
                                    })
                                });
                                //showBanner("You Lose", "Surrendered");
                                document.body.removeChild(confirmBox);
                            } catch (err) {
                                console.error("Error ending game:", err);
                                alert("Failed to surrender. Please try again.");
                            }
                        };
                        document.getElementById("cancel-surrender").onclick = () => {
                            document.body.removeChild(confirmBox);
                        };
                    } break;
                    case "View":
                    // build a modal overlay
                    const overlay = document.createElement("div");
                    Object.assign(overlay.style, {
                        position:        "fixed",
                        top:             "47.5%",
                        left:            "50%",
                        transform:       "translate(-50%, -50%)",
                        width:           "60vw",
                        height:          "80vh",
                        padding:         "0px 0px 0px",
                        backgroundColor: "rgba(0, 0, 0, 0.85)",
                        border:          "3px solid white",
                        borderRadius:    "12px",
                        zIndex:          "300000",
                        overflow:        "visible"
                    });

                    const scrollArea = document.createElement("div");
                    Object.assign(scrollArea.style, {
                        position:       "absolute",
                        top:            "0",
                        left:           "0",
                        width:          "100%",
                        height:         "calc(100% - 60px)",
                        overflowY:     "visible",
                        display:       "grid",
                        gridTemplateColumns: "repeat(auto-fill, minmax(85px, 1fr))",
                        gridAutoRows:        "135px",
                        rowGap:              "4px",
                        columnGap:     "4px",
                        justifyContent:"start",
                        alignItems:    "start",
                        padding:       "16px",
                    });
                    // add each deck card at 1/3 scale
                    gameState[username].Deck.forEach(cardObj => {
                        const card = cards.find(c => String(c.id) === String(cardObj.id));
                        const el = renderCard(card);
                            el.style.transform = "scale(0.28)";
                            el.style.transformOrigin  = "top left";
                            el.style.margin = "0px";
                            el.style.padding = "0";
                            el.style.pointerEvents = "auto";
                        el.dataset.zone = "Deck";
                        attachHoverMenu(el, card);
                        // highlight on hover
                        el.addEventListener("mouseenter", () => {
                            // clear out previous preview
                            const scaled = document.getElementById("scaled-card");
                            scaled.innerHTML = "";

                            // render full-size clone
                            const big = renderCard(card);
                                big.style.marginLeft = "-62px";
                                big.style.marginTop = "-27px";
                                big.style.transform     = "scale(1.2)";
                                big.style.transformOrigin = "top left";
                                big.style.pointerEvents = "none";

                            scaled.appendChild(big);
                        });
                        el.addEventListener("mouseleave", () => el.style.boxShadow = "none");
                        scrollArea.appendChild(el);
                    });

                    overlay.appendChild(scrollArea);

                    const btnContainer = document.createElement("div");
                    Object.assign(btnContainer.style, {
                        position:        "absolute",
                        bottom:          "10px",    // 10px above the overlay’s bottom edge
                        left:            "50%",
                        transform:       "translateX(-50%)",
                        zIndex:          "300001",  // just above the overlay content
                    });

                    // close button
                    const closeBtn = document.createElement("button");
                    closeBtn.textContent = "Close";
                    Object.assign(closeBtn.style, {
                        position:        "fixed",
                        bottom:          "20px",
                        left:            "50%",
                        transform:       "translateX(-50%)",
                        padding:         "8px 16px",
                        fontSize:        "1em",
                        zIndex:          "4000",
                        cursor:          "pointer",
                    });
                    closeBtn.onclick = () => overlay.remove();
                    overlay.appendChild(closeBtn);
                    overlay.appendChild(btnContainer);

                    document.body.appendChild(overlay);
                    break;
                }
                });

                btn.addEventListener("mouseenter", () => btn.style.background = "#333");
                btn.addEventListener("mouseleave", () => btn.style.background = "transparent");
                menu.appendChild(btn);
            });

            deckBox.appendChild(menu);

            //console.log("deckText exists?", !!document.getElementById("deckText"));
            deckBox.addEventListener("mouseenter", () => {
                document.getElementById("deckText").textContent = `${remainingDeck.length}`;
                const rect = deckBox.getBoundingClientRect();
                menu.style.left = `${rect.left + rect.width/2}px`;
                menu.style.top  = `${rect.top}px`;
                menu.style.transform = "translate(-50%, -100%)";
                menu.style.display = "flex";
            });
            deckBox.addEventListener("mouseleave", () => {
                document.getElementById("deckText").textContent = "Deck";
                menu.style.display = "none";
            });
        }

        /**
         * Renders every card in one zone (hand, board, reserve, face-down piles …)
         * – Works for both players.
         * – Opponent face-down cards show THEIR sleeve and never preview.
         * – Player face-down cards keep the hover preview.
         */
        async function renderCardZone(cardsArray, containerId) {
            const container = document.getElementById(containerId);
            if (!container) return;

            /* gap tweaks for the player’s two face-down rows */
            container.style.gap = containerId === "playerFaceDownBox"        ? "75px"
                                : containerId === "playerFaceDownArsenalBox"  ? "25px"
                                : "4px";

            /* true when we are drawing a zone that belongs to the opponent */
            const isOppSide = containerId.startsWith("opponent");

            container.innerHTML = "";            // wipe old cards
            if (!cardsArray || cardsArray.length === 0) return;

            const faceUpBoxes = new Set([
                "playerChampionsBox",
                "playerArsenalBox",
                "playerReserveBox",
                "opponentFaceDownBox",
                "opponentFaceDownArsenalBox"
            ]);

            let ordered;
            if (faceUpBoxes.has(containerId)) {
                ordered = cardsArray.slice();
            } else {
                const half    = Math.floor(cardsArray.length / 2);
                ordered = [];
                for (let i = 0; i < cardsArray.length; i++) {
                    const offset = i % 2 === 0
                    ?   i / 2
                    :  -Math.ceil(i / 2);
                    ordered.push(
                        cardsArray[half + offset] ||
                        cardsArray[half - offset]
                    );
                }
            }

            /* fetch the player’s sleeve once (opponent sleeve comes from their deck-box) */
            if (!userSleeveURL) userSleeveURL = await fetchUserData();

            ordered.forEach(cardData => {
                if (!cardData?.id) return;

                /* full card or token */
                let card = cards.find(c => String(c.id) === String(cardData.id));
                if (!card) {
                const baseToken = tokens.find(t => String(cardData.id).startsWith(String(t.id)));
                if (baseToken) card = { ...baseToken, ...cardData };
                }

                /* ---------------- face-down checks ---------------- */
                const isFaceDownArsenal  = cardData.boardState === "FaceDownArsenalZone";
                const isFaceDownChampion = cardData.boardState === "FaceDownZone";
                const isFaceDown         = isFaceDownArsenal || isFaceDownChampion;

                /* --------- FACE-DOWN ARSENAL CARD (both players) --------- */
                if (isFaceDownArsenal) {
                    const wrap = document.createElement("div");
                    wrap.classList.add("card");
                    Object.assign(wrap.style, {
                        display:"inline-block", position:"relative",
                        marginLeft:"-33.8%", marginTop:"-16px",
                        width:"260px", height:"400px",
                        transform:"scale(0.3)", transformOrigin:"top center",
                        pointerEvents:"auto", cursor:"default"
                    });

                    const sleeve = isOppSide
                        ? (opponentDeckBox?.style.backgroundImage || '').slice(5,-2)
                        : userSleeveURL;

                    const cardBack = document.createElement("div");
                    Object.assign(cardBack.style, {
                        width:"100%", height:"100%",
                        backgroundImage:`url(${sleeve || 'default-sleeve.png'})`,
                        backgroundSize:"cover", backgroundPosition:"center",
                        border:"2px solid white", pointerEvents:"none"
                    });
                    wrap.appendChild(cardBack);

                    /* ── overlay button restores targeting/highlight ─────────── */
                    const btn = document.createElement("button");
                    btn.className = "card-button";
                    btn.dataset.cardId = String(cardData.id);
                    Object.assign(btn.style,{
                        position:"absolute", top:"0", left:"0",
                        width:"100%", height:"100%",
                        border:"none", background:"transparent", opacity:"0",
                        cursor:"pointer", pointerEvents:"auto", zIndex:100100
                    });
                    if (containerId === "playerFaceDownArsenalBox") {
                        btn.style.top = "-320px";
                    }
                    wrap.appendChild(btn);
                    if (typeof wrapCardButton === "function") wrapCardButton(btn, containerId);

                    /* only PLAYER’S own face-down arsenal previews */
                    if (!isOppSide) {
                        btn.addEventListener("mouseenter", () => {
                            const full = cards.find(c => String(c.id) === String(cardData.id));
                            if (!full) return;
                            const scaled = document.querySelector("#viewing-window .scaled-card");
                            if (!scaled) return;
                            scaled.innerHTML = "";
                            const preview = renderCard(full);
                            Object.assign(preview.style,{
                                width:"240px", height:"420px", transform:"scale(1.2)",
                                marginLeft:"-15%", marginTop:"7%"
                            });
                            scaled.appendChild(preview);
                        });
                    }

                    wrap.appendChild(btn);
                    if (typeof wrapCardButton === "function") wrapCardButton(btn, containerId);
                    if (isOppSide) {
                        attachTargetOverlay(btn,  cardData);
                    } else {
                        attachHoverMenu(btn,  cardData);
                    }
                    wrap.dataset.cardId = String(cardData.id);
                    wrap.dataset.zone   = "FaceDownArsenalZone";
                    wrap._card          = cardData;
                    if (isOppSide) {
                        attachTargetOverlay(wrap, cardData);
                    } else {
                        attachHoverMenu(wrap, cardData);
                    }
                    container.appendChild(wrap);
                    return;       // done with this card
                }

                /* --------- OTHER FACE-DOWN CARDS (champions etc.) --------- */
                if (isFaceDown) {
                    const wrap = document.createElement("div");
                    wrap.classList.add("card");
                    Object.assign(wrap.style,{
                        display:"inline-block", position:"relative",
                        marginLeft:"-39.3%", marginTop:"16px",
                        width:"260px", height:"400px",
                        transform:"translateY(11%) rotate(270deg) scale(0.33)",
                        transformOrigin:"top center"
                    });

                    /* correct sleeve for each side */
                    const sleeve = isOppSide
                        ? (opponentDeckBox?.style.backgroundImage || '').slice(5,-2)
                        : userSleeveURL;

                    const cardBack = document.createElement("div");
                    Object.assign(cardBack.style,{
                        width:"100%", height:"100%",
                        backgroundImage:`url(${sleeve || 'default-sleeve.png'})`,
                        backgroundSize:"cover", backgroundPosition:"center",
                        border:"2px solid white", pointerEvents:"none"
                    });
                    wrap.appendChild(cardBack);

                    /* ── overlay button restores targeting/highlight ─────────── */
                    const btn = document.createElement("button");
                    btn.className = "card-button";
                    btn.dataset.cardId = String(cardData.id);
                    Object.assign(btn.style,{
                        position:"absolute", top:"0", left:"0",
                        width:"100%", height:"100%",
                        border:"none", background:"transparent",
                        opacity:"0", cursor:"pointer", pointerEvents:"auto",
                        zIndex:100100
                    });

                    /* player’s own face-down cards still preview on hover */
                    if (!isOppSide) {
                        btn.addEventListener("mouseenter", () => {
                            const real = cards.find(c => String(c.id) === String(cardData.id));
                            if (!real) return;
                                const scaled = document.querySelector("#viewing-window .scaled-card");
                            if (!scaled) return;
                            scaled.innerHTML = "";
                            const preview = renderCard(real);
                            Object.assign(preview.style,{
                                width:"240px", height:"420px", transform:"scale(1.2)",
                                marginLeft:"-15%", marginTop:"7%"
                            });
                            scaled.appendChild(preview);
                        });
                    }
                    wrap.appendChild(btn);
                    if (typeof wrapCardButton === "function") wrapCardButton(btn, containerId);
                    if (isOppSide) {
                        attachTargetOverlay(btn,  cardData);
                    } else {
                        attachHoverMenu(btn,  cardData);
                    }
                    wrap.dataset.cardId = String(cardData.id);
                    wrap.dataset.zone = "FaceDownZone";
                    wrap._card        = cardData;

                    if (isOppSide) {
                        attachTargetOverlay(wrap, cardData);
                    } else {
                        attachHoverMenu(wrap, cardData);
                    }

                    container.appendChild(wrap);
                    return;
                }

                /* ---------------- FACE-UP cards (normal path) ---------------- */
                const enriched = { ...card, ...cardData };     // keep your live stats
                const rendered = renderCard(enriched);
                rendered._card = cardData;                     // keep your quick ref

                if (containerId === "playerChampionsBox") rendered.dataset.zone = "Zone (Champion)";
                if (containerId === "playerArsenalBox")   rendered.dataset.zone = "Zone (Arsenal)";
                if (containerId === "playerReserveBox")   rendered.dataset.zone = "Reserve";

                attachHoverMenu(rendered, cardData);
                // inside renderCardZone loop, after `attachHoverMenu(rendered, cardData);`
                if (cardData.counters) {
                    updateCounterOverlay(rendered, cardData);
                }
                if (cardData.damage !== undefined || cardData.damageThreshold !== undefined) {
                    refreshCardFace(rendered, cardData);
                }

                /* wrapper controls scale / offset for various zones */
                const wrap = document.createElement("div");
                Object.assign(wrap.style,{ display:"inline-block", position:"relative",
                                        pointerEvents:"auto", zIndex:"200000" });
                if (containerId === "playerReserveBox") {
                Object.assign(wrap.style,{
                    marginLeft:"-210px", marginTop:"-350px",
                    transform:"scale(0.3)", transformOrigin:"top center"
                });
                } else if (containerId === "opponentReserveBox") {
                    Object.assign(wrap.style,{ marginLeft:"-210px", marginTop:"-350px" });
                } else {
                    Object.assign(wrap.style,{
                        marginLeft:"-44px", marginTop:"323px",
                        transform:"scale(0.3)", transformOrigin:"top center"
                    });
                }

                /* hover to show big card */
                wrap.addEventListener("mouseenter", () => {
                const scaled = document.querySelector("#viewing-window .scaled-card");
                if (!scaled) return;
                scaled.innerHTML = "";
                const preview = renderCard(enriched);
                Object.assign(preview.style,{
                    width:"240px", height:"420px", transform:"scale(1.2)",
                    marginLeft:"-15%", marginTop:"7%"
                });
                scaled.appendChild(preview);
                });

                wrap.appendChild(rendered);
                updateCounterOverlay(wrap, cardData);

                wrap.dataset.cardId   = String(cardData.id);
                wrap.dataset.cardName = enriched.name;

                container.appendChild(wrap);
            });
            attachments.forEach(({ sourceId, targetId, color }) => {
                placeCircle(sourceId, color);
                placeCircle(targetId, color);
            });
        }
    applyHoverMenus();

    setInterval(() => {
        // you may want to guard that gameState is initialized
        if (!gameState) return;

        renderLatestTombCard();
        renderLatestVoidCard();
        renderLatestOpponentTombCard();
        renderLatestOpponentVoidCard();
    }, 250);

    // 1) New helper – only gives you the click-through target overlay:
    function attachTargetOverlay(el, cardData) {
        // don’t double-add
        if (el.querySelector('.target-overlay')) return;

        // make sure the parent can be positioned
        if (getComputedStyle(el).position === 'static') {
            el.style.position = 'relative';
        }

        const overlay = document.createElement('div');
        overlay.classList.add('target-overlay');
        Object.assign(overlay.style, {
            position:   'absolute',
            top:        '0',
            left:       '0',
            width:      '100%',
            height:     '100%',
            cursor:     'pointer',
            zIndex:     '220000'
        });

        overlay.addEventListener('click', e => {
            e.stopPropagation();
            socket.emit('toggle_target', { gameId, cardId: cardData.id });
            flashTargetRing(cardData.id);
        });

        el.appendChild(overlay);
    }

    async function flipCard(cardId) {
        const facedownZone = gameState[username].FaceDownZone;
        const championsZone = gameState[username]["Zone (Champion)"];

        const cardIndex = facedownZone.findIndex(c => String(c.id) === String(cardId));
        if (cardIndex === -1) {
            console.warn("❌ Card not found in FaceDownZone:", cardId);
            return;
        }

        const card = facedownZone[cardIndex];

        // ❌ Only the player on their turn can flip
        if (gameState.turn.currentPlayer !== username) {
            alert("You can only flip cards during your turn.");
            return;
        }

        // ❌ Only during Main 1 or Main 2
        const phase = gameState.turn.currentPhase;
        if (phase !== "Main 1" && phase !== "Main 2") {
            alert("You can only flip champions face-up during your Main Phase.");
            return;
        }

        // ❌ Cannot flip the turn it's set
        if (gameState.turn.count <= card.setTurn) {
            alert("You cannot flip this card the turn it was set.");
            return;
        }

        // ✅ Move to Champion Zone
        facedownZone.splice(cardIndex, 1);
        delete card.faceDown;
        delete card.setTurn;
        card.lastBoardState = "FaceDownZone";
        card.boardState = "Zone (Champion)";
        championsZone.push(card);

        addGameLogEntry(`${username} flipped a champion face-up: ${card.name}`);

        await fetch("https://geimon-app-833627ba44e0.herokuapp.com/updateGameState", {
            method: "POST",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                gameId,
                owner: username,
                updatedZones: {
                    FaceDownZone: facedownZone,
                    [CHAMPION_ZONE]: championsZone
                }
            })
        });
        setTimeout(async () => {
            await updateLocalFromGameState();
        }, 5000); // adjust if needed
    }

    document.addEventListener("playerLifeReachedZero", async (e) => {
        if (gameEnded) return;
        gameEnded = true;
        const loser = e.detail.player;
        const winner = Object.keys(gameState).find(name =>
            name !== loser && name !== "turn" && name !== "player1" && name !== "player2"
        );

        await fetch("https://geimon-app-833627ba44e0.herokuapp.com/endGame", {
            method: "POST",
            credentials: "include",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                gameId,
                loser,
                reason: "Life reached 0"
            })
        });

        if (loser === username) {
            //showBanner("You Lose", "Your life reached 0");
        } else {
            //showBanner("You Win", "Opponent’s life reached 0");
        }
    });

    document.addEventListener("DOMContentLoaded", () => {
        const tooltip = document.getElementById("tooltip");
        const tokenTooltip = document.getElementById("token-tooltip");

        const tabs = document.querySelectorAll(".tab-button");
        const contents = document.querySelectorAll(".tab-content");

        const chatMessages = document.getElementById('chat-messages');
        const chatTyping   = document.getElementById('chat-typing');
        const chatInput    = document.getElementById('chat-input');
        const chatSend     = document.getElementById('chat-send');

        function appendSystem(msg) {                  // copied from single.html
            const d = document.createElement('div');
            d.className = 'system-message';
            d.textContent = msg;
            chatMessages.appendChild(d);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        window.appendSystem = appendSystem;

        socket.on("lifeFlash", ({ player, life, delta, from }) => {
            const isSelf = player === username;
            const lifeElem = document.getElementById(isSelf ? "player-life" : "opponent-life");
            const screenHalf = document.getElementById(isSelf ? "player-side" : "opponent-side");

            const oldLife = gameState[player].life;
            const newLife = life;
            gameState[player].life = newLife;

            if (lifeElem && screenHalf) {
                animateLifeNumber(lifeElem, oldLife, newLife);

                const flash = document.createElement("div");
                flash.className = `life-flash ${delta > 0 ? "heal" : "damage"} ${isSelf ? "bottom" : "top"}`;
                screenHalf.appendChild(flash);

                setTimeout(() => flash.classList.add("active"), 10);
                setTimeout(() => flash.remove(), 700);
            }
        });

        socket.on('temp_reveal_card', ({ from, cardId }) => {
            if (from === username) return;          // ignore the echo of our own message
            tempRevealedIds.add(String(cardId));
            renderOpponentHand();                   // flip it for 3 s on our screen
            setTimeout(() => {
                tempRevealedIds.delete(String(cardId));
                renderOpponentHand();               // flip it back
            }, 3000);
        });

        // incoming chat
        socket.on('message', ({ username: from, text }) => {
            const div = document.createElement('div');
            div.textContent = `${from}: ${text}`;
            chatMessages.appendChild(div);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        });

        // incoming typing indicator
        socket.on('typing', ({ username: from, isTyping }) => {
            chatTyping.textContent = isTyping ? `${from} is typing…` : '';
        });

        // send chat
        function sendChat () {
            const txt = chatInput.value.trim();
            if (!txt) return;
            socket.emit('message', txt);
            chatInput.value = '';
        }
        chatSend.onclick = sendChat;
        chatInput.addEventListener('keypress', e => {
            if (e.key === 'Enter') sendChat();
                socket.emit('typing', true);
        });
        chatInput.addEventListener('input', () => {
            if (chatInput.value === '') socket.emit('typing', false);
        });
        let typingTimeout;
        chatInput.addEventListener('keyup', () => {
            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => socket.emit('typing', false), 1000);
        });

        tabs.forEach(tab => {
            tab.addEventListener("click", () => {
                tabs.forEach(t => t.classList.remove("active"));
                contents.forEach(c => c.classList.remove("active"));

                tab.classList.add("active");
                document.getElementById(tab.dataset.tab).classList.add("active");
            });
        });

        // Game Log Data Population
        const params = new URLSearchParams(window.location.search);
        //document.getElementById("totem").textContent = params.get("totem");

        const dictionarySearch = document.getElementById("dictionary-search");
        const dictionaryResults = document.getElementById("dictionary-results");

        const loadAllTerms = () => {
            dictionaryResults.innerHTML = "";
            const allTerms = [...Object.entries(keywords), ...Object.entries(rules)];
            allTerms.sort((a, b) => a[0].localeCompare(b[0]));
            allTerms.forEach(([key, value]) => {
                const resultItem = document.createElement("p");
                resultItem.innerHTML = `<strong>${key}:</strong> ${value}`;
                dictionaryResults.appendChild(resultItem);
            });
        };
        loadAllTerms();

        dictionarySearch.addEventListener("input", () => {
            const query = dictionarySearch.value.toLowerCase();
            dictionaryResults.innerHTML = "";

            if (!query) {
                loadAllTerms();
                return;
            }

            const matchedKeywords = Object.entries(keywords).filter(([key]) =>
                key.toLowerCase().includes(query)
            );

            const matchedRules = Object.entries(rules).filter(([key]) =>
                key.toLowerCase().includes(query)
            );

            [...matchedKeywords, ...matchedRules].forEach(([key, value]) => {
                const resultItem = document.createElement("p");
                resultItem.innerHTML = `<strong>${key}:</strong> ${value}`;
                dictionaryResults.appendChild(resultItem);
            });
        });

        document.querySelectorAll(".keyword").forEach(keyword => {
            const description = keyword.dataset.description;

            if (description && description.trim() !== "") {
                keyword.addEventListener("mouseenter", (e) => {
                    tooltip.textContent = description;
                    tooltip.style.display = "block";
                    tokenTooltip.querySelector(".token-tooltip-text").textContent = description;
                    tokenTooltip.style.display = "block";
                });

                keyword.addEventListener("mouseleave", () => {
                    tooltip.style.display = "none";
                    tokenTooltip.style.display = "none";
                });

                keyword.addEventListener("mousemove", (e) => {
                    if (tooltip.style.display === "block") {
                        tooltip.style.left = `${e.pageX + 10}px`;
                        tooltip.style.top = `${e.pageY - 40}px`;
                    }
                    if (tokenTooltip.style.display === "block") { // ✅ Fix: Remove `else if`
                        tokenTooltip.style.left = `${e.pageX + 10}px`;
                        tokenTooltip.style.top = `${e.pageY - 40}px`;
                    }
                });
            }
        });
    });
    initGameClient();
    </script>
</body>
</html>