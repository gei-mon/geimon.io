<!DOCTYPE html>
<html lang=""en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv=""X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
    <link rel="icon" href="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/favicon.png" type="image/png">
    <link rel="stylesheet" href="style.css">
    <title>ACTIVE GAME</title>
</head>
<style>
  #coin {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    transition: transform 0.1s;
}
  #drawn-cards {
    position: fixed;
    bottom: 2%; /* Positions the cards near the bottom */
    left: 50%;
    transform: translate(-25%, 30%);
    display: flex;
    flex-direction: row; /* Aligns cards in a horizontal row */
    align-items: center;
    z-index: 9999; /* Places it over everything */
    gap: -5%; /* Allows 5% overlap */
}
.card {
    width: 240px; /* Reduces card size */
    height: 420px;
    position: relative; /* Ensures controlled placement */
    margin-left: -5%; /* Overlaps cards by 5% */
}
.viewing-window {
    position: fixed;
    left: 0.5%; /* Keeps it on the left */
    top: 25%;
    transform: translateY(-50%);
    width: 280px; /* Size for zoomed card */
    height: 440px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #1e1e1e;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110; /* Ensures it's on top */
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.context-window {
    position: fixed;
    left: 0.5%;
    top: 75%;
    transform: translateY(-50%);
    width: 280px;
    height: 440px;
    display: flex;
    flex-direction: column;
    background-color: #1e1e1e;
    padding: 10px;
    border-radius: 10px;
    box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.5);
    z-index: 100110;
    pointer-events: auto !important;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}
.tabs {
    display: flex;
    justify-content: space-around;
    padding: 5px;
}
.tab-button {
    padding: 5px;
    cursor: pointer;
    background: #505050;
    color: white;
    border: none;
    border-radius: 5px;
}
.tab-button.active {
    background: #838383;
}
.tab-content-container {
    flex-grow: 1;
    padding: 10px;
    overflow-y: auto;
}
.tab-content {
    display: none;
    color: white;
}
.tab-content.active {
    display: block;
}
#viewing-window .scaled-card {
    pointer-events: auto !important;
    z-index: 100110; /* Ensures it's on top */
}
#viewing-window .scaled-card .card-cost,
#viewing-window .scaled-card .card-text,
#viewing-window .scaled-card .card-name,
#viewing-window .scaled-card .card-condition,
#viewing-window .scaled-card .card-tags,
#viewing-window .scaled-card .bottom-bar,
#viewing-window .scaled-card .card-image {
    z-index: 100200 !important;
}
.tooltip {
    z-index: 100300 !important;
}
#tooltip {
    position: absolute;
    display: none;
    background-color: rgba(0, 0, 0, 1);
    color: white;
    padding: 5px;
    border-radius: 5px;
    font-size: 14px;
    max-width: 250px;
    z-index: 100300; /* Ensure it appears above other elements */
}
.token-tooltip {
    pointer-events: auto !important;
    z-index: 100300 !important;
}
#token-tooltip {
    z-index: 100300; /* Ensure it appears above other elements */
}
.keyword {
    pointer-events: auto !important;
    position: relative; /* Ensures proper hovering */
    z-index: 100300; /* Ensures tooltip appears above other elements */
}
.card-cost .keyword {
    position: relative;
    z-index: 100300 !important;
    pointer-events: auto !important;
}
.card-cost {
    pointer-events: auto !important;
    z-index: 100000 !important;
}
.card-text {
    pointer-events: auto !important;
    z-index: 100000 !important;
}
.scaled-card .card-button {
    display: none !important;
}
</style>
<body style="background-color:rgb(78, 78, 78);">
  <img src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/try_2.png" class="bg-image" alt="">
        <div id="coin-flip-container" style="display: none; text-align: center; margin-top: 50px;">
            <img id="coin" src="https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png" alt="coin" style="width: 150px; height: 150px;">
            <h2 id="flip-result" style="display: none;"></h2>
        </div>
        <div id="tooltip" class="tooltip"></div>
        <div id="token-tooltip" style="display: none; position: absolute;">
            <div class="token-tooltip-text" style="font-family: 'Times New Roman', serif; font-size: 14px;"></div>
        </div>
        <div id="playerDeckBox"></div>
        <div id="drawn-cards" style="display: flex; flex-wrap: wrap; gap: 10px; padding: 10px;">
            <p id="drawn-message" style="color: white; font-size: 1.5em;"></p>
        </div>
        <div class="viewing-window" id="viewing-window">
            <div class="scaled-card" id="scaled-card" style="transform: scale(0.797); transform-origin: center; pointer-events: none; margin-left: 14%;"></div>
        </div>
        <div class="context-window" id="context-window">
            <div class="tabs">
                <button class="tab-button active" data-tab="chat">Chat</button>
                <button class="tab-button" data-tab="game-log">Game Log</button>
                <button class="tab-button" data-tab="dictionary">Dictionary</button>
            </div>
            <div class="tab-content-container">
                <div class="tab-content active" id="chat">
                    <p>This is a Solo Game, and we here at Geimon! do not believe that AI should be allowed to speak.</p>
                </div>
                <div class="tab-content" id="game-log">
                    <p>Totem: <span id="totem" style="color: goldenrod;"></span></p>
                    <p id="game-log-placeholder"></p>
                </div>
                <div class="tab-content" id="dictionary">
                    <input type="text" id="dictionary-search" placeholder="Search terms..." style="width: 95%;"">
                    <div id="dictionary-results"></div>
                </div>
            </div>
        </div>


        <script type="module">
            import { cards } from "./data/cards.js";
            import { tokens } from "./data/tokens.js";
            import { renderCard } from "./utils/cardRenderer.js";
            import { addTooltipListeners, addTokenTooltipListeners } from "./utils/cardRenderer.js";
            import { keywords } from "./data/keywords.js";
            import { rules } from "./data/rules.js";
            let gameId = localStorage.getItem("gameId");
            if (!gameId) {
                gameId = Math.random().toString(36).substr(2, 9); // Simple ID
                localStorage.setItem("gameId", gameId);
            }
            let username = null;
            const params = new URLSearchParams(window.location.search);
            const isSinglePlayer = params.get("gameType") === "single";
            const otherPlayerName = params.get("opponent") || "Unknown_Opponent"; // if multiplayer later

            async function getUsername() {
                const res = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/me', { credentials: 'include' });
                const data = await res.json();
                if (data.loggedIn) {
                    username = data.username;
                }
            }
            async function initGameClient() {
            await getUsername();
            if (!username) {
                alert("Could not retrieve username.");
                return; // ✅ This is now valid
            }
            }

        window.onload = () => {
            const params = new URLSearchParams(window.location.search);
            const turnOrder = params.get("turnOrder");

            if (turnOrder === "coinflip") {
                const container = document.getElementById("coin-flip-container");
                const coin = document.getElementById("coin");
                const resultText = document.getElementById("flip-result");
                container.style.display = "block";
                resultText.textContent = "";

                // Image paths
                const headsImg = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/heads.png";
                const tailsImg = "https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Site Assets/tails.png";

                let positionY = window.innerHeight / 2;
                let velocity = -25;
                let gravity = 1;
                let flips = 0;

                function animateFlip() {
                    coin.src = Math.random() > 0.5 ? headsImg : tailsImg;

                    positionY += velocity;
                    velocity += gravity;

                    coin.style.top = `${positionY}px`;

                    if (velocity > 0 && positionY >= window.innerHeight / 2) {
                        clearInterval(interval);

                        const finalResult = Math.random() > 0.5 ? "Heads" : "Tails";
                        coin.src = finalResult === "Heads" ? headsImg : tailsImg;

                        if (finalResult === "Tails") {
                            resultText.textContent = "You are going second.";
                            resultText.style.display = "block";
                            resultText.style.fontSize = "2em";
                            resultText.style.marginTop = "10%";
                            resultText.style.textShadow ="2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black";
                            setTimeout(() => transitionToNextScreen("second"), 2000);
                        } else {
                            resultText.textContent = "You won the coin flip! Choose:";
                            resultText.style.display = "block";
                            resultText.style.fontSize = "2em";
                            resultText.style.marginTop = "10%";
                            resultText.style.textShadow = "2px 2px 4px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black";

                            const buttonContainer = document.createElement("div");
                            buttonContainer.style.marginTop = "20px";

                            const goFirstButton = document.createElement("button");
                            goFirstButton.textContent = "Go First";
                            goFirstButton.style.marginRight = "10px";
                            goFirstButton.className = "button button";
                            goFirstButton.onclick = () => {
                                clearTimeout(autoSelectTimer); // Cancel timer if selected manually
                                transitionToNextScreen("first");
                            };

                            const goSecondButton = document.createElement("button");
                            goSecondButton.textContent = "Go Second";
                            goSecondButton.className = "button button";
                            goSecondButton.onclick = () => {
                                clearTimeout(autoSelectTimer); // Cancel timer if selected manually
                                transitionToNextScreen("second");
                            };

                            buttonContainer.appendChild(goFirstButton);
                            buttonContainer.appendChild(goSecondButton);
                            container.appendChild(buttonContainer);

                            // Start 3-second timer for automatic selection
                            const autoSelectTimer = setTimeout(() => {
                                const randomChoice = Math.random() < 0.5 ? "first" : "second"; // 50/50 chance
                                console.log(`Time expired! Automatically choosing: ${randomChoice}`);
                                transitionToNextScreen(randomChoice);
                            }, 3000); // 3 seconds
                        }

                    }
                }
                const interval = setInterval(animateFlip, 50);
            } else {
                document.body.innerHTML = `
                    <h1>Game Configuration</h1>
                    <p>Player Deck: ${params.get("playerDeck")}</p>
                    <p>Opponent Deck: ${params.get("opponentDeck")}</p>
                    <p>Game Type: ${params.get("gameType")}</p>
                    <p>Totem: ${params.get("totem")}</p>
                    <p>Turn Order: ${turnOrder}</p>
                `;
            }
        };
        async function fetchGameStateFromServer() {
            const response = await fetch(`https://geimon-app-833627ba44e0.herokuapp.com/getGameState/${gameId}`);
        if (!response.ok) {
            console.error("Failed to fetch game state");
            return;
        }
        gameState = await response.json();
        updateLocalFromGameState();
        }
        async function transitionToNextScreen(choice) {
            // Keep the background image visible
            const bgImage = document.querySelector(".bg-image");

            // Create a semi-transparent overlay
            const overlay = document.createElement("div");
            overlay.style.position = "absolute";
            overlay.style.top = "0";
            overlay.style.left = "0";
            overlay.style.width = "100%";
            overlay.style.height = "100%";
            overlay.style.backgroundColor = "rgba(0, 0, 0, 0.4)"; // Dark transparency
            overlay.style.zIndex = "10";

            // Main container for the structured design
            const mainContainer = document.createElement("div");
            mainContainer.style.position = "absolute";
            mainContainer.style.top = "2%";
            mainContainer.style.left = "2%";
            mainContainer.style.width = "94%";
            mainContainer.style.height = "92%";
            mainContainer.style.display = "flex";
            mainContainer.style.flexDirection = "column";
            mainContainer.style.justifyContent = "center";
            mainContainer.style.alignItems = "center";
            mainContainer.style.gap = "10px";
            mainContainer.style.padding = "20px";
            mainContainer.style.backgroundColor = "rgba(0, 0, 0)";
            mainContainer.style.borderRadius = "20px";
            mainContainer.style.zIndex = "20";
            mainContainer.style.opacity = "0"; // Start fully invisible
            mainContainer.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
            mainContainer.style.transform = "scale(0.8)  translate(100px,-50px)";

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                mainContainer.style.opacity = "1";
            }, 50);

            // Central result box
            const resultBox = document.createElement("div");
            resultBox.style.position = "absolute";
            resultBox.style.top = "50%";
            resultBox.style.left = "50%";
            resultBox.style.transform = "translate(-50%, -50%)";
            resultBox.style.padding = "20px 40px";
            resultBox.style.color = "white";
            resultBox.style.fontSize = "2em";
            resultBox.style.borderRadius = "10px";
            resultBox.style.textAlign = "center";
            resultBox.style.opacity = "0"; // Start fully invisible
            resultBox.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
            resultBox.style.zIndex = "100"; // On top of everything
            resultBox.style.boxShadow = "0 0 20px black";

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                resultBox.style.opacity = "1";
            }, 50);

            // Set background color based on choice
            resultBox.style.backgroundColor = choice === "first" ? "blue" : "red";
            resultBox.textContent = choice === "first" ? "Your Turn" : "Opponent's Turn";

            // Main board container
            const board = document.createElement("div");
            board.style.position = "absolute";
            board.style.top = "2%";
            board.style.left = "2%";
            board.style.width = "96%";
            board.style.height = "94%";
            board.style.backgroundColor = "black";
            board.style.zIndex = "20";
            board.style.borderRadius = "20px";
            board.style.opacity = "0"; // Start fully invisible
            board.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect

            // Trigger fade-in after DOM insertion
            setTimeout(() => {
                board.style.opacity = "1";
            }, 50);

            fetchUserData().then(userData => {
                if (userData && userData.zoneArt) {
                    const zoneArtContainer = document.createElement("div");
                    zoneArtContainer.style.position = "absolute";
                    zoneArtContainer.style.left = "0";
                    zoneArtContainer.style.bottom = "0";
                    zoneArtContainer.style.width = "100%";
                    zoneArtContainer.style.height = "50%";
                    zoneArtContainer.style.overflow = "hidden";

                    const zoneArtImage = document.createElement("img");
                    zoneArtImage.src = `https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Zones/${userData.zoneArt}`;
                    zoneArtImage.style.position = "absolute";
                    zoneArtImage.style.width = "100%";
                    zoneArtImage.style.height = "200%"; // Double height so top half is offscreen
                    zoneArtImage.style.top = "0%"; // Shift to crop top, show only bottom half
                    zoneArtImage.style.left = "0";
                    zoneArtImage.style.zIndex = "10";
                    zoneArtImage.style.border = "6px solid black";
                    zoneArtImage.style.objectFit = "cover";

                    zoneArtContainer.appendChild(zoneArtImage);
                    board.appendChild(zoneArtContainer);
                }
            });

            // After all elements like playerDeckBox and deckText are added
            fetchUserData().then(userData => {
                if (userData && userData.deckSleeve) {
                    playerDeckBox.style.backgroundImage = `url(https://geimon-app-833627ba44e0.herokuapp.com/Public/Images/Sleeves/${userData.deckSleeve})`;
                    playerDeckBox.style.backgroundSize = "cover";
                    playerDeckBox.style.backgroundPosition = "center";
                    playerDeckBox.style.backgroundRepeat = "no-repeat";
                }
            });

            // Function to add a box
            function addBox(x, y, w, h, color="green") {
                const box = document.createElement("div");
                box.style.position = "absolute";
                box.style.left = x;
                box.style.top = y;
                box.style.width = w;
                box.style.height = h;
                box.style.border = `4px solid ${color}`;
                box.style.backgroundColor = "black";
                box.style.opacity = "0.5";
                box.style.zIndex = "30";
                board.appendChild(box);
            }

            // Reproduce visual layout from image (values are approximate %)
            addBox("1%", "1%", "6%", "19%", "lightsalmon");     // Opponent Deck
            addBox("9%", "1%", "68%", "19%", "lightsalmon");    // Opponent Arsenal

            addBox("79%", "1%", "20%", "40%", "lightsalmon");   // Opponent Reserve

            addBox("1%", "22%", "6%", "19%", "lightsalmon");    // Opponent Tomb
            addBox("9%", "22%", "68%", "19%", "lightsalmon");   // Opponent Champions

            addBox("1%", "44%", "10%", "14%", "lightsalmon");    // Opponent Void

            addBox("14%", "47%", "72%", "7%", "lightgreen");    // Path

            addBox("89%", "44%", "10%", "14%", "lightblue");   // Player Void

            addBox("1%", "60%", "20%", "40%", "lightblue");   // Player Reserve

            addBox("23%", "60%", "68%", "19%", "lightblue");  // Player Champions
            addBox("93%", "60%", "6%", "19%", "lightblue");  // Player Tomb

            addBox("23%", "81%", "68%", "19%", "lightblue");  // Player Arsenal
            addBox("93%", "81%", "6%", "19%", "lightblue");  // Player Deck

            document.body.appendChild(overlay);
            document.body.appendChild(mainContainer);
            mainContainer.appendChild(board);
            mainContainer.appendChild(resultBox);

            // Fade out the result box after 3 seconds
            setTimeout(() => {
                resultBox.style.opacity = "0"; // Fades out smoothly
            }, 2000);

            const params = new URLSearchParams(window.location.search);
            const selectedTotem = params.get("totem");
            const selectedTotemText = params.get("totemText");

            document.getElementById("totem").textContent = selectedTotem;
            const totemTextElement = document.createElement("p");
            totemTextElement.innerHTML = `<strong>Description:</strong> ${selectedTotemText}`;
            document.getElementById("game-log").appendChild(totemTextElement);

            const totemBox = document.createElement("div");
            totemBox.style.position = "absolute";
            totemBox.style.top = "46%";
            totemBox.style.left = "53%";
            totemBox.style.transform = "translate(-50%, -50%)";
            totemBox.style.padding = "16px 32px";
            totemBox.style.backgroundColor = "goldenrod";
            totemBox.style.color = "white";
            totemBox.style.fontSize = "1.5em";
            totemBox.style.borderRadius = "10px";
            totemBox.style.textAlign = "center";
            totemBox.style.opacity = "0"; // Start invisible
            totemBox.style.transition = "opacity 1s ease-in-out";
            totemBox.style.zIndex = "120";
            totemBox.style.boxShadow = "0 0 20px black";
            totemBox.textContent = `Selected Totem: ${selectedTotem} - ${selectedTotemText}`;

            // Add to document
            document.body.appendChild(totemBox);

            // Trigger fade-in
            setTimeout(() => {
                totemBox.style.opacity = "1";
            }, 2500); // Slight delay after result box

            setTimeout(() => {
                totemBox.style.opacity = "0";
            }, 6500);

            // Function to fetch user data from the session
            async function fetchUserData() {
                try {
                    const res = await fetch('https://geimon-app-833627ba44e0.herokuapp.com/me', {
                        credentials: 'include'
                    });
                    if (!res.ok) throw new Error('Response error');

                    const data = await res.json();
                    if (!data.loggedIn) return null;

                    return data;
                } catch (err) {
                    console.error('Failed to fetch user data:', err);
                    return null;
                }
            }

            function updateLocalFromGameState() {
            const player = gameState[username];
            remainingDeck = player.Deck;
            drawnCardsArray = player.Hand;
            initialDeckSize = player.Deck.length + player.Hand.length + player.Tomb.length + player.Void.length;
            renderDrawnCards();
            updateDeckText();
            }

            // Fetch deck and start game
            const playerDeckName = new URLSearchParams(window.location.search).get("playerDeck");
            const opponentDeckName = new URLSearchParams(window.location.search).get("opponentDeck");

            const playerDeckResult = await fetchDeckCards(playerDeckName);
            const opponentDeckResult = await fetchDeckCards(opponentDeckName);

            if (!playerDeckResult.success || !opponentDeckResult.success) {
                console.error("Deck fetch failed");
                return;
            }

            const playerDeck = playerDeckResult.card_ids;
            const opponentDeck = opponentDeckResult.card_ids;

            if (playerDeckResult.success && opponentDeckResult.success) {
                await fetch('https://geimon-app-833627ba44e0.herokuapp.com/startGame', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        gameId,
                        playerUsername: username,
                        opponentUsername: isSinglePlayer ? "AI_Bot" : otherPlayerName,
                        playerDeck,
                        opponentDeck,
                        isSinglePlayer: true
                    })
                });

                if (gameState[username].Hand.length === 0) {
                    drawCards(gameState[username].Deck, 5);
                }

                if (gameState[username].Hand.length > 0) {
                    renderDrawnCards();
                    updateDeckText();
                } else {
                    drawCards(gameState[username].Deck, 5);
                }

                updateDeckText();
            } else {
                console.error("Deck loading failed:", playerDeckResult.message);
            }
        }
        async function fetchDeckCards(deckName) {
        if (deckName === "Random") {
            // Generate a random deck locally
            const cardPool = cards.map(card => card.id); // Extract all IDs
            const deckSize = Math.floor(Math.random() * 41) + 60; // Random between 60–100
            const shuffled = cardPool.sort(() => 0.5 - Math.random());
            const card_ids = shuffled.slice(0, deckSize);

            deckCount = `${card_ids.length}`;
            if (playerDeckBox) {
                playerDeckBox.innerText = "Deck";
            }

            return { success: true, card_ids };
        }

        // Fallback to real server call for named decks
        try {
            const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                method: "POST",
                credentials: 'include',
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ deck_name: deckName })
            });

            const data = await response.json();

            if (data.success) {
                deckCount = `${data.card_ids.length}`;
                if (playerDeckBox) {
                    playerDeckBox.innerText = "Deck";
                }
            } else {
                deckCount = data.message;
            }

            return data;
        } catch (error) {
            console.error("Error fetching deck cards:", error);
            return { success: false, message: 'Fetch error' };
        }
    }

    // Select the existing Player Deck box after it's created
    const playerDeckBox = document.createElement("div");
        playerDeckBox.id = "playerDeckBox";
        playerDeckBox.style.position = "absolute";
        playerDeckBox.style.left = "86.1%";
        playerDeckBox.style.top = "68.9%";
        playerDeckBox.style.width = "3.72%";
        playerDeckBox.style.height = "11.8%";
        //playerDeckBox.style.backgroundColor = "lightblue";
        playerDeckBox.style.outline = "4px solid white"; // Bright white outline for debugging
        playerDeckBox.style.display = "block"; // Ensure it's always visible
        playerDeckBox.style.zIndex = "1000"; // Bring it to the front layer
        playerDeckBox.style.opacity = "0"; // Start fully invisible
        playerDeckBox.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect
        playerDeckBox.style.textAlign = "center"; // Ensures proper alignment
        playerDeckBox.style.fontWeight = "bold";
        playerDeckBox.style.fontSize = "1.2em";
        playerDeckBox.style.color = "white";
        playerDeckBox.style.textShadow = `
            -2px -2px 4px black,  
            2px -2px 4px black,  
            -2px 2px 4px black,  
            2px 2px 4px black
        `;

    // Create the text span element separately
    const deckText = document.createElement("span");
        deckText.innerText = "Deck";
        deckText.style.position = "absolute"; // Positions independently inside the box
        deckText.style.left = "50%"; // Centers horizontally
        deckText.style.top = "70%"; // Moves text downward
        deckText.style.transform = "translate(-50%, -50%)"; // Ensures precise centering

    playerDeckBox.appendChild(deckText);
    document.body.appendChild(playerDeckBox); // Add to the document

    // Create Surrender Button Overlay
    const surrenderButton = document.createElement("button");
        surrenderButton.style.position = "absolute";
        surrenderButton.style.left = "86.1%";
        surrenderButton.style.top = "72%";
        surrenderButton.style.width = "3.72%";
        surrenderButton.style.height = "9%";//addBox("93%", "81%", "6%", "19%", "lightblue");  // Player Deck
        surrenderButton.style.backgroundColor = "rgba(255, 0, 0)";
        surrenderButton.style.opacity = "0";
        surrenderButton.style.border = "none";
        surrenderButton.style.zIndex = "1001";
        surrenderButton.style.cursor = "pointer";
        surrenderButton.title = "Surrender";

    // Add event listener for click
    surrenderButton.addEventListener("click", () => {
        const confirmBox = document.createElement("div");
        confirmBox.style.position = "fixed";
        confirmBox.style.top = "50%";
        confirmBox.style.left = "50%";
        confirmBox.style.transform = "translate(-50%, -50%)";
        confirmBox.style.padding = "20px";
        confirmBox.style.backgroundColor = "#333";
        confirmBox.style.color = "white";
        confirmBox.style.border = "2px solid red";
        confirmBox.style.borderRadius = "10px";
        confirmBox.style.zIndex = "10000";
        confirmBox.style.textAlign = "center";
        confirmBox.style.boxShadow = "0 0 10px black";

        confirmBox.innerHTML = `
            <p style="margin-bottom: 20px;">Are you sure you'd like to surrender?</p>
            <button id="confirm-surrender" style="margin-right: 10px;">Surrender</button>
            <button id="cancel-surrender">Cancel</button>
        `;

        document.body.appendChild(confirmBox);

        document.getElementById("confirm-surrender").onclick = () => {
            alert("You chose to surrender.");
            document.body.removeChild(confirmBox);
        };

        document.getElementById("cancel-surrender").onclick = () => {
            document.body.removeChild(confirmBox);
        };
    });

    document.body.appendChild(surrenderButton);

        setTimeout(() => {
            playerDeckBox.style.opacity = "1";
        }, 6500);
        let deckCount = "Deck";

    // Ensure it exists before adding event listeners
    if (playerDeckBox) {
        playerDeckBox.style.display = "block";
        playerDeckBox.style.outline = "4px solid white";

        playerDeckBox.addEventListener("mouseenter", () => {
            playerDeckBox.innerText = deckCount;
        });

        // Mouse leave resets to "Deck"
        playerDeckBox.addEventListener("mouseleave", () => {
            playerDeckBox.innerText = "Deck";
        });
    }

    // Fetch deck count dynamically
    setTimeout(async () => {
        const urlParams = new URLSearchParams(window.location.search);

        async function getDeckFromParam(paramName) {
            const paramValue = urlParams.get(paramName);
            try {
                const parsed = JSON.parse(paramValue);
                if (Array.isArray(parsed)) {
                    return parsed; // Already a full random deck
                }
            } catch (e) {
                const result = await fetchDeckCards(paramValue);
                if (result.success) return result.card_ids;
                console.error(`Failed to load deck '${paramName}':`, result.message);
                return [];
            }
        }

        const playerDeckCardIds = await getDeckFromParam("playerDeck");
        const opponentDeckCardIds = await getDeckFromParam("opponentDeck");

        // You can now use these arrays:
        console.log("Player Deck:", playerDeckCardIds);
        console.log("Opponent Deck:", opponentDeckCardIds);

        // Optionally continue setup:
        // startGameWithDecks(playerDeckCardIds, opponentDeckCardIds);
    }, 200);


        let remainingDeck = []; // Store shuffled deck globally
        let drawnCardsArray = []; // Track drawn cards separately
        let initialDeckSize = 0; // Store starting deck size globally
        let gameState = null;


        // Function to update deck text dynamically
        function updateDeckText() {
            if (deckText) {
                deckText.innerText = `Deck (${remainingDeck.length}/${initialDeckSize})`; // Correct dynamic update
            }
        }

        // Function to shuffle the deck using Fisher-Yates algorithm
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        // Function to render drawn cards
        function renderDrawnCards() {
            const drawnCardsContainer = document.getElementById("drawn-cards"); // Ensure this container exists
            const scaledCardContainer = document.getElementById("scaled-card");
            const viewingWindow = document.getElementById("viewing-window");
            const contextWindow = document.getElementById("context-window");
            drawnCardsContainer.innerHTML = ""; // Clear previous renders

            if (drawnCardsArray.length === 0) {
                console.log("No cards have been drawn yet.");
                return;
            }

            console.log("Rendering Drawn Cards:", drawnCardsArray);

            // Find full card details from `cards` dataset
            const drawnCardObjects = drawnCardsArray
                .map(obj => cards.find(card => String(card.id) === String(obj.id)))
                .filter(Boolean);

            const typeOrder = ["Champion", "Action", "Equipment", "Obelisk", "Rush", "Reflex"];
            drawnCardsArray.sort((a, b) => {
                const cardA = cards.find(c => String(c.id) === String(a.id));
                const cardB = cards.find(c => String(c.id) === String(b.id));
                if (!cardA || !cardB) return 0;

                const typeOrder = ["Champion", "Action", "Equipment", "Obelisk", "Rush", "Reflex"];
                const indexA = typeOrder.indexOf(cardA.type);
                const indexB = typeOrder.indexOf(cardB.type);

                if (indexA !== indexB) return indexA - indexB;
                return cardA.name.localeCompare(cardB.name);
            });

            drawnCardsArray.forEach(cardObj => {
                const card = cards.find(card => String(card.id) === String(cardObj.id));
                if (card) {
                    const cardElement = renderCard(card, drawnCardsContainer);
                        cardElement.dataset.boardState = cardObj.boardState;
                        cardElement.dataset.lastBoardState = cardObj.lastBoardState;
                    cardElement.style.transform = "scale(0.5)";
                    cardElement.style.position = "relative"; // Ensures correct alignment
                    cardElement.style.marginLeft = "-15%"; // Overlaps cards slightly
                    cardElement.style.opacity = "0";
                    cardElement.style.transition = "opacity 1s ease-in-out"; // Smooth fade effect

                    const cardButton = document.createElement("button");
                    cardButton.style.position = "absolute";
                    cardButton.style.top = "0";
                    cardButton.style.right = "0";
                    cardButton.style.width = "100%"; /* Covers entire card */
                    cardButton.style.height = "100%"; /* Covers entire card */
                    cardButton.style.opacity = "0";
                    cardButton.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
                    cardButton.style.border = "none";
                    cardButton.style.pointerEvents = "none";
                    cardButton.style.padding = "5px";
                    cardButton.style.zIndex = "100100";
                    cardButton.style.background = "transparent";
                    cardButton.onclick = () => alert(`Card clicked: ${card.name}`);

                    // Hover effect to display scaled card in viewing window
                    cardElement.addEventListener("mouseenter", () => {
                        scaledCardContainer.innerHTML = ""; // Clear previous preview
                        const clone = cardElement.cloneNode(true);
                        const cloneButton = clone.querySelector(".card-button");
                        if (cloneButton) cloneButton.remove(); // Remove interactions
                        clone.style.transform = "scale(1.2)"; // Slight enlargement
                        clone.style.width = "100%"; // Full width inside the viewing window
                        clone.style.position = "relative";
                        scaledCardContainer.appendChild(clone);
                        addTooltipListeners(clone);
                        addTokenTooltipListeners(clone);
                    });

                    cardElement.appendChild(cardButton);
                    drawnCardsContainer.appendChild(cardElement);
                    setTimeout(() => {
                        cardElement.style.opacity = "1";
                        cardButton.style.opacity = "1";
                        cardButton.style.pointerEvents = "auto";
                        cardButton.style.cursor = "pointer";
                        viewingWindow.style.opacity = "1";
                        contextWindow.style.opacity = "1";
                    }, 6500);
                }
            });
        }
        async function drawCards(deck, numCards = 5) {
        if (deck.length < numCards) {
            console.warn("Not enough cards left to draw.");
            return [];
        }

        function getCardsFromZone(zone, count) {
            return zone.splice(0, count);
        }

        function renderZone(zoneName, owner = username) {
            const cards = gameState[owner][zoneName];
        }

        const drawnCards = getCardsFromZone(gameState[username].Deck, numCards);
        drawnCards.forEach(card => {
            card.lastBoardState = card.boardState;
            card.boardState = "Hand";
        });
        gameState[username].Hand.push(...drawnCards);

        // Debugging logs for confirmation
        console.log("Initial Hand:", drawnCards);
        console.log("Remaining Deck Contents:", deck);

        await sendZoneUpdate(["Deck", "Hand"]);

        renderDrawnCards();
        updateDeckText();
        return drawnCards;
        }

        async function sendZoneUpdate(zones) {
            const updatedZones = {};
            zones.forEach(z => {
                updatedZones[z] = gameState[username][z];
            });

            await fetch('https://geimon-app-833627ba44e0.herokuapp.com/updateGameState', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                gameId,
                updatedZones,
                owner: username
                })
            });
        }

        // Function to update deck count visually
        function updateDeckCount() {
            if (playerDeckBox) {
                playerDeckBox.innerText = `Deck`;
            }
        }

        // Fetch and shuffle deck, then update count
        async function fetchAndShuffleDeck(deckParam) {
            let cardIds = [];

            try {
                // Try to parse as a JSON array
                const parsed = JSON.parse(deckParam);
                if (Array.isArray(parsed)) {
                    cardIds = parsed;
                } else {
                    // Fallback to server fetch
                    const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                        method: "POST",
                        credentials: "include",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify({ deck_name: deckParam }),
                    });

                    const data = await response.json();
                    if (!data.success) {
                        console.error("Error:", data.message);
                        return;
                    }

                    cardIds = data.card_ids;
                }
            } catch (e) {
                // Not valid JSON — must be a normal deck name
                const response = await fetch("https://geimon-app-833627ba44e0.herokuapp.com/getDeckCards", {
                    method: "POST",
                    credentials: "include",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ deck_name: deckParam }),
                });

                const data = await response.json();
                if (!data.success) {
                    console.error("Error:", data.message);
                    return;
                }

                cardIds = data.card_ids;
            }

            // At this point, cardIds is valid
            initialDeckSize = cardIds.length;
            remainingDeck = shuffleDeck(cardIds).map(id => ({
                id,
                boardState: "Deck",
                lastBoardState: null
            }));

            console.log("Deck Shuffled:", remainingDeck);
            console.log("Total Cards in Deck:", initialDeckSize);
        }

        // Attach event listeners to update deck count dynamically
        if (playerDeckBox) {
            playerDeckBox.addEventListener("mouseenter", () => {
                playerDeckBox.innerText = `${remainingDeck.length}`;
            });

            playerDeckBox.addEventListener("mouseleave", () => {
                playerDeckBox.innerText = "Deck";
            });
        }

    document.addEventListener("DOMContentLoaded", () => {
        const tooltip = document.getElementById("tooltip");
        const tokenTooltip = document.getElementById("token-tooltip");

        const tabs = document.querySelectorAll(".tab-button");
        const contents = document.querySelectorAll(".tab-content");

        tabs.forEach(tab => {
            tab.addEventListener("click", () => {
                tabs.forEach(t => t.classList.remove("active"));
                contents.forEach(c => c.classList.remove("active"));

                tab.classList.add("active");
                document.getElementById(tab.dataset.tab).classList.add("active");
            });
        });

        // Game Log Data Population
        const params = new URLSearchParams(window.location.search);
        document.getElementById("totem").textContent = params.get("totem");

        const dictionarySearch = document.getElementById("dictionary-search");
        const dictionaryResults = document.getElementById("dictionary-results");

        const loadAllTerms = () => {
            dictionaryResults.innerHTML = "";
            const allTerms = [...Object.entries(keywords), ...Object.entries(rules)];
            allTerms.sort((a, b) => a[0].localeCompare(b[0]));
            allTerms.forEach(([key, value]) => {
                const resultItem = document.createElement("p");
                resultItem.innerHTML = `<strong>${key}:</strong> ${value}`;
                dictionaryResults.appendChild(resultItem);
            });
        };
        loadAllTerms();

        dictionarySearch.addEventListener("input", () => {
            const query = dictionarySearch.value.toLowerCase();
            dictionaryResults.innerHTML = "";

            if (!query) {
                loadAllTerms();
                return;
            }

            const matchedKeywords = Object.entries(keywords).filter(([key]) =>
                key.toLowerCase().includes(query)
            );

            const matchedRules = Object.entries(rules).filter(([key]) =>
                key.toLowerCase().includes(query)
            );

            [...matchedKeywords, ...matchedRules].forEach(([key, value]) => {
                const resultItem = document.createElement("p");
                resultItem.innerHTML = `<strong>${key}:</strong> ${value}`;
                dictionaryResults.appendChild(resultItem);
            });
        });

        document.querySelectorAll(".keyword").forEach(keyword => {
            const description = keyword.dataset.description;

            if (description && description.trim() !== "") {
                keyword.addEventListener("mouseenter", (e) => {
                    tooltip.textContent = description;
                    tooltip.style.display = "block";
                    tokenTooltip.querySelector(".token-tooltip-text").textContent = description;
                    tokenTooltip.style.display = "block";
                });

                keyword.addEventListener("mouseleave", () => {
                    tooltip.style.display = "none";
                    tokenTooltip.style.display = "none";
                });

                keyword.addEventListener("mousemove", (e) => {
                    if (tooltip.style.display === "block") {
                        tooltip.style.left = `${e.pageX + 10}px`;
                        tooltip.style.top = `${e.pageY - 40}px`;
                    }
                    if (tokenTooltip.style.display === "block") { // ✅ Fix: Remove `else if`
                        tokenTooltip.style.left = `${e.pageX + 10}px`;
                        tokenTooltip.style.top = `${e.pageY - 40}px`;
                    }
                });
            }
        });
    });
    initGameClient();
    </script>
</body>
</html>